/* --- Generated by PLIC-CxxStub --- */

// --- ClientHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rapicorn-core.hh> // for rcore/rapicornsignal.hh
using Rapicorn::Signals::slot;

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __PLIC_GENERIC_CC_BOILERPLATE__
#define __PLIC_GENERIC_CC_BOILERPLATE__

#define PLIC_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("PLIC-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Plic::uint64;

static __attribute__ ((__format__ (__printf__, 1, 2), unused))
Plic::FieldBuffer* plic$_error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  Plic::error_vprintf (format, args);
  va_end (args);
  return NULL;
}

} // Anonymous
#endif // __PLIC_GENERIC_CC_BOILERPLATE__


#ifndef PLIC_CONNECTION
#define PLIC_CONNECTION()       (*(Plic::Connection*)NULL)
uint64               connection_handle2id  (const Plic::SmartHandle &h) { return h._rpc_id(); }
static inline void   connection_context4id (Plic::uint64 ipcid, Plic::NonCopyable *ctx) {}
template<class C> C* connection_id2context (uint64 oid) { return (C*) NULL; }
#endif // !PLIC_CONNECTION


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Empty {
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Empty &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Empty &e) { e = Empty (frr.pop_evalue()); return frr; }

enum Enum1 {
  E1_A = 1,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum1 &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); return frr; }

enum Enum1c {
  E1C_A = 1,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum1c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); return frr; }

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum2 &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); return frr; }

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum2c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); return frr; }

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum3 &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); return frr; }

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum3c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); return frr; }

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4a &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); return frr; }

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4b &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); return frr; }

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); return frr; }

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4d &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); return frr; }

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  ExtensiveEnum &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); return frr; }

class FirstInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class FirstInterface.
{
  static FirstInterface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static FirstInterface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      FirstInterface_SmartHandle ();
  void                          void_func                  ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const FirstInterface_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, FirstInterface_SmartHandle&);

struct XFooRecord_Handle {
  bool                          single_bool;
  int                           single_num;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  FirstInterface_SmartHandle    iface1;
  FirstInterface_SmartHandle    iface2;
  FirstInterface_SmartHandle    iface3;
  inline                        XFooRecord_Handle () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const XFooRecord_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, XFooRecord_Handle&);

struct XFooSequence_Handle : public std::vector<bool> {
  typedef std::vector<bool> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const XFooSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, XFooSequence_Handle&);

struct IntSequence_Handle : public std::vector<int> {
  typedef std::vector<int> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const IntSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, IntSequence_Handle&);

struct FloatSequence_Handle : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const FloatSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, FloatSequence_Handle&);

struct StringSequence_Handle : public std::vector<std::string> {
  typedef std::vector<std::string> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const StringSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, StringSequence_Handle&);

struct ExtensiveEnumSequence_Handle : public std::vector<ExtensiveEnum> {
  typedef std::vector<ExtensiveEnum> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const ExtensiveEnumSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, ExtensiveEnumSequence_Handle&);

struct RecordSequence_Handle : public std::vector<XFooRecord_Handle> {
  typedef std::vector<XFooRecord_Handle> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const RecordSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, RecordSequence_Handle&);

struct SequenceSequence_Handle : public std::vector<IntSequence_Handle> {
  typedef std::vector<IntSequence_Handle> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const SequenceSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, SequenceSequence_Handle&);

struct InterfaceSequence_Handle : public std::vector<FirstInterface_SmartHandle> {
  typedef std::vector<FirstInterface_SmartHandle> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const InterfaceSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, InterfaceSequence_Handle&);

struct NestedTypesRec_Handle {
  XFooRecord_Handle             rec;
  XFooSequence_Handle           seq;
  inline                        NestedTypesRec_Handle () { }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const NestedTypesRec_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, NestedTypesRec_Handle&);

struct NestedTypesSeq_Handle : public std::vector<NestedTypesRec_Handle> {
  typedef std::vector<NestedTypesRec_Handle> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const NestedTypesSeq_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, NestedTypesSeq_Handle&);

typedef int AliasInt;

typedef double AliasFloat;

typedef bool AliasBool;

typedef std::string AliasString;

typedef XFooRecord_Handle AliasRecord;

typedef XFooSequence_Handle AliasSequence;

typedef ExtensiveEnum AliasEnum;

struct NewRecord_Handle {
  int                           i;
  Enum1                         enum1;
  XFooSequence_Handle           xfs;
  NestedTypesRec_Handle         ntr;
  inline                        NewRecord_Handle () { i = 0; enum1 = Enum1 (0); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const NewRecord_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, NewRecord_Handle&);

namespace Inner {

struct InnerRecord_Handle {
  int                           x;
  int                           y;
  NewRecord_Handle              rec;
  inline                        InnerRecord_Handle () { x = 0; y = 0; }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const InnerRecord_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, InnerRecord_Handle&);
} // Inner

struct Refer2Inner_Handle {
  Inner::InnerRecord_Handle     r;
  inline                        Refer2Inner_Handle () { }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const Refer2Inner_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, Refer2Inner_Handle&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SomeRecord_Handle {
  MandatoryNamespace::NewRecord_Handle r1;
  MandatoryNamespace::NewRecord_Handle r2;
  MandatoryNamespace::Inner::InnerRecord_Handle r3;
  MandatoryNamespace::Inner::InnerRecord_Handle r4;
  inline                        SomeRecord_Handle () { }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const SomeRecord_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, SomeRecord_Handle&);
} // OtherNamespace

namespace Auxdata {

typedef int bar;

typedef double x;

typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class UIWidgetArea_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class UIWidgetArea.
{
  static UIWidgetArea_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  typedef Rapicorn::Signals::SignalProxy<UIWidgetArea_SmartHandle, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::SignalProxy<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint)> Signal_sample_signal;
public:
  template<class C>
  static UIWidgetArea_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      UIWidgetArea_SmartHandle ();
  double                        dummy    () const;
  void                          dummy    (double);
  std::string                   on_click () const;
  void                          on_click (const std::string&);
  Signal_void_signal            void_signal;
  Signal_sample_signal          sample_signal;
  double                        simple_method            ();
  double                        single_arg               (int n);
  double                        single_arg2              (int n = 5);
  double                        two_args                 (int n,
                                                          double r);
  double                        two_args2                (int n = 6,
                                                          double r = 7.7);
  double                        multi_args               (int n,
                                                          double r,
                                                          int i,
                                                          const std::string &s = "String ding",
                                                          double y = 5);
  double                        self_method              (UIWidgetArea_SmartHandle &ba1,
                                                          UIWidgetArea_SmartHandle &ba2);
  void                          void_method              ();
  std::string                   on_click2out             ();
  void                          on_click2in              (const std::string &command);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const UIWidgetArea_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, UIWidgetArea_SmartHandle&);

class Parent_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class Parent.
{
  static Parent_SmartHandle     _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static Parent_SmartHandle     downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      Parent_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const Parent_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, Parent_SmartHandle&);

class Child_SmartHandle : public Parent_SmartHandle
  /// See also the corresponding IDL class Child.
{
  static Child_SmartHandle      _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static Child_SmartHandle      downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      Child_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const Child_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, Child_SmartHandle&);

class Descendant_SmartHandle : public Child_SmartHandle
  /// See also the corresponding IDL class Descendant.
{
  static Descendant_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static Descendant_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      Descendant_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const Descendant_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, Descendant_SmartHandle&);

class GrandChild_SmartHandle : public Descendant_SmartHandle
  /// See also the corresponding IDL class GrandChild.
{
  static GrandChild_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static GrandChild_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      GrandChild_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const GrandChild_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, GrandChild_SmartHandle&);

enum QuickEnum {
  ZERO = 0,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  QuickEnum &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); return frr; }

struct QuickRecord_Handle {
  int                           int1;
  int                           int2;
  inline                        QuickRecord_Handle () { int1 = 0; int2 = 0; }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const QuickRecord_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, QuickRecord_Handle&);

struct QuickSequence_Handle : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const QuickSequence_Handle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, QuickSequence_Handle&);

class QuickIface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class QuickIface.
{
  static QuickIface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static QuickIface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      QuickIface_SmartHandle ();
  void                          simple_function        (int i = 9);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const QuickIface_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, QuickIface_SmartHandle&);

class MethodTestInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class MethodTestInterface.
{
  static MethodTestInterface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static MethodTestInterface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      MethodTestInterface_SmartHandle ();
  void                          method_with_void                ();
  bool                          method_with_bools               (bool input,
                                                                 bool optval = 0);
  int                           method_with_ints                (int input,
                                                                 int optval = -2);
  double                        method_with_floats              (double input,
                                                                 double optval = 309.9);
  std::string                   method_with_string              (const std::string &input,
                                                                 const std::string &optval = "default");
  QuickEnum                     method_with_enum                (QuickEnum input,
                                                                 QuickEnum optval = QuickEnum (0));
  QuickRecord_Handle            method_with_record              (const QuickRecord_Handle &input,
                                                                 const QuickRecord_Handle &optval = QuickRecord_Handle());
  QuickSequence_Handle          method_with_sequence            (const QuickSequence_Handle &input,
                                                                 const QuickSequence_Handle &optval = QuickSequence_Handle());
  GrandChild_SmartHandle        method_with_interface           (GrandChild_SmartHandle &input,
                                                                 GrandChild_SmartHandle &optval = *(GrandChild_SmartHandle*) NULL);
  QuickIface_SmartHandle        method_with_quickiface          (QuickIface_SmartHandle &input,
                                                                 QuickIface_SmartHandle &iface0 = *(QuickIface_SmartHandle*) NULL);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const MethodTestInterface_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, MethodTestInterface_SmartHandle&);

class SignalTestInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class SignalTestInterface.
{
  static SignalTestInterface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void ()> Signal_void_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, int ()> Signal_int_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, double ()> Signal_float_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickRecord_Handle ()> Signal_record_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickSequence_Handle ()> Signal_sequence_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, GrandChild_SmartHandle ()> Signal_interface_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle ()> Signal_self_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r)> Signal_record_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_)> Signal_self_args;
public:
  template<class C>
  static SignalTestInterface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      SignalTestInterface_SmartHandle ();
  Signal_void_result            void_result;
  Signal_bool_result            bool_result;
  Signal_int_result             int_result;
  Signal_float_result           float_result;
  Signal_string_result          string_result;
  Signal_enum_result            enum_result;
  Signal_record_result          record_result;
  Signal_sequence_result        sequence_result;
  Signal_interface_result       interface_result;
  Signal_self_result            self_result;
  Signal_void_arg               void_arg;
  Signal_bool_arg               bool_arg;
  Signal_int_arg                int_arg;
  Signal_float_arg              float_arg;
  Signal_string_arg             string_arg;
  Signal_enum_arg               enum_arg;
  Signal_record_arg             record_arg;
  Signal_sequence_arg           sequence_arg;
  Signal_interface_arg          interface_arg;
  Signal_self_args              self_args;
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const SignalTestInterface_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, SignalTestInterface_SmartHandle&);

class PropertyTester_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class PropertyTester.
{
  static PropertyTester_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static PropertyTester_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      PropertyTester_SmartHandle ();
  bool                          bool_prop      () const;
  void                          bool_prop      (bool);
  int                           int_prop       () const;
  void                          int_prop       (int);
  double                        float_prop     () const;
  void                          float_prop     (double);
  std::string                   string_prop    () const;
  void                          string_prop    (const std::string&);
  QuickEnum                     enum_prop      () const;
  void                          enum_prop      (QuickEnum);
  QuickRecord_Handle            record_prop    () const;
  void                          record_prop    (const QuickRecord_Handle&);
  QuickSequence_Handle          sequence_prop  () const;
  void                          sequence_prop  (const QuickSequence_Handle&);
  GrandChild_SmartHandle        interface_prop () const;
  void                          interface_prop (GrandChild_SmartHandle);
  PropertyTester_SmartHandle    self_prop      () const;
  void                          self_prop      (PropertyTester_SmartHandle);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const PropertyTester_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, PropertyTester_SmartHandle&);
} // InterfaceTests

namespace RapicornPlicTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  ClickType &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); return frr; }

class ButtonArea_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class ButtonArea.
{
  static ButtonArea_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  typedef Rapicorn::Signals::SignalProxy<ButtonArea_SmartHandle, bool ()> Signal_check_activate;
  typedef Rapicorn::Signals::SignalProxy<ButtonArea_SmartHandle, void ()> Signal_activate;
public:
  template<class C>
  static ButtonArea_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      ButtonArea_SmartHandle ();
  std::string                   on_click   () const;
  void                          on_click   (const std::string&);
  std::string                   on_click2  () const;
  void                          on_click2  (const std::string&);
  std::string                   on_click3  () const;
  void                          on_click3  (const std::string&);
  ClickType                     click_type () const;
  void                          click_type (ClickType);
  Signal_check_activate         check_activate;
  Signal_activate               activate;
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const ButtonArea_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, ButtonArea_SmartHandle&);

class PureMethods_SmartHandle;

class PureMethods_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class PureMethods.
{
  static PureMethods_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static PureMethods_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      PureMethods_SmartHandle ();
  int                           pure_method             (double f);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const PureMethods_SmartHandle&);
Plic::FieldReader& operator>> (Plic::FieldReader&, PureMethods_SmartHandle&);
} // RapicornPlicTest

// --- Implementations ---

namespace MandatoryNamespace {

// === FirstInterface ===
static inline void ref   (FirstInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (FirstInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct FirstInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public FirstInterface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  FirstInterface_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
FirstInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3e0c8f5da9110ad8ULL, 0xea565508333a9035ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
FirstInterface_SmartHandle::FirstInterface_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const FirstInterface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, FirstInterface_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<FirstInterface_Context$> (ipcid)->handle$ : FirstInterface_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
FirstInterface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x04be3719c81a379bULL, 0x1079454a90442f2cULL);
  return type_hash;
}
FirstInterface_SmartHandle
FirstInterface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<FirstInterface_Context$> (connection_handle2id (other))->handle$;
  return FirstInterface_SmartHandle();
}
const Plic::TypeHashList&
FirstInterface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<FirstInterface_Context$> (ipcid)->list_types();
}
void
FirstInterface_SmartHandle::void_func ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x209463c55becedadULL, 0x39ddfcb9aadc3c74ULL); // msgid
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const XFooRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (14);
  fb << self.single_bool;
  fb << self.single_num;
  fb << self.single_float;
  fb << self.single_string;
  fb << self.sibling1;
  fb << self.sibling2;
  fb << self.multi1;
  fb << self.multi2;
  fb << self.multi3;
  fb << self.multi4;
  fb << self.enum_field;
  fb << self.iface1;
  fb << self.iface2;
  fb << self.iface3;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, XFooRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 14) return src;
  fbr >> self.single_bool;
  fbr >> self.single_num;
  fbr >> self.single_float;
  fbr >> self.single_string;
  fbr >> self.sibling1;
  fbr >> self.sibling2;
  fbr >> self.multi1;
  fbr >> self.multi2;
  fbr >> self.multi3;
  fbr >> self.multi4;
  fbr >> self.enum_field;
  fbr >> self.iface1;
  fbr >> self.iface2;
  fbr >> self.iface3;
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const XFooSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, XFooSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const IntSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, IntSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const FloatSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, FloatSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const StringSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, StringSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const ExtensiveEnumSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, ExtensiveEnumSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const RecordSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, RecordSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const SequenceSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, SequenceSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const InterfaceSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, InterfaceSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const NestedTypesRec_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb << self.rec;
  fb << self.seq;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, NestedTypesRec_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return src;
  fbr >> self.rec;
  fbr >> self.seq;
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const NestedTypesSeq_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, NestedTypesSeq_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const NewRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb << self.i;
  fb << self.enum1;
  fb << self.xfs;
  fb << self.ntr;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, NewRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return src;
  fbr >> self.i;
  fbr >> self.enum1;
  fbr >> self.xfs;
  fbr >> self.ntr;
  return src;
}

namespace Inner {
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const InnerRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  fb << self.x;
  fb << self.y;
  fb << self.rec;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, InnerRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return src;
  fbr >> self.x;
  fbr >> self.y;
  fbr >> self.rec;
  return src;
}
} // Inner
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const Refer2Inner_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  fb << self.r;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, Refer2Inner_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return src;
  fbr >> self.r;
  return src;
}
} // MandatoryNamespace

namespace OtherNamespace {
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const SomeRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb << self.r1;
  fb << self.r2;
  fb << self.r3;
  fb << self.r4;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, SomeRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return src;
  fbr >> self.r1;
  fbr >> self.r2;
  fbr >> self.r3;
  fbr >> self.r4;
  return src;
}
} // OtherNamespace

namespace InterfaceTests {

// === UIWidgetArea ===
static inline void ref   (UIWidgetArea_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (UIWidgetArea_SmartHandle&) {} // dummy stub for Signal<>.emit
struct UIWidgetArea_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public UIWidgetArea_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  struct Signal_void_signal_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_void_signal_EventHandler$> > Signal_void_signal;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_void_signal signal;
    Signal_void_signal_EventHandler$ (UIWidgetArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_void_signal_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } void_signal;
  struct Signal_sample_signal_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint), Rapicorn::Signals::CollectorDefault<double>, Rapicorn::Signals::SignalConnectionRelay<Signal_sample_signal_EventHandler$> > Signal_sample_signal;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_sample_signal signal;
    Signal_sample_signal_EventHandler$ (UIWidgetArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_sample_signal_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } sample_signal;
  UIWidgetArea_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    void_signal (handle$),
    sample_signal (handle$),
    m_cached_types (NULL)
  {
    handle$.void_signal = void_signal.signal;
    void_signal.signal.listener (void_signal, &Signal_void_signal_EventHandler$::connections_changed);
    handle$.sample_signal = sample_signal.signal;
    sample_signal.signal.listener (sample_signal, &Signal_sample_signal_EventHandler$::connections_changed);
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
UIWidgetArea_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3b205dd851cb8a1dULL, 0x5bcddc39beffee0dULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
void
UIWidgetArea_Context$::Signal_void_signal_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x52ef738c2571d0f2ULL, 0x05b653adf0a80acfULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
UIWidgetArea_Context$::Signal_void_signal_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
void
UIWidgetArea_Context$::Signal_sample_signal_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x511bbb2e2b129d5bULL, 0xe7152819ec289550ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
UIWidgetArea_Context$::Signal_sample_signal_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 2) return plic$_error ("invalid number of arguments");
  UIWidgetArea_SmartHandle  arg_ba1;
  fbr >> arg_ba1;
  int  arg_someint;
  fbr >> arg_someint;
  double  rval = signal.emit (arg_ba1, arg_someint);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, void ()> UIWidgetArea_SmartHandle_Signal_void_signal;
typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint)> UIWidgetArea_SmartHandle_Signal_sample_signal;
UIWidgetArea_SmartHandle::UIWidgetArea_SmartHandle () :
  void_signal (*(UIWidgetArea_SmartHandle_Signal_void_signal*) NULL),
  sample_signal (*(UIWidgetArea_SmartHandle_Signal_sample_signal*) NULL)
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const UIWidgetArea_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, UIWidgetArea_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<UIWidgetArea_Context$> (ipcid)->handle$ : UIWidgetArea_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
UIWidgetArea_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0c1b9195fa9a5a6cULL, 0xc1f636e721317b86ULL);
  return type_hash;
}
UIWidgetArea_SmartHandle
UIWidgetArea_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<UIWidgetArea_Context$> (connection_handle2id (other))->handle$;
  return UIWidgetArea_SmartHandle();
}
const Plic::TypeHashList&
UIWidgetArea_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<UIWidgetArea_Context$> (ipcid)->list_types();
}
double
UIWidgetArea_SmartHandle::dummy () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x39146750080bd117ULL, 0x9edc3ab3b5e82e8dULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::dummy (double value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a284d0b5305ac3aULL, 0xd98a1d86235ad649ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
UIWidgetArea_SmartHandle::on_click () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x37b8129e6139dfaeULL, 0xece65fb7aeda0163ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::on_click (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2d15d46bb30e2a40ULL, 0xc421a429912efd6dULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
UIWidgetArea_SmartHandle::simple_method ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x39a122b559d15903ULL, 0x0a95fe35b7a1de33ULL); // msgid
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::single_arg (int arg_n)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3910395d202c93c2ULL, 0x9206a89acaaf2086ULL); // msgid
  fb << (*this);
  fb << arg_n;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::single_arg2 (int arg_n)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3b5ae84b86dfa59cULL, 0x5d2ef3880b1fa360ULL); // msgid
  fb << (*this);
  fb << arg_n;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::two_args (int arg_n,
                                    double arg_r)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x359c33f1677a63ebULL, 0x3a05748016992575ULL); // msgid
  fb << (*this);
  fb << arg_n;
  fb << arg_r;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::two_args2 (int arg_n,
                                     double arg_r)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3291a584ff9121b3ULL, 0xbd14f4bbc47fb2ccULL); // msgid
  fb << (*this);
  fb << arg_n;
  fb << arg_r;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::multi_args (int arg_n,
                                      double arg_r,
                                      int arg_i,
                                      const std::string &arg_s,
                                      double arg_y)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 5), *fr = NULL;
  fb.add_msgid (0x3501ef84b7c1d9ffULL, 0x564566ab8a5e1b8bULL); // msgid
  fb << (*this);
  fb << arg_n;
  fb << arg_r;
  fb << arg_i;
  fb << arg_s;
  fb << arg_y;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::self_method (UIWidgetArea_SmartHandle &arg_ba1,
                                       UIWidgetArea_SmartHandle &arg_ba2)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x316521a2bcc037d0ULL, 0x43987053dab0c3c0ULL); // msgid
  fb << (*this);
  fb << arg_ba1;
  fb << arg_ba2;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::void_method ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x2e02c52c84773703ULL, 0x00027e452edb615cULL); // msgid
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}
std::string
UIWidgetArea_SmartHandle::on_click2out ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x3e4f2ff4e1424783ULL, 0x439ed3d602e3946eULL); // msgid
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::on_click2in (const std::string &arg_command)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2294f15cd15e9458ULL, 0x5e0ac9b493bb4f17ULL); // msgid
  fb << (*this);
  fb << arg_command;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}

// === Parent ===
static inline void ref   (Parent_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Parent_SmartHandle&) {} // dummy stub for Signal<>.emit
struct Parent_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Parent_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Parent_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
Parent_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x358122a8447018eaULL, 0xf27025a07a51a48aULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
Parent_SmartHandle::Parent_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const Parent_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, Parent_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<Parent_Context$> (ipcid)->handle$ : Parent_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
Parent_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL);
  return type_hash;
}
Parent_SmartHandle
Parent_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Parent_Context$> (connection_handle2id (other))->handle$;
  return Parent_SmartHandle();
}
const Plic::TypeHashList&
Parent_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Parent_Context$> (ipcid)->list_types();
}

// === Child ===
static inline void ref   (Child_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Child_SmartHandle&) {} // dummy stub for Signal<>.emit
struct Child_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Child_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Child_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
Child_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3d9ee6a844c60394ULL, 0xd2cee7633ad091d5ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
Child_SmartHandle::Child_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const Child_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, Child_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<Child_Context$> (ipcid)->handle$ : Child_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
Child_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0a44a1b5cf26cfc0ULL, 0xcd6e05d08ba2667eULL);
  return type_hash;
}
Child_SmartHandle
Child_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Child_Context$> (connection_handle2id (other))->handle$;
  return Child_SmartHandle();
}
const Plic::TypeHashList&
Child_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Child_Context$> (ipcid)->list_types();
}

// === Descendant ===
static inline void ref   (Descendant_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Descendant_SmartHandle&) {} // dummy stub for Signal<>.emit
struct Descendant_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Descendant_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Descendant_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
Descendant_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3a8b819b364228b8ULL, 0x9dce3529210a7700ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
Descendant_SmartHandle::Descendant_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const Descendant_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, Descendant_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<Descendant_Context$> (ipcid)->handle$ : Descendant_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
Descendant_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0980fc7a8521c350ULL, 0x641568ba1f461de2ULL);
  return type_hash;
}
Descendant_SmartHandle
Descendant_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Descendant_Context$> (connection_handle2id (other))->handle$;
  return Descendant_SmartHandle();
}
const Plic::TypeHashList&
Descendant_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Descendant_Context$> (ipcid)->list_types();
}

// === GrandChild ===
static inline void ref   (GrandChild_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (GrandChild_SmartHandle&) {} // dummy stub for Signal<>.emit
struct GrandChild_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public GrandChild_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  GrandChild_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
GrandChild_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3aa9daa434261f37ULL, 0xa848862e429bf919ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
GrandChild_SmartHandle::GrandChild_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const GrandChild_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, GrandChild_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<GrandChild_Context$> (ipcid)->handle$ : GrandChild_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
GrandChild_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x001a87e60ed9bd66ULL, 0xfff1a96d7bab9cd9ULL);
  return type_hash;
}
GrandChild_SmartHandle
GrandChild_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<GrandChild_Context$> (connection_handle2id (other))->handle$;
  return GrandChild_SmartHandle();
}
const Plic::TypeHashList&
GrandChild_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<GrandChild_Context$> (ipcid)->list_types();
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const QuickRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb << self.int1;
  fb << self.int2;
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, QuickRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return src;
  fbr >> self.int1;
  fbr >> self.int2;
  return src;
}
inline Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &dst, const QuickSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
  return dst;
}
inline Plic::FieldReader&
operator>> (Plic::FieldReader &src, QuickSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
  return src;
}

// === QuickIface ===
static inline void ref   (QuickIface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (QuickIface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct QuickIface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public QuickIface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  QuickIface_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
QuickIface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3ceafdc3043b707dULL, 0xf30106bb4338c235ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
QuickIface_SmartHandle::QuickIface_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const QuickIface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, QuickIface_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<QuickIface_Context$> (ipcid)->handle$ : QuickIface_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
QuickIface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0ce40c896cfa0177ULL, 0x5ab6faf97ff6fed2ULL);
  return type_hash;
}
QuickIface_SmartHandle
QuickIface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<QuickIface_Context$> (connection_handle2id (other))->handle$;
  return QuickIface_SmartHandle();
}
const Plic::TypeHashList&
QuickIface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<QuickIface_Context$> (ipcid)->list_types();
}
void
QuickIface_SmartHandle::simple_function (int arg_i)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2446078b004b9aabULL, 0x37d6c73a34ac7070ULL); // msgid
  fb << (*this);
  fb << arg_i;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}

// === MethodTestInterface ===
static inline void ref   (MethodTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (MethodTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct MethodTestInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public MethodTestInterface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  MethodTestInterface_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
MethodTestInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x363e0b9e750bbbe2ULL, 0x8b5953ab5fb23a59ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
MethodTestInterface_SmartHandle::MethodTestInterface_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const MethodTestInterface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, MethodTestInterface_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<MethodTestInterface_Context$> (ipcid)->handle$ : MethodTestInterface_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
MethodTestInterface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x03befccd5d5ee8d5ULL, 0x7f1f65a869ad267fULL);
  return type_hash;
}
MethodTestInterface_SmartHandle
MethodTestInterface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<MethodTestInterface_Context$> (connection_handle2id (other))->handle$;
  return MethodTestInterface_SmartHandle();
}
const Plic::TypeHashList&
MethodTestInterface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<MethodTestInterface_Context$> (ipcid)->list_types();
}
void
MethodTestInterface_SmartHandle::method_with_void ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x281392e54343bee9ULL, 0x0dbeb788728dbff4ULL); // msgid
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}
bool
MethodTestInterface_SmartHandle::method_with_bools (bool arg_input,
                                                    bool arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b68546991e25342ULL, 0xa71399caec9ccfc7ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >> retval;
  delete fr;
  return retval;
}
int
MethodTestInterface_SmartHandle::method_with_ints (int arg_input,
                                                   int arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x39555e79a31047bfULL, 0x0f06b4f122a81e1dULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >> retval;
  delete fr;
  return retval;
}
double
MethodTestInterface_SmartHandle::method_with_floats (double arg_input,
                                                     double arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x391dd7c671dada38ULL, 0x32ca18bc1bd39689ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
std::string
MethodTestInterface_SmartHandle::method_with_string (const std::string &arg_input,
                                                     const std::string &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3ad5eafe588b965aULL, 0x38c04145925d2963ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
QuickEnum
MethodTestInterface_SmartHandle::method_with_enum (QuickEnum arg_input,
                                                   QuickEnum arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x387f08a5c150e6a7ULL, 0x83c133fcd2be3200ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval;
  frr >> retval;
  delete fr;
  return retval;
}
QuickRecord_Handle
MethodTestInterface_SmartHandle::method_with_record (const QuickRecord_Handle &arg_input,
                                                     const QuickRecord_Handle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b59b493f287edf0ULL, 0x4771d353c78389d1ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecord_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
QuickSequence_Handle
MethodTestInterface_SmartHandle::method_with_sequence (const QuickSequence_Handle &arg_input,
                                                       const QuickSequence_Handle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34c9e8a686a7f261ULL, 0x9af099b173ac979cULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequence_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
GrandChild_SmartHandle
MethodTestInterface_SmartHandle::method_with_interface (GrandChild_SmartHandle &arg_input,
                                                        GrandChild_SmartHandle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34619983babcee5bULL, 0x9875f78f28f381b7ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  GrandChild_SmartHandle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
QuickIface_SmartHandle
MethodTestInterface_SmartHandle::method_with_quickiface (QuickIface_SmartHandle &arg_input,
                                                         QuickIface_SmartHandle &arg_iface0)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3a2ab33a8358edcbULL, 0x7c028db9464052a0ULL); // msgid
  fb << (*this);
  fb << arg_input;
  fb << arg_iface0;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickIface_SmartHandle  retval;
  frr >> retval;
  delete fr;
  return retval;
}

// === SignalTestInterface ===
static inline void ref   (SignalTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (SignalTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct SignalTestInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public SignalTestInterface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  struct Signal_void_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_void_result_EventHandler$> > Signal_void_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_void_result signal;
    Signal_void_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_void_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } void_result;
  struct Signal_bool_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, bool (), Rapicorn::Signals::CollectorDefault<bool>, Rapicorn::Signals::SignalConnectionRelay<Signal_bool_result_EventHandler$> > Signal_bool_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_bool_result signal;
    Signal_bool_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_bool_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } bool_result;
  struct Signal_int_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, int (), Rapicorn::Signals::CollectorDefault<int>, Rapicorn::Signals::SignalConnectionRelay<Signal_int_result_EventHandler$> > Signal_int_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_int_result signal;
    Signal_int_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_int_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } int_result;
  struct Signal_float_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, double (), Rapicorn::Signals::CollectorDefault<double>, Rapicorn::Signals::SignalConnectionRelay<Signal_float_result_EventHandler$> > Signal_float_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_float_result signal;
    Signal_float_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_float_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } float_result;
  struct Signal_string_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, std::string (), Rapicorn::Signals::CollectorDefault<std::string>, Rapicorn::Signals::SignalConnectionRelay<Signal_string_result_EventHandler$> > Signal_string_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_string_result signal;
    Signal_string_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_string_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } string_result;
  struct Signal_enum_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickEnum (), Rapicorn::Signals::CollectorDefault<QuickEnum>, Rapicorn::Signals::SignalConnectionRelay<Signal_enum_result_EventHandler$> > Signal_enum_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_enum_result signal;
    Signal_enum_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_enum_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } enum_result;
  struct Signal_record_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickRecord_Handle (), Rapicorn::Signals::CollectorDefault<QuickRecord_Handle>, Rapicorn::Signals::SignalConnectionRelay<Signal_record_result_EventHandler$> > Signal_record_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_record_result signal;
    Signal_record_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_record_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } record_result;
  struct Signal_sequence_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickSequence_Handle (), Rapicorn::Signals::CollectorDefault<QuickSequence_Handle>, Rapicorn::Signals::SignalConnectionRelay<Signal_sequence_result_EventHandler$> > Signal_sequence_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_sequence_result signal;
    Signal_sequence_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_sequence_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } sequence_result;
  struct Signal_interface_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, GrandChild_SmartHandle (), Rapicorn::Signals::CollectorDefault<GrandChild_SmartHandle>, Rapicorn::Signals::SignalConnectionRelay<Signal_interface_result_EventHandler$> > Signal_interface_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_interface_result signal;
    Signal_interface_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_interface_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } interface_result;
  struct Signal_self_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle (), Rapicorn::Signals::CollectorDefault<SignalTestInterface_SmartHandle>, Rapicorn::Signals::SignalConnectionRelay<Signal_self_result_EventHandler$> > Signal_self_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_self_result signal;
    Signal_self_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_self_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } self_result;
  struct Signal_void_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_void_arg_EventHandler$> > Signal_void_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_void_arg signal;
    Signal_void_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_void_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } void_arg;
  struct Signal_bool_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (bool b), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_bool_arg_EventHandler$> > Signal_bool_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_bool_arg signal;
    Signal_bool_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_bool_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } bool_arg;
  struct Signal_int_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (int i), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_int_arg_EventHandler$> > Signal_int_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_int_arg signal;
    Signal_int_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_int_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } int_arg;
  struct Signal_float_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (double f), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_float_arg_EventHandler$> > Signal_float_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_float_arg signal;
    Signal_float_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_float_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } float_arg;
  struct Signal_string_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const std::string &s), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_string_arg_EventHandler$> > Signal_string_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_string_arg signal;
    Signal_string_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_string_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } string_arg;
  struct Signal_enum_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (QuickEnum e), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_enum_arg_EventHandler$> > Signal_enum_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_enum_arg signal;
    Signal_enum_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_enum_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } enum_arg;
  struct Signal_record_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_record_arg_EventHandler$> > Signal_record_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_record_arg signal;
    Signal_record_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_record_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } record_arg;
  struct Signal_sequence_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_sequence_arg_EventHandler$> > Signal_sequence_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_sequence_arg signal;
    Signal_sequence_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_sequence_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } sequence_arg;
  struct Signal_interface_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_interface_arg_EventHandler$> > Signal_interface_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_interface_arg signal;
    Signal_interface_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_interface_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } interface_arg;
  struct Signal_self_args_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_self_args_EventHandler$> > Signal_self_args;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_self_args signal;
    Signal_self_args_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_self_args_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } self_args;
  SignalTestInterface_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    void_result (handle$),
    bool_result (handle$),
    int_result (handle$),
    float_result (handle$),
    string_result (handle$),
    enum_result (handle$),
    record_result (handle$),
    sequence_result (handle$),
    interface_result (handle$),
    self_result (handle$),
    void_arg (handle$),
    bool_arg (handle$),
    int_arg (handle$),
    float_arg (handle$),
    string_arg (handle$),
    enum_arg (handle$),
    record_arg (handle$),
    sequence_arg (handle$),
    interface_arg (handle$),
    self_args (handle$),
    m_cached_types (NULL)
  {
    handle$.void_result = void_result.signal;
    void_result.signal.listener (void_result, &Signal_void_result_EventHandler$::connections_changed);
    handle$.bool_result = bool_result.signal;
    bool_result.signal.listener (bool_result, &Signal_bool_result_EventHandler$::connections_changed);
    handle$.int_result = int_result.signal;
    int_result.signal.listener (int_result, &Signal_int_result_EventHandler$::connections_changed);
    handle$.float_result = float_result.signal;
    float_result.signal.listener (float_result, &Signal_float_result_EventHandler$::connections_changed);
    handle$.string_result = string_result.signal;
    string_result.signal.listener (string_result, &Signal_string_result_EventHandler$::connections_changed);
    handle$.enum_result = enum_result.signal;
    enum_result.signal.listener (enum_result, &Signal_enum_result_EventHandler$::connections_changed);
    handle$.record_result = record_result.signal;
    record_result.signal.listener (record_result, &Signal_record_result_EventHandler$::connections_changed);
    handle$.sequence_result = sequence_result.signal;
    sequence_result.signal.listener (sequence_result, &Signal_sequence_result_EventHandler$::connections_changed);
    handle$.interface_result = interface_result.signal;
    interface_result.signal.listener (interface_result, &Signal_interface_result_EventHandler$::connections_changed);
    handle$.self_result = self_result.signal;
    self_result.signal.listener (self_result, &Signal_self_result_EventHandler$::connections_changed);
    handle$.void_arg = void_arg.signal;
    void_arg.signal.listener (void_arg, &Signal_void_arg_EventHandler$::connections_changed);
    handle$.bool_arg = bool_arg.signal;
    bool_arg.signal.listener (bool_arg, &Signal_bool_arg_EventHandler$::connections_changed);
    handle$.int_arg = int_arg.signal;
    int_arg.signal.listener (int_arg, &Signal_int_arg_EventHandler$::connections_changed);
    handle$.float_arg = float_arg.signal;
    float_arg.signal.listener (float_arg, &Signal_float_arg_EventHandler$::connections_changed);
    handle$.string_arg = string_arg.signal;
    string_arg.signal.listener (string_arg, &Signal_string_arg_EventHandler$::connections_changed);
    handle$.enum_arg = enum_arg.signal;
    enum_arg.signal.listener (enum_arg, &Signal_enum_arg_EventHandler$::connections_changed);
    handle$.record_arg = record_arg.signal;
    record_arg.signal.listener (record_arg, &Signal_record_arg_EventHandler$::connections_changed);
    handle$.sequence_arg = sequence_arg.signal;
    sequence_arg.signal.listener (sequence_arg, &Signal_sequence_arg_EventHandler$::connections_changed);
    handle$.interface_arg = interface_arg.signal;
    interface_arg.signal.listener (interface_arg, &Signal_interface_arg_EventHandler$::connections_changed);
    handle$.self_args = self_args.signal;
    self_args.signal.listener (self_args, &Signal_self_args_EventHandler$::connections_changed);
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
SignalTestInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3b2248e8e9d4ff05ULL, 0xda71e710449d85dfULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
void
SignalTestInterface_Context$::Signal_void_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x535d5e95471873b6ULL, 0x7a9f5692ce00e007ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_void_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
void
SignalTestInterface_Context$::Signal_bool_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x51ffffa2f8db1b1bULL, 0x3e01434baf49eceeULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_bool_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  bool  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_int_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x51ac083cdc878affULL, 0x72ad7414773447a2ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_int_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  int  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_float_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5cc54429499b42b6ULL, 0x35e1fb7707130bcaULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_float_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  double  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_string_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5790f575b6cac788ULL, 0x27db8e3c014993a7ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_string_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  std::string  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_enum_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x56fc6f3f4946e7b2ULL, 0x0fe0cc5f83d2ab84ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_enum_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  QuickEnum  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_record_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x50b723665ed298a5ULL, 0x32aa063680a4e3c0ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_record_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  QuickRecord_Handle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_sequence_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5ef00325dfcf4552ULL, 0x991130ecddd21730ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_sequence_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  QuickSequence_Handle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_interface_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x58e8587c542d85ceULL, 0xe2b572e902c69f7cULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_interface_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  GrandChild_SmartHandle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_self_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x59bb2da621bab28fULL, 0x32bc82e7eb9bc512ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_self_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  SignalTestInterface_SmartHandle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_void_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x583dc36c7785c7f3ULL, 0xb330cefa4e8247a9ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_void_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
void
SignalTestInterface_Context$::Signal_bool_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5f7ba898d12986bfULL, 0x8a1143a5f6dc85b8ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_bool_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  bool  arg_b;
  fbr >> arg_b;
  signal.emit (arg_b);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_int_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5f91dc79c2bee013ULL, 0x809b90b2fad4ea0aULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_int_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  int  arg_i;
  fbr >> arg_i;
  signal.emit (arg_i);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_float_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5d5c43cd47b258caULL, 0xb0d5fde097d6d12cULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_float_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  double  arg_f;
  fbr >> arg_f;
  signal.emit (arg_f);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_string_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x53de7a105b57bf62ULL, 0x9d8ffe4942a0934fULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_string_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  std::string  arg_s;
  fbr >> arg_s;
  signal.emit (arg_s);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_enum_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x586138796f133c4dULL, 0x1c7573f2d30ac907ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_enum_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  QuickEnum  arg_e;
  fbr >> arg_e;
  signal.emit (arg_e);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_record_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x59cb77461ddeac82ULL, 0xfeaa98721bd8ecd3ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_record_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  QuickRecord_Handle  arg_r;
  fbr >> arg_r;
  signal.emit (arg_r);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_sequence_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x547b4dd41606b568ULL, 0x1d763791a33d2bc9ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_sequence_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  QuickSequence_Handle  arg_s;
  fbr >> arg_s;
  signal.emit (arg_s);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_interface_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x57a5dbfbeb5a4ef9ULL, 0xb5df0c3b3bba4b22ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_interface_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  GrandChild_SmartHandle  arg_i;
  fbr >> arg_i;
  signal.emit (arg_i);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_self_args_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5c515ee37b78a970ULL, 0xe89c2af2f29359a0ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_self_args_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  SignalTestInterface_SmartHandle  arg_self_;
  fbr >> arg_self_;
  signal.emit (arg_self_);
  return NULL;
}
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void ()> SignalTestInterface_SmartHandle_Signal_void_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, bool ()> SignalTestInterface_SmartHandle_Signal_bool_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, int ()> SignalTestInterface_SmartHandle_Signal_int_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, double ()> SignalTestInterface_SmartHandle_Signal_float_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, std::string ()> SignalTestInterface_SmartHandle_Signal_string_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickEnum ()> SignalTestInterface_SmartHandle_Signal_enum_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickRecord_Handle ()> SignalTestInterface_SmartHandle_Signal_record_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickSequence_Handle ()> SignalTestInterface_SmartHandle_Signal_sequence_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, GrandChild_SmartHandle ()> SignalTestInterface_SmartHandle_Signal_interface_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle ()> SignalTestInterface_SmartHandle_Signal_self_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void ()> SignalTestInterface_SmartHandle_Signal_void_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (bool b)> SignalTestInterface_SmartHandle_Signal_bool_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (int i)> SignalTestInterface_SmartHandle_Signal_int_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (double f)> SignalTestInterface_SmartHandle_Signal_float_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const std::string &s)> SignalTestInterface_SmartHandle_Signal_string_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (QuickEnum e)> SignalTestInterface_SmartHandle_Signal_enum_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r)> SignalTestInterface_SmartHandle_Signal_record_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s)> SignalTestInterface_SmartHandle_Signal_sequence_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i)> SignalTestInterface_SmartHandle_Signal_interface_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_)> SignalTestInterface_SmartHandle_Signal_self_args;
SignalTestInterface_SmartHandle::SignalTestInterface_SmartHandle () :
  void_result (*(SignalTestInterface_SmartHandle_Signal_void_result*) NULL),
  bool_result (*(SignalTestInterface_SmartHandle_Signal_bool_result*) NULL),
  int_result (*(SignalTestInterface_SmartHandle_Signal_int_result*) NULL),
  float_result (*(SignalTestInterface_SmartHandle_Signal_float_result*) NULL),
  string_result (*(SignalTestInterface_SmartHandle_Signal_string_result*) NULL),
  enum_result (*(SignalTestInterface_SmartHandle_Signal_enum_result*) NULL),
  record_result (*(SignalTestInterface_SmartHandle_Signal_record_result*) NULL),
  sequence_result (*(SignalTestInterface_SmartHandle_Signal_sequence_result*) NULL),
  interface_result (*(SignalTestInterface_SmartHandle_Signal_interface_result*) NULL),
  self_result (*(SignalTestInterface_SmartHandle_Signal_self_result*) NULL),
  void_arg (*(SignalTestInterface_SmartHandle_Signal_void_arg*) NULL),
  bool_arg (*(SignalTestInterface_SmartHandle_Signal_bool_arg*) NULL),
  int_arg (*(SignalTestInterface_SmartHandle_Signal_int_arg*) NULL),
  float_arg (*(SignalTestInterface_SmartHandle_Signal_float_arg*) NULL),
  string_arg (*(SignalTestInterface_SmartHandle_Signal_string_arg*) NULL),
  enum_arg (*(SignalTestInterface_SmartHandle_Signal_enum_arg*) NULL),
  record_arg (*(SignalTestInterface_SmartHandle_Signal_record_arg*) NULL),
  sequence_arg (*(SignalTestInterface_SmartHandle_Signal_sequence_arg*) NULL),
  interface_arg (*(SignalTestInterface_SmartHandle_Signal_interface_arg*) NULL),
  self_args (*(SignalTestInterface_SmartHandle_Signal_self_args*) NULL)
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const SignalTestInterface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, SignalTestInterface_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<SignalTestInterface_Context$> (ipcid)->handle$ : SignalTestInterface_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
SignalTestInterface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0acc338edd01a172ULL, 0x27c5f8854a5f9458ULL);
  return type_hash;
}
SignalTestInterface_SmartHandle
SignalTestInterface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (other))->handle$;
  return SignalTestInterface_SmartHandle();
}
const Plic::TypeHashList&
SignalTestInterface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<SignalTestInterface_Context$> (ipcid)->list_types();
}

// === PropertyTester ===
static inline void ref   (PropertyTester_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (PropertyTester_SmartHandle&) {} // dummy stub for Signal<>.emit
struct PropertyTester_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public PropertyTester_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  PropertyTester_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
PropertyTester_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x33ed5186814fd96fULL, 0x2db9aae41d7f688cULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
PropertyTester_SmartHandle::PropertyTester_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const PropertyTester_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, PropertyTester_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<PropertyTester_Context$> (ipcid)->handle$ : PropertyTester_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
PropertyTester_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0de89d5c207bc662ULL, 0x846800e315917b46ULL);
  return type_hash;
}
PropertyTester_SmartHandle
PropertyTester_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<PropertyTester_Context$> (connection_handle2id (other))->handle$;
  return PropertyTester_SmartHandle();
}
const Plic::TypeHashList&
PropertyTester_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<PropertyTester_Context$> (ipcid)->list_types();
}
bool
PropertyTester_SmartHandle::bool_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x396c5b1aaf49cec6ULL, 0xb6218ab5ac6b82c3ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::bool_prop (bool value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2bd3c8fc8f71f8b4ULL, 0x2dde5c2c8fcf750cULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
int
PropertyTester_SmartHandle::int_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x369c402f00bbf1e2ULL, 0x515a4131e4516216ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::int_prop (int value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a015ad6b813701dULL, 0x62fa674331e78289ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
PropertyTester_SmartHandle::float_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3b2c96526265c4baULL, 0xc1f4b15d96504a08ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::float_prop (double value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x25ae78062c0435cdULL, 0x1d21f473f7647360ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
PropertyTester_SmartHandle::string_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x385771786e6432dbULL, 0xcb19bfb3aa9a26feULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::string_prop (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x206d200c92ba7e41ULL, 0x857975e0304c85f3ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickEnum
PropertyTester_SmartHandle::enum_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d09e074f5d2f8edULL, 0x38e8a275e29c3fc2ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::enum_prop (QuickEnum value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2b77a2f3a3c4d5b4ULL, 0x4d5b96d1adf5f7ccULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickRecord_Handle
PropertyTester_SmartHandle::record_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x31443949c61d0fecULL, 0xeb221638d6ffd3cfULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecord_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::record_prop (const QuickRecord_Handle &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a5f5c212625f446ULL, 0x30d24123307269ceULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickSequence_Handle
PropertyTester_SmartHandle::sequence_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3f323c929c803ea8ULL, 0x6ebf49e977bfb699ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequence_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::sequence_prop (const QuickSequence_Handle &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x232174952090a941ULL, 0xae8b7a3e13fdfde7ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
GrandChild_SmartHandle
PropertyTester_SmartHandle::interface_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x33a8b72ea92bb600ULL, 0x3837c1118556aaedULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  GrandChild_SmartHandle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::interface_prop (GrandChild_SmartHandle value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x29163b10631cf4b4ULL, 0xf014d69b1a1153e9ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
PropertyTester_SmartHandle
PropertyTester_SmartHandle::self_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e6b07e114fab96bULL, 0x45a97f76ee1a7bcfULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  PropertyTester_SmartHandle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::self_prop (PropertyTester_SmartHandle value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2c1aea6b5567c7beULL, 0x8f21acd05f5030deULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
} // InterfaceTests

namespace RapicornPlicTest {

// === ButtonArea ===
static inline void ref   (ButtonArea_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (ButtonArea_SmartHandle&) {} // dummy stub for Signal<>.emit
struct ButtonArea_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public ButtonArea_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  struct Signal_check_activate_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, bool (), Rapicorn::Signals::CollectorUntil0<bool>, Rapicorn::Signals::SignalConnectionRelay<Signal_check_activate_EventHandler$> > Signal_check_activate;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_check_activate signal;
    Signal_check_activate_EventHandler$ (ButtonArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_check_activate_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } check_activate;
  struct Signal_activate_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_activate_EventHandler$> > Signal_activate;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_activate signal;
    Signal_activate_EventHandler$ (ButtonArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_activate_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } activate;
  ButtonArea_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    check_activate (handle$),
    activate (handle$),
    m_cached_types (NULL)
  {
    handle$.check_activate = check_activate.signal;
    check_activate.signal.listener (check_activate, &Signal_check_activate_EventHandler$::connections_changed);
    handle$.activate = activate.signal;
    activate.signal.listener (activate, &Signal_activate_EventHandler$::connections_changed);
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
ButtonArea_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3416c0fa53fb9e4bULL, 0xca6572c6a964739bULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
void
ButtonArea_Context$::Signal_check_activate_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5aa49f58f83f54b7ULL, 0xff357b59e593e480ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
ButtonArea_Context$::Signal_check_activate_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  bool  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
ButtonArea_Context$::Signal_activate_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x567351a83995c46eULL, 0xcd153a5a755401f6ULL);
  fb << *signal.emitter();
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb << m_handler_id;    // handler connection request
    fb << 0;               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb << 0;               // no handler connection
    fb << m_connection_id; // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      frr >> m_connection_id;
    delete fr;
  }
}
Plic::FieldBuffer*
ButtonArea_Context$::Signal_activate_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, bool (), Rapicorn::Signals::CollectorUntil0<bool> > ButtonArea_SmartHandle_Signal_check_activate;
typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, void ()> ButtonArea_SmartHandle_Signal_activate;
ButtonArea_SmartHandle::ButtonArea_SmartHandle () :
  check_activate (*(ButtonArea_SmartHandle_Signal_check_activate*) NULL),
  activate (*(ButtonArea_SmartHandle_Signal_activate*) NULL)
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const ButtonArea_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, ButtonArea_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<ButtonArea_Context$> (ipcid)->handle$ : ButtonArea_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
ButtonArea_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0dcb7c084481f495ULL, 0x58f43abd0dd694eaULL);
  return type_hash;
}
ButtonArea_SmartHandle
ButtonArea_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<ButtonArea_Context$> (connection_handle2id (other))->handle$;
  return ButtonArea_SmartHandle();
}
const Plic::TypeHashList&
ButtonArea_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<ButtonArea_Context$> (ipcid)->list_types();
}
std::string
ButtonArea_SmartHandle::on_click () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e3aae70657f83b7ULL, 0x728ed182ccdc4020ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2d526a22ceb83792ULL, 0x62169ce8c45be6e0ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonArea_SmartHandle::on_click2 () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3c128313732bc9a9ULL, 0xad69a127aa1ce9b0ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click2 (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x23c57c80df9b0efbULL, 0xb8e860a363947d7dULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonArea_SmartHandle::on_click3 () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x380ad1778851e535ULL, 0x5b045ec25d2deb0eULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click3 (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x27d09d1b9508a02bULL, 0x1e072d4d979e4921ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
ClickType
ButtonArea_SmartHandle::click_type () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d39bef0c031e35dULL, 0x7ea1af466f8574b1ULL);
  fb << (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  ClickType  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::click_type (ClickType value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x27b69c1801d07bbeULL, 0x929dbc4b4f2ea981ULL); // msgid
  fb << (*this);
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}

// === PureMethods ===
static inline void ref   (PureMethods_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (PureMethods_SmartHandle&) {} // dummy stub for Signal<>.emit
struct PureMethods_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public PureMethods_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  PureMethods_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {
  }
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
PureMethods_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3f8c1b3ea1e0fd3cULL, 0x53f8ae50709fadc0ULL);
    fb << handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >> len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >> thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
PureMethods_SmartHandle::PureMethods_SmartHandle ()
{}
Plic::FieldBuffer&
operator<< (Plic::FieldBuffer &fb, const PureMethods_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
  return fb;
}
Plic::FieldReader&
operator>> (Plic::FieldReader &fbr, PureMethods_SmartHandle &handle)
{
  const uint64 ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<PureMethods_Context$> (ipcid)->handle$ : PureMethods_SmartHandle();
  return fbr;
}
const Plic::TypeHash&
PureMethods_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0364646bccfb6bbcULL, 0x37b842dacad68d00ULL);
  return type_hash;
}
PureMethods_SmartHandle
PureMethods_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<PureMethods_Context$> (connection_handle2id (other))->handle$;
  return PureMethods_SmartHandle();
}
const Plic::TypeHashList&
PureMethods_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const uint64 ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<PureMethods_Context$> (ipcid)->list_types();
}
int
PureMethods_SmartHandle::pure_method (double arg_f)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3c452a34192441bfULL, 0xcb1002037bf028e2ULL); // msgid
  fb << (*this);
  fb << arg_f;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >> retval;
  delete fr;
  return retval;
}
} // RapicornPlicTest

