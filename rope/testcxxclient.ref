/* --- Generated by PLIC-CxxStub --- */

// --- ClientHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rapicorn-core.hh> // for rcore/rapicornsignal.hh
using Rapicorn::Signals::slot;

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __PLIC_GENERIC_CC_BOILERPLATE__
#define __PLIC_GENERIC_CC_BOILERPLATE__

#define PLIC_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("PLIC-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Plic::uint64;

static __attribute__ ((__format__ (__printf__, 1, 2), unused))
Plic::FieldBuffer* plic$_error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  Plic::error_vprintf (format, args);
  va_end (args);
  return NULL;
}

} // Anonymous
#endif // __PLIC_GENERIC_CC_BOILERPLATE__


#ifndef PLIC_CONNECTION
#define PLIC_CONNECTION()       (*(Plic::Connection*)NULL)
uint64               connection_handle2id  (const Plic::SmartHandle &h) { return h._rpc_id(); }
static inline void   connection_context4id (Plic::uint64 ipcid, Plic::NonCopyable *ctx) {}
template<class C> C* connection_id2context (uint64 oid) { return (C*) NULL; }
#endif // !PLIC_CONNECTION


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Empty {
};

enum Enum1 {
  E1_A = 1,
};

enum Enum1c {
  E1C_A = 1,
};

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};

class FirstInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class FirstInterface.
{
protected:
public:
  static FirstInterface_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                FirstInterface_SmartHandle ();
  void                    void_func                  ();
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

struct XFooRecord_Handle {
  bool                    single_bool;
  int                     single_num;
  double                  single_float;
  std::string             single_string;
  int                     sibling1;
  int                     sibling2;
  int                     multi1;
  int                     multi2;
  int                     multi3;
  int                     multi4;
  ExtensiveEnum           enum_field;
  FirstInterface_SmartHandle iface1;
  FirstInterface_SmartHandle iface2;
  FirstInterface_SmartHandle iface3;
  inline                  XFooRecord_Handle () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
void operator<< (Plic::FieldBuffer&, const XFooRecord_Handle&);
void operator>> (Plic::FieldReader&, XFooRecord_Handle&);

struct XFooSequence_Handle : public std::vector<bool> {
  typedef std::vector<bool> Sequence;
};
void operator<< (Plic::FieldBuffer&, const XFooSequence_Handle&);
void operator>> (Plic::FieldReader&, XFooSequence_Handle&);

struct IntSequence_Handle : public std::vector<int> {
  typedef std::vector<int> Sequence;
};
void operator<< (Plic::FieldBuffer&, const IntSequence_Handle&);
void operator>> (Plic::FieldReader&, IntSequence_Handle&);

struct FloatSequence_Handle : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
void operator<< (Plic::FieldBuffer&, const FloatSequence_Handle&);
void operator>> (Plic::FieldReader&, FloatSequence_Handle&);

struct StringSequence_Handle : public std::vector<std::string> {
  typedef std::vector<std::string> Sequence;
};
void operator<< (Plic::FieldBuffer&, const StringSequence_Handle&);
void operator>> (Plic::FieldReader&, StringSequence_Handle&);

struct ExtensiveEnumSequence_Handle : public std::vector<ExtensiveEnum> {
  typedef std::vector<ExtensiveEnum> Sequence;
};
void operator<< (Plic::FieldBuffer&, const ExtensiveEnumSequence_Handle&);
void operator>> (Plic::FieldReader&, ExtensiveEnumSequence_Handle&);

struct RecordSequence_Handle : public std::vector<XFooRecord_Handle> {
  typedef std::vector<XFooRecord_Handle> Sequence;
};
void operator<< (Plic::FieldBuffer&, const RecordSequence_Handle&);
void operator>> (Plic::FieldReader&, RecordSequence_Handle&);

struct SequenceSequence_Handle : public std::vector<IntSequence_Handle> {
  typedef std::vector<IntSequence_Handle> Sequence;
};
void operator<< (Plic::FieldBuffer&, const SequenceSequence_Handle&);
void operator>> (Plic::FieldReader&, SequenceSequence_Handle&);

struct InterfaceSequence_Handle : public std::vector<FirstInterface_SmartHandle> {
  typedef std::vector<FirstInterface_SmartHandle> Sequence;
};
void operator<< (Plic::FieldBuffer&, const InterfaceSequence_Handle&);
void operator>> (Plic::FieldReader&, InterfaceSequence_Handle&);

struct NestedTypesRec_Handle {
  XFooRecord_Handle       rec;
  XFooSequence_Handle     seq;
  inline                  NestedTypesRec_Handle () { }
};
void operator<< (Plic::FieldBuffer&, const NestedTypesRec_Handle&);
void operator>> (Plic::FieldReader&, NestedTypesRec_Handle&);

struct NestedTypesSeq_Handle : public std::vector<NestedTypesRec_Handle> {
  typedef std::vector<NestedTypesRec_Handle> Sequence;
};
void operator<< (Plic::FieldBuffer&, const NestedTypesSeq_Handle&);
void operator>> (Plic::FieldReader&, NestedTypesSeq_Handle&);

typedef int AliasInt;

typedef double AliasFloat;

typedef bool AliasBool;

typedef std::string AliasString;

typedef XFooRecord_Handle AliasRecord;

typedef XFooSequence_Handle AliasSequence;

typedef ExtensiveEnum AliasEnum;

struct NewRecord_Handle {
  int                     i;
  Enum1                   enum1;
  XFooSequence_Handle     xfs;
  NestedTypesRec_Handle   ntr;
  inline                  NewRecord_Handle () { i = 0; enum1 = Enum1 (0); }
};
void operator<< (Plic::FieldBuffer&, const NewRecord_Handle&);
void operator>> (Plic::FieldReader&, NewRecord_Handle&);

namespace Inner {

struct InnerRecord_Handle {
  int                     x;
  int                     y;
  NewRecord_Handle        rec;
  inline                  InnerRecord_Handle () { x = 0; y = 0; }
};
void operator<< (Plic::FieldBuffer&, const InnerRecord_Handle&);
void operator>> (Plic::FieldReader&, InnerRecord_Handle&);
} // Inner

struct Refer2Inner_Handle {
  Inner::InnerRecord_Handle r;
  inline                  Refer2Inner_Handle () { }
};
void operator<< (Plic::FieldBuffer&, const Refer2Inner_Handle&);
void operator>> (Plic::FieldReader&, Refer2Inner_Handle&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SomeRecord_Handle {
  MandatoryNamespace::NewRecord_Handle r1;
  MandatoryNamespace::NewRecord_Handle r2;
  MandatoryNamespace::Inner::InnerRecord_Handle r3;
  MandatoryNamespace::Inner::InnerRecord_Handle r4;
  inline                  SomeRecord_Handle () { }
};
void operator<< (Plic::FieldBuffer&, const SomeRecord_Handle&);
void operator>> (Plic::FieldReader&, SomeRecord_Handle&);
} // OtherNamespace

namespace Auxdata {

typedef int bar;

typedef double x;

typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class UIWidgetArea_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class UIWidgetArea.
{
protected:
  typedef Rapicorn::Signals::SignalProxy<UIWidgetArea_SmartHandle, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::SignalProxy<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint)> Signal_sample_signal;
public:
  static UIWidgetArea_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                UIWidgetArea_SmartHandle ();
  double                  dummy    () const;
  void                    dummy    (double);
  std::string             on_click () const;
  void                    on_click (const std::string&);
  Signal_void_signal      void_signal;
  Signal_sample_signal    sample_signal;
  double                  simple_method            ();
  double                  single_arg               (int n);
  double                  single_arg2              (int n = 5);
  double                  two_args                 (int n,
                                                    double r);
  double                  two_args2                (int n = 6,
                                                    double r = 7.7);
  double                  multi_args               (int n,
                                                    double r,
                                                    int i,
                                                    const std::string &s = "String ding",
                                                    double y = 5);
  double                  self_method              (UIWidgetArea_SmartHandle &ba1,
                                                    UIWidgetArea_SmartHandle &ba2);
  void                    void_method              ();
  std::string             on_click2out             ();
  void                    on_click2in              (const std::string &command);
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class Parent_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class Parent.
{
protected:
public:
  static Parent_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                Parent_SmartHandle ();
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class Child_SmartHandle : public Parent_SmartHandle
  /// See also the corresponding IDL class Child.
{
protected:
public:
  static Child_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                Child_SmartHandle ();
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class Descendant_SmartHandle : public Child_SmartHandle
  /// See also the corresponding IDL class Descendant.
{
protected:
public:
  static Descendant_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                Descendant_SmartHandle ();
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class GrandChild_SmartHandle : public Descendant_SmartHandle
  /// See also the corresponding IDL class GrandChild.
{
protected:
public:
  static GrandChild_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                GrandChild_SmartHandle ();
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

enum QuickEnum {
  ZERO = 0,
};

struct QuickRecord_Handle {
  int                     int1;
  int                     int2;
  inline                  QuickRecord_Handle () { int1 = 0; int2 = 0; }
};
void operator<< (Plic::FieldBuffer&, const QuickRecord_Handle&);
void operator>> (Plic::FieldReader&, QuickRecord_Handle&);

struct QuickSequence_Handle : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
void operator<< (Plic::FieldBuffer&, const QuickSequence_Handle&);
void operator>> (Plic::FieldReader&, QuickSequence_Handle&);

class QuickIface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class QuickIface.
{
protected:
public:
  static QuickIface_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                QuickIface_SmartHandle ();
  void                    simple_function        (int i = 9);
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class MethodTestInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class MethodTestInterface.
{
protected:
public:
  static MethodTestInterface_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                MethodTestInterface_SmartHandle ();
  void                    method_with_void                ();
  bool                    method_with_bools               (bool input,
                                                           bool optval = 0);
  int                     method_with_ints                (int input,
                                                           int optval = -2);
  double                  method_with_floats              (double input,
                                                           double optval = 309.9);
  std::string             method_with_string              (const std::string &input,
                                                           const std::string &optval = "default");
  QuickEnum               method_with_enum                (QuickEnum input,
                                                           QuickEnum optval = QuickEnum (0));
  QuickRecord_Handle      method_with_record              (const QuickRecord_Handle &input,
                                                           const QuickRecord_Handle &optval = QuickRecord_Handle());
  QuickSequence_Handle    method_with_sequence            (const QuickSequence_Handle &input,
                                                           const QuickSequence_Handle &optval = QuickSequence_Handle());
  GrandChild_SmartHandle  method_with_interface           (GrandChild_SmartHandle &input,
                                                           GrandChild_SmartHandle &optval = *(GrandChild_SmartHandle*) NULL);
  QuickIface_SmartHandle  method_with_quickiface          (QuickIface_SmartHandle &input,
                                                           QuickIface_SmartHandle &iface0 = *(QuickIface_SmartHandle*) NULL);
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class SignalTestInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class SignalTestInterface.
{
protected:
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void ()> Signal_void_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, int ()> Signal_int_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, double ()> Signal_float_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickRecord_Handle ()> Signal_record_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickSequence_Handle ()> Signal_sequence_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, GrandChild_SmartHandle ()> Signal_interface_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle ()> Signal_self_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r)> Signal_record_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_)> Signal_self_args;
public:
  static SignalTestInterface_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                SignalTestInterface_SmartHandle ();
  Signal_void_result      void_result;
  Signal_bool_result      bool_result;
  Signal_int_result       int_result;
  Signal_float_result     float_result;
  Signal_string_result    string_result;
  Signal_enum_result      enum_result;
  Signal_record_result    record_result;
  Signal_sequence_result  sequence_result;
  Signal_interface_result interface_result;
  Signal_self_result      self_result;
  Signal_void_arg         void_arg;
  Signal_bool_arg         bool_arg;
  Signal_int_arg          int_arg;
  Signal_float_arg        float_arg;
  Signal_string_arg       string_arg;
  Signal_enum_arg         enum_arg;
  Signal_record_arg       record_arg;
  Signal_sequence_arg     sequence_arg;
  Signal_interface_arg    interface_arg;
  Signal_self_args        self_args;
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class PropertyTester_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class PropertyTester.
{
protected:
public:
  static PropertyTester_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                PropertyTester_SmartHandle ();
  bool                    bool_prop      () const;
  void                    bool_prop      (bool);
  int                     int_prop       () const;
  void                    int_prop       (int);
  double                  float_prop     () const;
  void                    float_prop     (double);
  std::string             string_prop    () const;
  void                    string_prop    (const std::string&);
  QuickEnum               enum_prop      () const;
  void                    enum_prop      (QuickEnum);
  QuickRecord_Handle      record_prop    () const;
  void                    record_prop    (const QuickRecord_Handle&);
  QuickSequence_Handle    sequence_prop  () const;
  void                    sequence_prop  (const QuickSequence_Handle&);
  GrandChild_SmartHandle  interface_prop () const;
  void                    interface_prop (GrandChild_SmartHandle);
  PropertyTester_SmartHandle self_prop      () const;
  void                    self_prop      (PropertyTester_SmartHandle);
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
} // InterfaceTests

namespace RapicornPlicTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class ButtonArea_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class ButtonArea.
{
protected:
  typedef Rapicorn::Signals::SignalProxy<ButtonArea_SmartHandle, bool ()> Signal_check_activate;
  typedef Rapicorn::Signals::SignalProxy<ButtonArea_SmartHandle, void ()> Signal_activate;
public:
  static ButtonArea_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                ButtonArea_SmartHandle ();
  std::string             on_click   () const;
  void                    on_click   (const std::string&);
  std::string             on_click2  () const;
  void                    on_click2  (const std::string&);
  std::string             on_click3  () const;
  void                    on_click3  (const std::string&);
  ClickType               click_type () const;
  void                    click_type (ClickType);
  Signal_check_activate   check_activate;
  Signal_activate         activate;
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class PureMethods_SmartHandle;

class PureMethods_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class PureMethods.
{
protected:
public:
  static PureMethods_SmartHandle _new (Plic::FieldReader &fbr) __attribute__ ((noinline));
  explicit                PureMethods_SmartHandle ();
  int                     pure_method             (double f);
  inline         operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
} // RapicornPlicTest

// --- Implementations ---

namespace MandatoryNamespace {

static inline void ref   (FirstInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (FirstInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
// === FirstInterface ===
struct FirstInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public FirstInterface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  FirstInterface_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
FirstInterface_SmartHandle::FirstInterface_SmartHandle ()
{}
FirstInterface_SmartHandle
FirstInterface_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<FirstInterface_Context$> (fbr.pop_object())->handle$;
}
void
FirstInterface_SmartHandle::void_func ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x209463c55becedadULL, 0x39ddfcb9aadc3c74ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}
void
operator<< (Plic::FieldBuffer &dst, const XFooRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (14);
  fb.add_int64 (self.single_bool);
  fb.add_int64 (self.single_num);
  fb.add_double (self.single_float);
  fb.add_string (self.single_string);
  fb.add_int64 (self.sibling1);
  fb.add_int64 (self.sibling2);
  fb.add_int64 (self.multi1);
  fb.add_int64 (self.multi2);
  fb.add_int64 (self.multi3);
  fb.add_int64 (self.multi4);
  fb.add_evalue (self.enum_field);
  fb.add_object (connection_handle2id (self.iface1));
  fb.add_object (connection_handle2id (self.iface2));
  fb.add_object (connection_handle2id (self.iface3));
}
void
operator>> (Plic::FieldReader &src, XFooRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 14) return;
  self.single_bool = fbr.pop_int64();
  self.single_num = fbr.pop_int64();
  self.single_float = fbr.pop_double();
  self.single_string = fbr.pop_string();
  self.sibling1 = fbr.pop_int64();
  self.sibling2 = fbr.pop_int64();
  self.multi1 = fbr.pop_int64();
  self.multi2 = fbr.pop_int64();
  self.multi3 = fbr.pop_int64();
  self.multi4 = fbr.pop_int64();
  self.enum_field = ExtensiveEnum (fbr.pop_evalue());
  self.iface1 = FirstInterface_SmartHandle::_new (fbr);
  self.iface2 = FirstInterface_SmartHandle::_new (fbr);
  self.iface3 = FirstInterface_SmartHandle::_new (fbr);
}
void
operator<< (Plic::FieldBuffer &dst, const XFooSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, XFooSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_int64());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const IntSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, IntSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_int64());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const FloatSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, FloatSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_double());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const StringSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_string (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, StringSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_string());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const ExtensiveEnumSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_evalue (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, ExtensiveEnumSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (ExtensiveEnum (fbr.pop_evalue()));
  }
}
void
operator<< (Plic::FieldBuffer &dst, const RecordSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
}
void
operator>> (Plic::FieldReader &src, RecordSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
}
void
operator<< (Plic::FieldBuffer &dst, const SequenceSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
}
void
operator>> (Plic::FieldReader &src, SequenceSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
}
void
operator<< (Plic::FieldBuffer &dst, const InterfaceSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_object (connection_handle2id (self[k]));
  }
}
void
operator>> (Plic::FieldReader &src, InterfaceSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (FirstInterface_SmartHandle::_new (fbr));
  }
}
void
operator<< (Plic::FieldBuffer &dst, const NestedTypesRec_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb << self.rec;
  fb << self.seq;
}
void
operator>> (Plic::FieldReader &src, NestedTypesRec_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >> self.rec;
  fbr >> self.seq;
}
void
operator<< (Plic::FieldBuffer &dst, const NestedTypesSeq_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
}
void
operator>> (Plic::FieldReader &src, NestedTypesSeq_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
}
void
operator<< (Plic::FieldBuffer &dst, const NewRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb.add_int64 (self.i);
  fb.add_evalue (self.enum1);
  fb << self.xfs;
  fb << self.ntr;
}
void
operator>> (Plic::FieldReader &src, NewRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  self.i = fbr.pop_int64();
  self.enum1 = Enum1 (fbr.pop_evalue());
  fbr >> self.xfs;
  fbr >> self.ntr;
}

namespace Inner {
void
operator<< (Plic::FieldBuffer &dst, const InnerRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  fb.add_int64 (self.x);
  fb.add_int64 (self.y);
  fb << self.rec;
}
void
operator>> (Plic::FieldReader &src, InnerRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  self.x = fbr.pop_int64();
  self.y = fbr.pop_int64();
  fbr >> self.rec;
}
} // Inner
void
operator<< (Plic::FieldBuffer &dst, const Refer2Inner_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  fb << self.r;
}
void
operator>> (Plic::FieldReader &src, Refer2Inner_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >> self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
void
operator<< (Plic::FieldBuffer &dst, const SomeRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb << self.r1;
  fb << self.r2;
  fb << self.r3;
  fb << self.r4;
}
void
operator>> (Plic::FieldReader &src, SomeRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >> self.r1;
  fbr >> self.r2;
  fbr >> self.r3;
  fbr >> self.r4;
}
} // OtherNamespace

namespace InterfaceTests {
double
UIWidgetArea_SmartHandle::dummy () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x39146750080bd117ULL, 0x9edc3ab3b5e82e8dULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::dummy (double value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a284d0b5305ac3aULL, 0xd98a1d86235ad649ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_double (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
UIWidgetArea_SmartHandle::on_click () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x37b8129e6139dfaeULL, 0xece65fb7aeda0163ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::on_click (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2d15d46bb30e2a40ULL, 0xc421a429912efd6dULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}

static inline void ref   (UIWidgetArea_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (UIWidgetArea_SmartHandle&) {} // dummy stub for Signal<>.emit
// === UIWidgetArea ===
struct UIWidgetArea_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public UIWidgetArea_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  struct Signal_void_signal_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_void_signal_EventHandler$> > Signal_void_signal;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_void_signal signal;
    Signal_void_signal_EventHandler$ (UIWidgetArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_void_signal_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } void_signal;
  struct Signal_sample_signal_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint), Rapicorn::Signals::CollectorDefault<double>, Rapicorn::Signals::SignalConnectionRelay<Signal_sample_signal_EventHandler$> > Signal_sample_signal;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_sample_signal signal;
    Signal_sample_signal_EventHandler$ (UIWidgetArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_sample_signal_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } sample_signal;
  UIWidgetArea_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    void_signal (handle$),
    sample_signal (handle$)
  {
    handle$.void_signal = void_signal.signal;
    void_signal.signal.listener (void_signal, &Signal_void_signal_EventHandler$::connections_changed);
    handle$.sample_signal = sample_signal.signal;
    sample_signal.signal.listener (sample_signal, &Signal_sample_signal_EventHandler$::connections_changed);
  }
};
void
UIWidgetArea_Context$::Signal_void_signal_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x52ef738c2571d0f2ULL, 0x05b653adf0a80acfULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
UIWidgetArea_Context$::Signal_void_signal_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
void
UIWidgetArea_Context$::Signal_sample_signal_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x511bbb2e2b129d5bULL, 0xe7152819ec289550ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
UIWidgetArea_Context$::Signal_sample_signal_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 2) return plic$_error ("invalid number of arguments");
  UIWidgetArea_SmartHandle  arg_ba1 = UIWidgetArea_SmartHandle::_new (fbr);
  int  arg_someint = fbr.pop_int64();
  double  rval = signal.emit (arg_ba1, arg_someint);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, void ()> UIWidgetArea_SmartHandle_Signal_void_signal;
typedef Rapicorn::Signals::Signal<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint)> UIWidgetArea_SmartHandle_Signal_sample_signal;
UIWidgetArea_SmartHandle::UIWidgetArea_SmartHandle () :
  void_signal (*(UIWidgetArea_SmartHandle_Signal_void_signal*) NULL),
  sample_signal (*(UIWidgetArea_SmartHandle_Signal_sample_signal*) NULL)
{}
UIWidgetArea_SmartHandle
UIWidgetArea_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<UIWidgetArea_Context$> (fbr.pop_object())->handle$;
}
double
UIWidgetArea_SmartHandle::simple_method ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x39a122b559d15903ULL, 0x0a95fe35b7a1de33ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::single_arg (int arg_n)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3910395d202c93c2ULL, 0x9206a89acaaf2086ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_n);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::single_arg2 (int arg_n)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3b5ae84b86dfa59cULL, 0x5d2ef3880b1fa360ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_n);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::two_args (int arg_n,
                                    double arg_r)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x359c33f1677a63ebULL, 0x3a05748016992575ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_n);
  fb.add_double (arg_r);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::two_args2 (int arg_n,
                                     double arg_r)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3291a584ff9121b3ULL, 0xbd14f4bbc47fb2ccULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_n);
  fb.add_double (arg_r);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::multi_args (int arg_n,
                                      double arg_r,
                                      int arg_i,
                                      const std::string &arg_s,
                                      double arg_y)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 5), *fr = NULL;
  fb.add_msgid (0x3501ef84b7c1d9ffULL, 0x564566ab8a5e1b8bULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_n);
  fb.add_double (arg_r);
  fb.add_int64 (arg_i);
  fb.add_string (arg_s);
  fb.add_double (arg_y);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::self_method (UIWidgetArea_SmartHandle &arg_ba1,
                                       UIWidgetArea_SmartHandle &arg_ba2)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x316521a2bcc037d0ULL, 0x43987053dab0c3c0ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_object (connection_handle2id (arg_ba1));
  fb.add_object (connection_handle2id (arg_ba2));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::void_method ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x2e02c52c84773703ULL, 0x00027e452edb615cULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}
std::string
UIWidgetArea_SmartHandle::on_click2out ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x3e4f2ff4e1424783ULL, 0x439ed3d602e3946eULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::on_click2in (const std::string &arg_command)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2294f15cd15e9458ULL, 0x5e0ac9b493bb4f17ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (arg_command);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}

static inline void ref   (Parent_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Parent_SmartHandle&) {} // dummy stub for Signal<>.emit
// === Parent ===
struct Parent_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Parent_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Parent_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
Parent_SmartHandle::Parent_SmartHandle ()
{}
Parent_SmartHandle
Parent_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<Parent_Context$> (fbr.pop_object())->handle$;
}

static inline void ref   (Child_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Child_SmartHandle&) {} // dummy stub for Signal<>.emit
// === Child ===
struct Child_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Child_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Child_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
Child_SmartHandle::Child_SmartHandle ()
{}
Child_SmartHandle
Child_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<Child_Context$> (fbr.pop_object())->handle$;
}

static inline void ref   (Descendant_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Descendant_SmartHandle&) {} // dummy stub for Signal<>.emit
// === Descendant ===
struct Descendant_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Descendant_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Descendant_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
Descendant_SmartHandle::Descendant_SmartHandle ()
{}
Descendant_SmartHandle
Descendant_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<Descendant_Context$> (fbr.pop_object())->handle$;
}

static inline void ref   (GrandChild_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (GrandChild_SmartHandle&) {} // dummy stub for Signal<>.emit
// === GrandChild ===
struct GrandChild_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public GrandChild_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  GrandChild_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
GrandChild_SmartHandle::GrandChild_SmartHandle ()
{}
GrandChild_SmartHandle
GrandChild_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<GrandChild_Context$> (fbr.pop_object())->handle$;
}
void
operator<< (Plic::FieldBuffer &dst, const QuickRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb.add_int64 (self.int1);
  fb.add_int64 (self.int2);
}
void
operator>> (Plic::FieldReader &src, QuickRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  self.int1 = fbr.pop_int64();
  self.int2 = fbr.pop_int64();
}
void
operator<< (Plic::FieldBuffer &dst, const QuickSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, QuickSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_double());
  }
}

static inline void ref   (QuickIface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (QuickIface_SmartHandle&) {} // dummy stub for Signal<>.emit
// === QuickIface ===
struct QuickIface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public QuickIface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  QuickIface_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
QuickIface_SmartHandle::QuickIface_SmartHandle ()
{}
QuickIface_SmartHandle
QuickIface_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<QuickIface_Context$> (fbr.pop_object())->handle$;
}
void
QuickIface_SmartHandle::simple_function (int arg_i)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2446078b004b9aabULL, 0x37d6c73a34ac7070ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_i);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}

static inline void ref   (MethodTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (MethodTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
// === MethodTestInterface ===
struct MethodTestInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public MethodTestInterface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  MethodTestInterface_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
MethodTestInterface_SmartHandle::MethodTestInterface_SmartHandle ()
{}
MethodTestInterface_SmartHandle
MethodTestInterface_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<MethodTestInterface_Context$> (fbr.pop_object())->handle$;
}
void
MethodTestInterface_SmartHandle::method_with_void ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x281392e54343bee9ULL, 0x0dbeb788728dbff4ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
}
bool
MethodTestInterface_SmartHandle::method_with_bools (bool arg_input,
                                                    bool arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b68546991e25342ULL, 0xa71399caec9ccfc7ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_input);
  fb.add_int64 (arg_optval);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval = frr.pop_int64();
  delete fr;
  return retval;
}
int
MethodTestInterface_SmartHandle::method_with_ints (int arg_input,
                                                   int arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x39555e79a31047bfULL, 0x0f06b4f122a81e1dULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (arg_input);
  fb.add_int64 (arg_optval);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval = frr.pop_int64();
  delete fr;
  return retval;
}
double
MethodTestInterface_SmartHandle::method_with_floats (double arg_input,
                                                     double arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x391dd7c671dada38ULL, 0x32ca18bc1bd39689ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_double (arg_input);
  fb.add_double (arg_optval);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
std::string
MethodTestInterface_SmartHandle::method_with_string (const std::string &arg_input,
                                                     const std::string &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3ad5eafe588b965aULL, 0x38c04145925d2963ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (arg_input);
  fb.add_string (arg_optval);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
QuickEnum
MethodTestInterface_SmartHandle::method_with_enum (QuickEnum arg_input,
                                                   QuickEnum arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x387f08a5c150e6a7ULL, 0x83c133fcd2be3200ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_evalue (arg_input);
  fb.add_evalue (arg_optval);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval = QuickEnum (frr.pop_evalue());
  delete fr;
  return retval;
}
QuickRecord_Handle
MethodTestInterface_SmartHandle::method_with_record (const QuickRecord_Handle &arg_input,
                                                     const QuickRecord_Handle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b59b493f287edf0ULL, 0x4771d353c78389d1ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecord_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
QuickSequence_Handle
MethodTestInterface_SmartHandle::method_with_sequence (const QuickSequence_Handle &arg_input,
                                                       const QuickSequence_Handle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34c9e8a686a7f261ULL, 0x9af099b173ac979cULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb << arg_input;
  fb << arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequence_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
GrandChild_SmartHandle
MethodTestInterface_SmartHandle::method_with_interface (GrandChild_SmartHandle &arg_input,
                                                        GrandChild_SmartHandle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34619983babcee5bULL, 0x9875f78f28f381b7ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_object (connection_handle2id (arg_input));
  fb.add_object (connection_handle2id (arg_optval));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  GrandChild_SmartHandle  retval = GrandChild_SmartHandle::_new (frr);
  delete fr;
  return retval;
}
QuickIface_SmartHandle
MethodTestInterface_SmartHandle::method_with_quickiface (QuickIface_SmartHandle &arg_input,
                                                         QuickIface_SmartHandle &arg_iface0)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3a2ab33a8358edcbULL, 0x7c028db9464052a0ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_object (connection_handle2id (arg_input));
  fb.add_object (connection_handle2id (arg_iface0));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickIface_SmartHandle  retval = QuickIface_SmartHandle::_new (frr);
  delete fr;
  return retval;
}

static inline void ref   (SignalTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (SignalTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
// === SignalTestInterface ===
struct SignalTestInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public SignalTestInterface_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  struct Signal_void_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_void_result_EventHandler$> > Signal_void_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_void_result signal;
    Signal_void_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_void_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } void_result;
  struct Signal_bool_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, bool (), Rapicorn::Signals::CollectorDefault<bool>, Rapicorn::Signals::SignalConnectionRelay<Signal_bool_result_EventHandler$> > Signal_bool_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_bool_result signal;
    Signal_bool_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_bool_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } bool_result;
  struct Signal_int_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, int (), Rapicorn::Signals::CollectorDefault<int>, Rapicorn::Signals::SignalConnectionRelay<Signal_int_result_EventHandler$> > Signal_int_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_int_result signal;
    Signal_int_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_int_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } int_result;
  struct Signal_float_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, double (), Rapicorn::Signals::CollectorDefault<double>, Rapicorn::Signals::SignalConnectionRelay<Signal_float_result_EventHandler$> > Signal_float_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_float_result signal;
    Signal_float_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_float_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } float_result;
  struct Signal_string_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, std::string (), Rapicorn::Signals::CollectorDefault<std::string>, Rapicorn::Signals::SignalConnectionRelay<Signal_string_result_EventHandler$> > Signal_string_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_string_result signal;
    Signal_string_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_string_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } string_result;
  struct Signal_enum_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickEnum (), Rapicorn::Signals::CollectorDefault<QuickEnum>, Rapicorn::Signals::SignalConnectionRelay<Signal_enum_result_EventHandler$> > Signal_enum_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_enum_result signal;
    Signal_enum_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_enum_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } enum_result;
  struct Signal_record_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickRecord_Handle (), Rapicorn::Signals::CollectorDefault<QuickRecord_Handle>, Rapicorn::Signals::SignalConnectionRelay<Signal_record_result_EventHandler$> > Signal_record_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_record_result signal;
    Signal_record_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_record_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } record_result;
  struct Signal_sequence_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickSequence_Handle (), Rapicorn::Signals::CollectorDefault<QuickSequence_Handle>, Rapicorn::Signals::SignalConnectionRelay<Signal_sequence_result_EventHandler$> > Signal_sequence_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_sequence_result signal;
    Signal_sequence_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_sequence_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } sequence_result;
  struct Signal_interface_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, GrandChild_SmartHandle (), Rapicorn::Signals::CollectorDefault<GrandChild_SmartHandle>, Rapicorn::Signals::SignalConnectionRelay<Signal_interface_result_EventHandler$> > Signal_interface_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_interface_result signal;
    Signal_interface_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_interface_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } interface_result;
  struct Signal_self_result_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle (), Rapicorn::Signals::CollectorDefault<SignalTestInterface_SmartHandle>, Rapicorn::Signals::SignalConnectionRelay<Signal_self_result_EventHandler$> > Signal_self_result;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_self_result signal;
    Signal_self_result_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_self_result_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } self_result;
  struct Signal_void_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_void_arg_EventHandler$> > Signal_void_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_void_arg signal;
    Signal_void_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_void_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } void_arg;
  struct Signal_bool_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (bool b), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_bool_arg_EventHandler$> > Signal_bool_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_bool_arg signal;
    Signal_bool_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_bool_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } bool_arg;
  struct Signal_int_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (int i), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_int_arg_EventHandler$> > Signal_int_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_int_arg signal;
    Signal_int_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_int_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } int_arg;
  struct Signal_float_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (double f), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_float_arg_EventHandler$> > Signal_float_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_float_arg signal;
    Signal_float_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_float_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } float_arg;
  struct Signal_string_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const std::string &s), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_string_arg_EventHandler$> > Signal_string_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_string_arg signal;
    Signal_string_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_string_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } string_arg;
  struct Signal_enum_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (QuickEnum e), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_enum_arg_EventHandler$> > Signal_enum_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_enum_arg signal;
    Signal_enum_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_enum_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } enum_arg;
  struct Signal_record_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_record_arg_EventHandler$> > Signal_record_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_record_arg signal;
    Signal_record_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_record_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } record_arg;
  struct Signal_sequence_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_sequence_arg_EventHandler$> > Signal_sequence_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_sequence_arg signal;
    Signal_sequence_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_sequence_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } sequence_arg;
  struct Signal_interface_arg_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_interface_arg_EventHandler$> > Signal_interface_arg;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_interface_arg signal;
    Signal_interface_arg_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_interface_arg_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } interface_arg;
  struct Signal_self_args_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_self_args_EventHandler$> > Signal_self_args;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_self_args signal;
    Signal_self_args_EventHandler$ (SignalTestInterface_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_self_args_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } self_args;
  SignalTestInterface_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    void_result (handle$),
    bool_result (handle$),
    int_result (handle$),
    float_result (handle$),
    string_result (handle$),
    enum_result (handle$),
    record_result (handle$),
    sequence_result (handle$),
    interface_result (handle$),
    self_result (handle$),
    void_arg (handle$),
    bool_arg (handle$),
    int_arg (handle$),
    float_arg (handle$),
    string_arg (handle$),
    enum_arg (handle$),
    record_arg (handle$),
    sequence_arg (handle$),
    interface_arg (handle$),
    self_args (handle$)
  {
    handle$.void_result = void_result.signal;
    void_result.signal.listener (void_result, &Signal_void_result_EventHandler$::connections_changed);
    handle$.bool_result = bool_result.signal;
    bool_result.signal.listener (bool_result, &Signal_bool_result_EventHandler$::connections_changed);
    handle$.int_result = int_result.signal;
    int_result.signal.listener (int_result, &Signal_int_result_EventHandler$::connections_changed);
    handle$.float_result = float_result.signal;
    float_result.signal.listener (float_result, &Signal_float_result_EventHandler$::connections_changed);
    handle$.string_result = string_result.signal;
    string_result.signal.listener (string_result, &Signal_string_result_EventHandler$::connections_changed);
    handle$.enum_result = enum_result.signal;
    enum_result.signal.listener (enum_result, &Signal_enum_result_EventHandler$::connections_changed);
    handle$.record_result = record_result.signal;
    record_result.signal.listener (record_result, &Signal_record_result_EventHandler$::connections_changed);
    handle$.sequence_result = sequence_result.signal;
    sequence_result.signal.listener (sequence_result, &Signal_sequence_result_EventHandler$::connections_changed);
    handle$.interface_result = interface_result.signal;
    interface_result.signal.listener (interface_result, &Signal_interface_result_EventHandler$::connections_changed);
    handle$.self_result = self_result.signal;
    self_result.signal.listener (self_result, &Signal_self_result_EventHandler$::connections_changed);
    handle$.void_arg = void_arg.signal;
    void_arg.signal.listener (void_arg, &Signal_void_arg_EventHandler$::connections_changed);
    handle$.bool_arg = bool_arg.signal;
    bool_arg.signal.listener (bool_arg, &Signal_bool_arg_EventHandler$::connections_changed);
    handle$.int_arg = int_arg.signal;
    int_arg.signal.listener (int_arg, &Signal_int_arg_EventHandler$::connections_changed);
    handle$.float_arg = float_arg.signal;
    float_arg.signal.listener (float_arg, &Signal_float_arg_EventHandler$::connections_changed);
    handle$.string_arg = string_arg.signal;
    string_arg.signal.listener (string_arg, &Signal_string_arg_EventHandler$::connections_changed);
    handle$.enum_arg = enum_arg.signal;
    enum_arg.signal.listener (enum_arg, &Signal_enum_arg_EventHandler$::connections_changed);
    handle$.record_arg = record_arg.signal;
    record_arg.signal.listener (record_arg, &Signal_record_arg_EventHandler$::connections_changed);
    handle$.sequence_arg = sequence_arg.signal;
    sequence_arg.signal.listener (sequence_arg, &Signal_sequence_arg_EventHandler$::connections_changed);
    handle$.interface_arg = interface_arg.signal;
    interface_arg.signal.listener (interface_arg, &Signal_interface_arg_EventHandler$::connections_changed);
    handle$.self_args = self_args.signal;
    self_args.signal.listener (self_args, &Signal_self_args_EventHandler$::connections_changed);
  }
};
void
SignalTestInterface_Context$::Signal_void_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x535d5e95471873b6ULL, 0x7a9f5692ce00e007ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_void_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
void
SignalTestInterface_Context$::Signal_bool_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x51ffffa2f8db1b1bULL, 0x3e01434baf49eceeULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_bool_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  bool  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
void
SignalTestInterface_Context$::Signal_int_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x51ac083cdc878affULL, 0x72ad7414773447a2ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_int_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  int  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
void
SignalTestInterface_Context$::Signal_float_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5cc54429499b42b6ULL, 0x35e1fb7707130bcaULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_float_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  double  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
void
SignalTestInterface_Context$::Signal_string_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5790f575b6cac788ULL, 0x27db8e3c014993a7ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_string_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  std::string  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
void
SignalTestInterface_Context$::Signal_enum_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x56fc6f3f4946e7b2ULL, 0x0fe0cc5f83d2ab84ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_enum_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  QuickEnum  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_evalue (rval);
  return &rb;
}
void
SignalTestInterface_Context$::Signal_record_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x50b723665ed298a5ULL, 0x32aa063680a4e3c0ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_record_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  QuickRecord_Handle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_sequence_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5ef00325dfcf4552ULL, 0x991130ecddd21730ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_sequence_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  QuickSequence_Handle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
void
SignalTestInterface_Context$::Signal_interface_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x58e8587c542d85ceULL, 0xe2b572e902c69f7cULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_interface_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  GrandChild_SmartHandle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_object (connection_handle2id (rval));
  return &rb;
}
void
SignalTestInterface_Context$::Signal_self_result_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x59bb2da621bab28fULL, 0x32bc82e7eb9bc512ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_self_result_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  SignalTestInterface_SmartHandle  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_object (connection_handle2id (rval));
  return &rb;
}
void
SignalTestInterface_Context$::Signal_void_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x583dc36c7785c7f3ULL, 0xb330cefa4e8247a9ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_void_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
void
SignalTestInterface_Context$::Signal_bool_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5f7ba898d12986bfULL, 0x8a1143a5f6dc85b8ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_bool_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  bool  arg_b = fbr.pop_int64();
  signal.emit (arg_b);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_int_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5f91dc79c2bee013ULL, 0x809b90b2fad4ea0aULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_int_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  int  arg_i = fbr.pop_int64();
  signal.emit (arg_i);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_float_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5d5c43cd47b258caULL, 0xb0d5fde097d6d12cULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_float_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  double  arg_f = fbr.pop_double();
  signal.emit (arg_f);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_string_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x53de7a105b57bf62ULL, 0x9d8ffe4942a0934fULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_string_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  std::string  arg_s = fbr.pop_string();
  signal.emit (arg_s);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_enum_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x586138796f133c4dULL, 0x1c7573f2d30ac907ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_enum_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  QuickEnum  arg_e = QuickEnum (fbr.pop_evalue());
  signal.emit (arg_e);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_record_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x59cb77461ddeac82ULL, 0xfeaa98721bd8ecd3ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_record_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  QuickRecord_Handle  arg_r;
  fbr >> arg_r;
  signal.emit (arg_r);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_sequence_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x547b4dd41606b568ULL, 0x1d763791a33d2bc9ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_sequence_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  QuickSequence_Handle  arg_s;
  fbr >> arg_s;
  signal.emit (arg_s);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_interface_arg_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x57a5dbfbeb5a4ef9ULL, 0xb5df0c3b3bba4b22ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_interface_arg_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  GrandChild_SmartHandle  arg_i = GrandChild_SmartHandle::_new (fbr);
  signal.emit (arg_i);
  return NULL;
}
void
SignalTestInterface_Context$::Signal_self_args_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5c515ee37b78a970ULL, 0xe89c2af2f29359a0ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
SignalTestInterface_Context$::Signal_self_args_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  SignalTestInterface_SmartHandle  arg_self_ = SignalTestInterface_SmartHandle::_new (fbr);
  signal.emit (arg_self_);
  return NULL;
}
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void ()> SignalTestInterface_SmartHandle_Signal_void_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, bool ()> SignalTestInterface_SmartHandle_Signal_bool_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, int ()> SignalTestInterface_SmartHandle_Signal_int_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, double ()> SignalTestInterface_SmartHandle_Signal_float_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, std::string ()> SignalTestInterface_SmartHandle_Signal_string_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickEnum ()> SignalTestInterface_SmartHandle_Signal_enum_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickRecord_Handle ()> SignalTestInterface_SmartHandle_Signal_record_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, QuickSequence_Handle ()> SignalTestInterface_SmartHandle_Signal_sequence_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, GrandChild_SmartHandle ()> SignalTestInterface_SmartHandle_Signal_interface_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle ()> SignalTestInterface_SmartHandle_Signal_self_result;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void ()> SignalTestInterface_SmartHandle_Signal_void_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (bool b)> SignalTestInterface_SmartHandle_Signal_bool_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (int i)> SignalTestInterface_SmartHandle_Signal_int_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (double f)> SignalTestInterface_SmartHandle_Signal_float_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const std::string &s)> SignalTestInterface_SmartHandle_Signal_string_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (QuickEnum e)> SignalTestInterface_SmartHandle_Signal_enum_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r)> SignalTestInterface_SmartHandle_Signal_record_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s)> SignalTestInterface_SmartHandle_Signal_sequence_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i)> SignalTestInterface_SmartHandle_Signal_interface_arg;
typedef Rapicorn::Signals::Signal<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_)> SignalTestInterface_SmartHandle_Signal_self_args;
SignalTestInterface_SmartHandle::SignalTestInterface_SmartHandle () :
  void_result (*(SignalTestInterface_SmartHandle_Signal_void_result*) NULL),
  bool_result (*(SignalTestInterface_SmartHandle_Signal_bool_result*) NULL),
  int_result (*(SignalTestInterface_SmartHandle_Signal_int_result*) NULL),
  float_result (*(SignalTestInterface_SmartHandle_Signal_float_result*) NULL),
  string_result (*(SignalTestInterface_SmartHandle_Signal_string_result*) NULL),
  enum_result (*(SignalTestInterface_SmartHandle_Signal_enum_result*) NULL),
  record_result (*(SignalTestInterface_SmartHandle_Signal_record_result*) NULL),
  sequence_result (*(SignalTestInterface_SmartHandle_Signal_sequence_result*) NULL),
  interface_result (*(SignalTestInterface_SmartHandle_Signal_interface_result*) NULL),
  self_result (*(SignalTestInterface_SmartHandle_Signal_self_result*) NULL),
  void_arg (*(SignalTestInterface_SmartHandle_Signal_void_arg*) NULL),
  bool_arg (*(SignalTestInterface_SmartHandle_Signal_bool_arg*) NULL),
  int_arg (*(SignalTestInterface_SmartHandle_Signal_int_arg*) NULL),
  float_arg (*(SignalTestInterface_SmartHandle_Signal_float_arg*) NULL),
  string_arg (*(SignalTestInterface_SmartHandle_Signal_string_arg*) NULL),
  enum_arg (*(SignalTestInterface_SmartHandle_Signal_enum_arg*) NULL),
  record_arg (*(SignalTestInterface_SmartHandle_Signal_record_arg*) NULL),
  sequence_arg (*(SignalTestInterface_SmartHandle_Signal_sequence_arg*) NULL),
  interface_arg (*(SignalTestInterface_SmartHandle_Signal_interface_arg*) NULL),
  self_args (*(SignalTestInterface_SmartHandle_Signal_self_args*) NULL)
{}
SignalTestInterface_SmartHandle
SignalTestInterface_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<SignalTestInterface_Context$> (fbr.pop_object())->handle$;
}
bool
PropertyTester_SmartHandle::bool_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x396c5b1aaf49cec6ULL, 0xb6218ab5ac6b82c3ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval = frr.pop_int64();
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::bool_prop (bool value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2bd3c8fc8f71f8b4ULL, 0x2dde5c2c8fcf750cULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
int
PropertyTester_SmartHandle::int_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x369c402f00bbf1e2ULL, 0x515a4131e4516216ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval = frr.pop_int64();
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::int_prop (int value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a015ad6b813701dULL, 0x62fa674331e78289ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_int64 (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
PropertyTester_SmartHandle::float_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3b2c96526265c4baULL, 0xc1f4b15d96504a08ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval = frr.pop_double();
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::float_prop (double value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x25ae78062c0435cdULL, 0x1d21f473f7647360ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_double (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
PropertyTester_SmartHandle::string_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x385771786e6432dbULL, 0xcb19bfb3aa9a26feULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::string_prop (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x206d200c92ba7e41ULL, 0x857975e0304c85f3ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickEnum
PropertyTester_SmartHandle::enum_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d09e074f5d2f8edULL, 0x38e8a275e29c3fc2ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval = QuickEnum (frr.pop_evalue());
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::enum_prop (QuickEnum value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2b77a2f3a3c4d5b4ULL, 0x4d5b96d1adf5f7ccULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_evalue (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickRecord_Handle
PropertyTester_SmartHandle::record_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x31443949c61d0fecULL, 0xeb221638d6ffd3cfULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecord_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::record_prop (const QuickRecord_Handle &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a5f5c212625f446ULL, 0x30d24123307269ceULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickSequence_Handle
PropertyTester_SmartHandle::sequence_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3f323c929c803ea8ULL, 0x6ebf49e977bfb699ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequence_Handle  retval;
  frr >> retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::sequence_prop (const QuickSequence_Handle &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x232174952090a941ULL, 0xae8b7a3e13fdfde7ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb << value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
GrandChild_SmartHandle
PropertyTester_SmartHandle::interface_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x33a8b72ea92bb600ULL, 0x3837c1118556aaedULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  GrandChild_SmartHandle  retval = GrandChild_SmartHandle::_new (frr);
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::interface_prop (GrandChild_SmartHandle value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x29163b10631cf4b4ULL, 0xf014d69b1a1153e9ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_object (connection_handle2id (value));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
PropertyTester_SmartHandle
PropertyTester_SmartHandle::self_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e6b07e114fab96bULL, 0x45a97f76ee1a7bcfULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  PropertyTester_SmartHandle  retval = PropertyTester_SmartHandle::_new (frr);
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::self_prop (PropertyTester_SmartHandle value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2c1aea6b5567c7beULL, 0x8f21acd05f5030deULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_object (connection_handle2id (value));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}

static inline void ref   (PropertyTester_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (PropertyTester_SmartHandle&) {} // dummy stub for Signal<>.emit
// === PropertyTester ===
struct PropertyTester_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public PropertyTester_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  PropertyTester_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
PropertyTester_SmartHandle::PropertyTester_SmartHandle ()
{}
PropertyTester_SmartHandle
PropertyTester_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<PropertyTester_Context$> (fbr.pop_object())->handle$;
}
} // InterfaceTests

namespace RapicornPlicTest {
std::string
ButtonArea_SmartHandle::on_click () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e3aae70657f83b7ULL, 0x728ed182ccdc4020ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2d526a22ceb83792ULL, 0x62169ce8c45be6e0ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonArea_SmartHandle::on_click2 () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3c128313732bc9a9ULL, 0xad69a127aa1ce9b0ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click2 (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x23c57c80df9b0efbULL, 0xb8e860a363947d7dULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonArea_SmartHandle::on_click3 () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x380ad1778851e535ULL, 0x5b045ec25d2deb0eULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval = frr.pop_string();
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click3 (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x27d09d1b9508a02bULL, 0x1e072d4d979e4921ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_string (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
ClickType
ButtonArea_SmartHandle::click_type () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d39bef0c031e35dULL, 0x7ea1af466f8574b1ULL);
  fb.add_object (connection_handle2id ((*this)));
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  ClickType  retval = ClickType (frr.pop_evalue());
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::click_type (ClickType value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x27b69c1801d07bbeULL, 0x929dbc4b4f2ea981ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_evalue (value);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}

static inline void ref   (ButtonArea_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (ButtonArea_SmartHandle&) {} // dummy stub for Signal<>.emit
// === ButtonArea ===
struct ButtonArea_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public ButtonArea_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  struct Signal_check_activate_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, bool (), Rapicorn::Signals::CollectorUntil0<bool>, Rapicorn::Signals::SignalConnectionRelay<Signal_check_activate_EventHandler$> > Signal_check_activate;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_check_activate signal;
    Signal_check_activate_EventHandler$ (ButtonArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_check_activate_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } check_activate;
  struct Signal_activate_EventHandler$ : Plic::Connection::EventHandler {
    typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, void (), Rapicorn::Signals::CollectorDefault<void>, Rapicorn::Signals::SignalConnectionRelay<Signal_activate_EventHandler$> > Signal_activate;
    virtual Plic::FieldBuffer* handle_event (Plic::FieldBuffer &fb);
    uint64 m_handler_id, m_connection_id;
    Signal_activate signal;
    Signal_activate_EventHandler$ (ButtonArea_SmartHandle &handle) : m_handler_id (0), m_connection_id (0), signal (handle) {}
    ~Signal_activate_EventHandler$ ()
    { if (m_handler_id) PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0; }
    void  connections_changed (bool hasconnections);
  } activate;
  ButtonArea_Context$ (uint64 ipcid) :
    handle$ (ipcid),
    check_activate (handle$),
    activate (handle$)
  {
    handle$.check_activate = check_activate.signal;
    check_activate.signal.listener (check_activate, &Signal_check_activate_EventHandler$::connections_changed);
    handle$.activate = activate.signal;
    activate.signal.listener (activate, &Signal_activate_EventHandler$::connections_changed);
  }
};
void
ButtonArea_Context$::Signal_check_activate_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x5aa49f58f83f54b7ULL, 0xff357b59e593e480ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
ButtonArea_Context$::Signal_check_activate_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  bool  rval = signal.emit ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
void
ButtonArea_Context$::Signal_activate_EventHandler$::connections_changed (bool hasconnections)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
  fb.add_msgid (0x567351a83995c46eULL, 0xcd153a5a755401f6ULL);
  fb.add_object (connection_handle2id (*signal.emitter()));
  if (hasconnections) {
    if (!m_handler_id)              // signal connected
      m_handler_id = PLIC_CONNECTION().register_event_handler (this);
    fb.add_int64 (m_handler_id);    // handler connection request
    fb.add_int64 (0);               // no disconnection
  } else {                          // signal disconnected
    if (m_handler_id)
      ; // FIXME: deletion! PLIC_CONNECTION().delete_event_handler (m_handler_id), m_handler_id = 0;
    fb.add_int64 (0);               // no handler connection
    fb.add_int64 (m_connection_id); // disconnection request
    m_connection_id = 0;
  }
  Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) { // FIXME: assert that fr is a non-NULL FieldBuffer with result message
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    if (frr.remaining() && m_handler_id)
      m_connection_id = frr.pop_int64();
  }
}
Plic::FieldBuffer*
ButtonArea_Context$::Signal_activate_EventHandler$::handle_event (Plic::FieldBuffer &fb)
{
  Plic::FieldReader fbr (fb);
  fbr.skip_msgid(); // FIXME: check msgid
  fbr.skip();       // skip m_handler_id
  if (fbr.remaining() != 0) return plic$_error ("invalid number of arguments");
  signal.emit ();
  return NULL;
}
typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, bool (), Rapicorn::Signals::CollectorUntil0<bool> > ButtonArea_SmartHandle_Signal_check_activate;
typedef Rapicorn::Signals::Signal<ButtonArea_SmartHandle, void ()> ButtonArea_SmartHandle_Signal_activate;
ButtonArea_SmartHandle::ButtonArea_SmartHandle () :
  check_activate (*(ButtonArea_SmartHandle_Signal_check_activate*) NULL),
  activate (*(ButtonArea_SmartHandle_Signal_activate*) NULL)
{}
ButtonArea_SmartHandle
ButtonArea_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<ButtonArea_Context$> (fbr.pop_object())->handle$;
}

static inline void ref   (PureMethods_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (PureMethods_SmartHandle&) {} // dummy stub for Signal<>.emit
// === PureMethods ===
struct PureMethods_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public PureMethods_SmartHandle {
    SmartHandle$ (uint64 ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  PureMethods_Context$ (uint64 ipcid) :
    handle$ (ipcid)
  {
  }
};
PureMethods_SmartHandle::PureMethods_SmartHandle ()
{}
PureMethods_SmartHandle
PureMethods_SmartHandle::_new (Plic::FieldReader &fbr)
{
  return connection_id2context<PureMethods_Context$> (fbr.pop_object())->handle$;
}
int
PureMethods_SmartHandle::pure_method (double arg_f)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3c452a34192441bfULL, 0xcb1002037bf028e2ULL); // msgid
  fb.add_object (connection_handle2id ((*this)));
  fb.add_double (arg_f);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval = frr.pop_int64();
  delete fr;
  return retval;
}
} // RapicornPlicTest

