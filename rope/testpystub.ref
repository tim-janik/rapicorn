### --- Generated by Rapicorn-PyStub --- ###


class __BaseRecord__:
  def __init__ (self, **entries):
    self.__dict__.update (entries)
class __BaseClass__ (object):
  pass
class __Signal__:
  def __init__ (self, signame):
    self.name = signame

class FirstInterface (__BaseClass__):
  def __init__ (self):
    super (FirstInterface, self).__init__()
  def void_func (self): # one way
    return _PLIC_0ca10000511e8482d7fca76824ef13399c10110ffb6e89b87aee6371c6eb9333 (self)

class XFooRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = XFooRecord()
    if hasattr (args, "__iter__") and len (args) == 14:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
      self.iface1 = args[11]
      #  self.iface1.vstring (Instance2StringCast (args[11]))
      self.iface2 = args[12]
      #  self.iface2.vstring (Instance2StringCast (args[12]))
      self.iface3 = args[13]
      #  self.iface3.vstring (Instance2StringCast (args[13]))
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface1))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface2))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface3))

class NestedTypesRec (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'rec' : None,  'seq' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NestedTypesRec()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.rec = args[0]
      #  XFooRecord.to_proto (self.rec.vrec, args[0])
      self.seq = args[1]
      #  XFooSequence.to_proto (self.seq.vseq, args[1])
    elif isinstance (args, dict):
      self.rec = args["rec"]
      self.seq = args["seq"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    XFooRecord.to_proto (_plic_field.vrec, self.rec)
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.seq)

class AliasRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = AliasRecord()
    if hasattr (args, "__iter__") and len (args) == 14:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
      self.iface1 = args[11]
      #  self.iface1.vstring (Instance2StringCast (args[11]))
      self.iface2 = args[12]
      #  self.iface2.vstring (Instance2StringCast (args[12]))
      self.iface3 = args[13]
      #  self.iface3.vstring (Instance2StringCast (args[13]))
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface1))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface2))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface3))

class NewRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'i' : 0,  'enum1' : 0,  'xfs' : None,  'ntr' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NewRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.i = args[0]
      #  self.i.vint64 = args[0]
      self.enum1 = args[1]
      #  self.enum1.vint64 = args[1]
      self.xfs = args[2]
      #  XFooSequence.to_proto (self.xfs.vseq, args[2])
      self.ntr = args[3]
      #  NestedTypesRec.to_proto (self.ntr.vrec, args[3])
    elif isinstance (args, dict):
      self.i = args["i"]
      self.enum1 = args["enum1"]
      self.xfs = args["xfs"]
      self.ntr = args["ntr"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.i
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum1
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.xfs)
    _plic_field = _plic_rp.fields.add()
    NestedTypesRec.to_proto (_plic_field.vrec, self.ntr)

class InnerRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'x' : 0,  'y' : 0,  'rec' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = InnerRecord()
    if hasattr (args, "__iter__") and len (args) == 3:
      self.x = args[0]
      #  self.x.vint64 = args[0]
      self.y = args[1]
      #  self.y.vint64 = args[1]
      self.rec = args[2]
      #  NewRecord.to_proto (self.rec.vrec, args[2])
    elif isinstance (args, dict):
      self.x = args["x"]
      self.y = args["y"]
      self.rec = args["rec"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.x
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.y
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.rec)

class Refer2Inner (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'r' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = Refer2Inner()
    if hasattr (args, "__iter__") and len (args) == 1:
      self.r = args[0]
      #  InnerRecord.to_proto (self.r.vrec, args[0])
    elif isinstance (args, dict):
      self.r = args["r"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r)

class SomeRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'r1' : None,  'r2' : None,  'r3' : None,  'r4' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = SomeRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.r1 = args[0]
      #  NewRecord.to_proto (self.r1.vrec, args[0])
      self.r2 = args[1]
      #  NewRecord.to_proto (self.r2.vrec, args[1])
      self.r3 = args[2]
      #  InnerRecord.to_proto (self.r3.vrec, args[2])
      self.r4 = args[3]
      #  InnerRecord.to_proto (self.r4.vrec, args[3])
    elif isinstance (args, dict):
      self.r1 = args["r1"]
      self.r2 = args["r2"]
      self.r3 = args["r3"]
      self.r4 = args["r4"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r1)
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r2)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r3)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r4)

class UIWidgetArea (__BaseClass__):
  def __init__ (self):
    super (UIWidgetArea, self).__init__()
    self.sig_void_signal = __Signal__ ('void_signal')
    self.sig_sample_signal = __Signal__ ('sample_signal')
  def simple_method (self): # float
    return _PLIC_0ca200003a5e02ed169b0d3b86dc10cdc07a85a6dfe104ade8554a515ffc84b1 (self)
  def single_arg (self, n): # float
    return _PLIC_0ca20000f96d1b2e54efdddfc11d9638b5d0abcc8a0f16c8957078d12b4b2fc0 (self, n)
  def single_arg2 (self, n = 5): # float
    return _PLIC_0ca20000afefb8c4b9d9952905d41bfda2c44e813b1a8c4d8e440d5ecaeecec8 (self, n)
  def two_args (self, n, r): # float
    return _PLIC_0ca20000d1f5823f8538f2ffa1581dd0c9e7d9d486336a46c941f5292b4dcdfc (self, n, r)
  def two_args2 (self, n = 6, r = 7.7): # float
    return _PLIC_0ca20000255fafa4429116798ce5813e5eacea949f7cfe8e1f41fe0ca4311729 (self, n, r)
  def multi_args (self, n, r, i, s = "String ding", y = 5): # float
    return _PLIC_0ca200005e6e8ea56f4fdd2d1d4b3bb3be7de84f81bcc35391710698705b209a (self, n, r, i, s, y)
  def self_method (self, ba1, ba2): # float
    return _PLIC_0ca20000abd1f74a3f2d1aefb6d12a66100e83849c14475879488ee1596dab87 (self, ba1, ba2)
  def void_method (self): # one way
    return _PLIC_0ca1000027be4746de7d9d84a2281ae4dccb312da0062c8362d76268f178e709 (self)
  def on_click2out (self): # string
    return _PLIC_0ca20000a3ce0a03aaaf9478a83b0f7c2664b179bda29105b1f6ad88c5a0c98a (self)
  def on_click2in (self, command): # one way
    return _PLIC_0ca10000e511187c9ea59f646fca1b626180b0bf59637495a99463469b646df9 (self, command)
  def __sig_void_signal__ (self): pass # default handler
  def __sig_sample_signal__ (self): pass # default handler

class Parent (__BaseClass__):
  def __init__ (self):
    super (Parent, self).__init__()

class Child (Parent):
  def __init__ (self):
    super (Child, self).__init__()

class Descendant (Child):
  def __init__ (self):
    super (Descendant, self).__init__()

class GrandChild (Descendant):
  def __init__ (self):
    super (GrandChild, self).__init__()

class QuickRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'int1' : 0,  'int2' : 0, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = QuickRecord()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.int1 = args[0]
      #  self.int1.vint64 = args[0]
      self.int2 = args[1]
      #  self.int2.vint64 = args[1]
    elif isinstance (args, dict):
      self.int1 = args["int1"]
      self.int2 = args["int2"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int2

class QuickIface (__BaseClass__):
  def __init__ (self):
    super (QuickIface, self).__init__()
  def simple_function (self, i = 9): # one way
    return _PLIC_0ca100007178342e2c84375ab4c874afb5578ad147fe3033392cdc1a7eebbb31 (self, i)

class MethodTestInterface (__BaseClass__):
  def __init__ (self):
    super (MethodTestInterface, self).__init__()
  def method_with_void (self): # one way
    return _PLIC_0ca10000f91c872ea90ceaec3b16df51887b366247a3a6126f4b7fab28f1ab12 (self)
  def method_with_bools (self, input, optval = 0): # bool
    return _PLIC_0ca200008ffdba44c998c0ffa6b486b19b4ea9f5a23d9c6da7746e46026b843e (self, input, optval)
  def method_with_ints (self, input, optval = -2): # int
    return _PLIC_0ca20000cec55716747c3602672780d11852bd2e467d1e9161085ceb1b2bf816 (self, input, optval)
  def method_with_floats (self, input, optval = 309.9): # float
    return _PLIC_0ca200006ede6737c9ee1722db2fc5834e5788c84a81be268c32f39e18ad9ab6 (self, input, optval)
  def method_with_string (self, input, optval = "default"): # string
    return _PLIC_0ca20000d07cd262fc81ef2c220a8d4559d0faae36ce56ea0990ad1d3c49827d (self, input, optval)
  def method_with_enum (self, input, optval = 0): # QuickEnum
    return _PLIC_0ca20000d1a935c9c1bdc5f48521c942ebcb3ede7a3fcbdcba634e15fbfde688 (self, input, optval)
  def method_with_record (self, input, optval = 0): # QuickRecord
    return _PLIC_0ca2000093f684d6345260c4f912f67fa8f6c2af19dc877e176ffee81397fa2e (self, input, optval)
  def method_with_sequence (self, input, optval = 0): # QuickSequence
    return _PLIC_0ca20000f8d6703f9af82486dc8ce5aa3a6095e0829ba18574e0fc82dbfa4b77 (self, input, optval)
  def method_with_interface (self, input, optval = 0): # GrandChild
    return _PLIC_0ca20000ed320c14672f050fc4be01b7239a6c63e8d3bb3e106046b369f7e804 (self, input, optval)
  def method_with_quickiface (self, input, iface0 = 0): # QuickIface
    return _PLIC_0ca200003fcf3b3d9eeea2d03769389cb168e0c6140b94e55b03b11a28cd7427 (self, input, iface0)

class ButtonArea (__BaseClass__):
  def __init__ (self):
    super (ButtonArea, self).__init__()
    self.sig_check_activate = __Signal__ ('check_activate')
    self.sig_activate = __Signal__ ('activate')
  def __sig_check_activate__ (self): pass # default handler
  def __sig_activate__ (self): pass # default handler

class PureMethods (__BaseClass__):
  def __init__ (self):
    super (PureMethods, self).__init__()
  def pure_method (self, f): # int
    return _PLIC_0ca20000ac480384d1df259f1d53b082995d5e5b4bb2fcb483f6a92ee477fcd6 (self, f)

