### --- Generated by Rapicorn-PyStub --- ###


def __plic_module_init_once__ (cpy_module):
  del globals()['__plic_module_init_once__'] # run once only
  global _CPY
  _CPY = cpy_module

class _BaseRecord_:
  def __init__ (self, **entries):
    self.__dict__.update (entries)
class _BaseClass_ (object):
  class _AidaID_:
    def __init__ (self, _aidaid):
      assert isinstance (_aidaid, (int, long))
      self.id = _aidaid
  def __init__ (self, _plic_id):
    assert isinstance (_plic_id, _BaseClass_._AidaID_)
    self.__plic__object__ = _plic_id.id
class __Signal__:
  def __init__ (self, signame):
    self.name = signame

class FirstInterface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (FirstInterface, self).__init__ (_plic_id)
  def void_func (self): # one way
    ___ret = _CPY._AIDA_MandatoryNamespace__FirstInterface__void_func_void (self)
    return ___ret

class XFooRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None,  'any1' : (),  'any2' : (),  'any3' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = XFooRecord()
    if hasattr (args, "__iter__") and len (args) == 17:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
      self.iface1 = args[11]
      #  self.iface1.vstring (Instance2StringCast (args[11]))
      self.iface2 = args[12]
      #  self.iface2.vstring (Instance2StringCast (args[12]))
      self.iface3 = args[13]
      #  self.iface3.vstring (Instance2StringCast (args[13]))
      self.any1 = args[14]
      #  # FIXME: support PLIC::Any with any.to_proto (self.any1.vany, args[14])
      self.any2 = args[15]
      #  # FIXME: support PLIC::Any with any.to_proto (self.any2.vany, args[15])
      self.any3 = args[16]
      #  # FIXME: support PLIC::Any with any.to_proto (self.any3.vany, args[16])
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
      self.any1 = args["any1"]
      self.any2 = args["any2"]
      self.any3 = args["any3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface1))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface2))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface3))
    _plic_field = _plic_rp.fields.add()
    # FIXME: support PLIC::Any with any.to_proto (_plic_field.vany, self.any1)
    _plic_field = _plic_rp.fields.add()
    # FIXME: support PLIC::Any with any.to_proto (_plic_field.vany, self.any2)
    _plic_field = _plic_rp.fields.add()
    # FIXME: support PLIC::Any with any.to_proto (_plic_field.vany, self.any3)

class NestedTypesRec (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'rec' : None,  'seq' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NestedTypesRec()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.rec = args[0]
      #  XFooRecord.to_proto (self.rec.vrec, args[0])
      self.seq = args[1]
      #  XFooSequence.to_proto (self.seq.vseq, args[1])
    elif isinstance (args, dict):
      self.rec = args["rec"]
      self.seq = args["seq"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    XFooRecord.to_proto (_plic_field.vrec, self.rec)
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.seq)

class AliasRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None,  'any1' : (),  'any2' : (),  'any3' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = AliasRecord()
    if hasattr (args, "__iter__") and len (args) == 17:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
      self.iface1 = args[11]
      #  self.iface1.vstring (Instance2StringCast (args[11]))
      self.iface2 = args[12]
      #  self.iface2.vstring (Instance2StringCast (args[12]))
      self.iface3 = args[13]
      #  self.iface3.vstring (Instance2StringCast (args[13]))
      self.any1 = args[14]
      #  # FIXME: support PLIC::Any with any.to_proto (self.any1.vany, args[14])
      self.any2 = args[15]
      #  # FIXME: support PLIC::Any with any.to_proto (self.any2.vany, args[15])
      self.any3 = args[16]
      #  # FIXME: support PLIC::Any with any.to_proto (self.any3.vany, args[16])
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
      self.any1 = args["any1"]
      self.any2 = args["any2"]
      self.any3 = args["any3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface1))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface2))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface3))
    _plic_field = _plic_rp.fields.add()
    # FIXME: support PLIC::Any with any.to_proto (_plic_field.vany, self.any1)
    _plic_field = _plic_rp.fields.add()
    # FIXME: support PLIC::Any with any.to_proto (_plic_field.vany, self.any2)
    _plic_field = _plic_rp.fields.add()
    # FIXME: support PLIC::Any with any.to_proto (_plic_field.vany, self.any3)

class NewRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'i' : 0,  'enum1' : 0,  'xfs' : (),  'ntr' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NewRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.i = args[0]
      #  self.i.vint64 = args[0]
      self.enum1 = args[1]
      #  self.enum1.vint64 = args[1]
      self.xfs = args[2]
      #  XFooSequence.to_proto (self.xfs.vseq, args[2])
      self.ntr = args[3]
      #  NestedTypesRec.to_proto (self.ntr.vrec, args[3])
    elif isinstance (args, dict):
      self.i = args["i"]
      self.enum1 = args["enum1"]
      self.xfs = args["xfs"]
      self.ntr = args["ntr"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.i
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum1
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.xfs)
    _plic_field = _plic_rp.fields.add()
    NestedTypesRec.to_proto (_plic_field.vrec, self.ntr)

class InnerRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'x' : 0,  'y' : 0,  'rec' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = InnerRecord()
    if hasattr (args, "__iter__") and len (args) == 3:
      self.x = args[0]
      #  self.x.vint64 = args[0]
      self.y = args[1]
      #  self.y.vint64 = args[1]
      self.rec = args[2]
      #  NewRecord.to_proto (self.rec.vrec, args[2])
    elif isinstance (args, dict):
      self.x = args["x"]
      self.y = args["y"]
      self.rec = args["rec"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.x
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.y
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.rec)

class Refer2Inner (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'r' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = Refer2Inner()
    if hasattr (args, "__iter__") and len (args) == 1:
      self.r = args[0]
      #  InnerRecord.to_proto (self.r.vrec, args[0])
    elif isinstance (args, dict):
      self.r = args["r"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r)

class SomeRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'r1' : None,  'r2' : None,  'r3' : None,  'r4' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = SomeRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.r1 = args[0]
      #  NewRecord.to_proto (self.r1.vrec, args[0])
      self.r2 = args[1]
      #  NewRecord.to_proto (self.r2.vrec, args[1])
      self.r3 = args[2]
      #  InnerRecord.to_proto (self.r3.vrec, args[2])
      self.r4 = args[3]
      #  InnerRecord.to_proto (self.r4.vrec, args[3])
    elif isinstance (args, dict):
      self.r1 = args["r1"]
      self.r2 = args["r2"]
      self.r3 = args["r3"]
      self.r4 = args["r4"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r1)
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r2)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r3)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r4)

class UIWidgetArea (_BaseClass_):
  def __init__ (self, _plic_id):
    super (UIWidgetArea, self).__init__ (_plic_id)
    self.sig_void_signal = __Signal__ ('void_signal')
    self.sig_sample_signal = __Signal__ ('sample_signal')
  def simple_method (self): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__simple_method_float (self)
    return ___ret
  def single_arg (self, n): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__single_arg_float_int (self, n)
    return ___ret
  def single_arg2 (self, n = 5): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__single_arg2_float_int (self, n)
    return ___ret
  def two_args (self, n, r): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__two_args_float_int_float (self, n, r)
    return ___ret
  def two_args2 (self, n = 6, r = 7.7): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__two_args2_float_int_float (self, n, r)
    return ___ret
  def multi_args (self, n, r, i, s = "String ding", y = 5): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__multi_args_float_int_float_int_string_float (self, n, r, i, s, y)
    return ___ret
  def self_method (self, ba1, ba2): # float
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__self_method_float_InterfaceTests__UIWidgetArea_InterfaceTests__UIWidgetArea (self, ba1, ba2)
    return ___ret
  def void_method (self): # one way
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__void_method_void (self)
    return ___ret
  def on_click2out (self): # string
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__on_click2out_string (self)
    return ___ret
  def on_click2in (self, command): # one way
    ___ret = _CPY._AIDA_InterfaceTests__UIWidgetArea__on_click2in_void_string (self, command)
    return ___ret
  def __sig_void_signal__ (self): pass # default handler
  def sig_void_signal_connect (self, func):
    return _CPY._AIDA_InterfaceTests__UIWidgetArea__void_signal_void (self, func, 0)
  def sig_void_signal_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__UIWidgetArea__void_signal_void (self, None, connection_id)
  def __sig_sample_signal__ (self): pass # default handler
  def sig_sample_signal_connect (self, func):
    return _CPY._AIDA_InterfaceTests__UIWidgetArea__sample_signal_float_InterfaceTests__UIWidgetArea_int (self, func, 0)
  def sig_sample_signal_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__UIWidgetArea__sample_signal_float_InterfaceTests__UIWidgetArea_int (self, None, connection_id)

class Parent (_BaseClass_):
  def __init__ (self, _plic_id):
    super (Parent, self).__init__ (_plic_id)

class Child (Parent):
  def __init__ (self, _plic_id):
    super (Child, self).__init__ (_plic_id)

class Descendant (Child):
  def __init__ (self, _plic_id):
    super (Descendant, self).__init__ (_plic_id)

class GrandChild (Descendant):
  def __init__ (self, _plic_id):
    super (GrandChild, self).__init__ (_plic_id)

class QuickRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'int1' : 0,  'int2' : 0, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = QuickRecord()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.int1 = args[0]
      #  self.int1.vint64 = args[0]
      self.int2 = args[1]
      #  self.int2.vint64 = args[1]
    elif isinstance (args, dict):
      self.int1 = args["int1"]
      self.int2 = args["int2"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int2

class QuickIface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (QuickIface, self).__init__ (_plic_id)
  def simple_function (self, i = 9): # one way
    ___ret = _CPY._AIDA_InterfaceTests__QuickIface__simple_function_void_int (self, i)
    return ___ret

class MethodTestInterface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (MethodTestInterface, self).__init__ (_plic_id)
  def method_with_void (self): # one way
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_void_void (self)
    return ___ret
  def method_with_bools (self, input, optval = 0): # bool
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_bools_bool_bool_bool (self, input, optval)
    return ___ret
  def method_with_ints (self, input, optval = -2): # int
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_ints_int_int_int (self, input, optval)
    return ___ret
  def method_with_floats (self, input, optval = 309.9): # float
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_floats_float_float_float (self, input, optval)
    return ___ret
  def method_with_string (self, input, optval = "default"): # string
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_string_string_string_string (self, input, optval)
    return ___ret
  def method_with_enum (self, input, optval = 0): # QuickEnum
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_enum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum (self, input, optval)
    return ___ret
  def method_with_record (self, input, optval = None): # QuickRecord
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_record_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord (self, input, optval)
    return ___ret
  def method_with_sequence (self, input, optval = ()): # QuickSequence
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_sequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence (self, input, optval)
    return ___ret
  def method_with_interface (self, input, optval = None): # GrandChild
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_interface_InterfaceTests__GrandChild_InterfaceTests__GrandChild_InterfaceTests__GrandChild (self, input, optval)
    return ___ret
  def method_with_anys (self, input, optval): # any
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_anys_any_any_any (self, input, optval)
    return ___ret
  def method_with_quickiface (self, input, iface0 = None): # QuickIface
    ___ret = _CPY._AIDA_InterfaceTests__MethodTestInterface__method_with_quickiface_InterfaceTests__QuickIface_InterfaceTests__QuickIface_InterfaceTests__QuickIface (self, input, iface0)
    return ___ret

class SignalTestInterface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (SignalTestInterface, self).__init__ (_plic_id)
    self.sig_void_result = __Signal__ ('void_result')
    self.sig_bool_result = __Signal__ ('bool_result')
    self.sig_int_result = __Signal__ ('int_result')
    self.sig_float_result = __Signal__ ('float_result')
    self.sig_string_result = __Signal__ ('string_result')
    self.sig_enum_result = __Signal__ ('enum_result')
    self.sig_record_result = __Signal__ ('record_result')
    self.sig_sequence_result = __Signal__ ('sequence_result')
    self.sig_interface_result = __Signal__ ('interface_result')
    self.sig_any_result = __Signal__ ('any_result')
    self.sig_self_result = __Signal__ ('self_result')
    self.sig_void_arg = __Signal__ ('void_arg')
    self.sig_bool_arg = __Signal__ ('bool_arg')
    self.sig_int_arg = __Signal__ ('int_arg')
    self.sig_float_arg = __Signal__ ('float_arg')
    self.sig_string_arg = __Signal__ ('string_arg')
    self.sig_enum_arg = __Signal__ ('enum_arg')
    self.sig_record_arg = __Signal__ ('record_arg')
    self.sig_sequence_arg = __Signal__ ('sequence_arg')
    self.sig_interface_arg = __Signal__ ('interface_arg')
    self.sig_any_arg = __Signal__ ('any_arg')
    self.sig_self_args = __Signal__ ('self_args')
  def __sig_void_result__ (self): pass # default handler
  def sig_void_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__void_result_void (self, func, 0)
  def sig_void_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__void_result_void (self, None, connection_id)
  def __sig_bool_result__ (self): pass # default handler
  def sig_bool_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__bool_result_bool (self, func, 0)
  def sig_bool_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__bool_result_bool (self, None, connection_id)
  def __sig_int_result__ (self): pass # default handler
  def sig_int_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__int_result_int (self, func, 0)
  def sig_int_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__int_result_int (self, None, connection_id)
  def __sig_float_result__ (self): pass # default handler
  def sig_float_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__float_result_float (self, func, 0)
  def sig_float_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__float_result_float (self, None, connection_id)
  def __sig_string_result__ (self): pass # default handler
  def sig_string_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__string_result_string (self, func, 0)
  def sig_string_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__string_result_string (self, None, connection_id)
  def __sig_enum_result__ (self): pass # default handler
  def sig_enum_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__enum_result_InterfaceTests__QuickEnum (self, func, 0)
  def sig_enum_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__enum_result_InterfaceTests__QuickEnum (self, None, connection_id)
  def __sig_record_result__ (self): pass # default handler
  def sig_record_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__record_result_InterfaceTests__QuickRecord (self, func, 0)
  def sig_record_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__record_result_InterfaceTests__QuickRecord (self, None, connection_id)
  def __sig_sequence_result__ (self): pass # default handler
  def sig_sequence_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__sequence_result_InterfaceTests__QuickSequence (self, func, 0)
  def sig_sequence_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__sequence_result_InterfaceTests__QuickSequence (self, None, connection_id)
  def __sig_interface_result__ (self): pass # default handler
  def sig_interface_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__interface_result_InterfaceTests__GrandChild (self, func, 0)
  def sig_interface_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__interface_result_InterfaceTests__GrandChild (self, None, connection_id)
  def __sig_any_result__ (self): pass # default handler
  def sig_any_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__any_result_any (self, func, 0)
  def sig_any_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__any_result_any (self, None, connection_id)
  def __sig_self_result__ (self): pass # default handler
  def sig_self_result_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__self_result_InterfaceTests__SignalTestInterface (self, func, 0)
  def sig_self_result_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__self_result_InterfaceTests__SignalTestInterface (self, None, connection_id)
  def __sig_void_arg__ (self): pass # default handler
  def sig_void_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__void_arg_void (self, func, 0)
  def sig_void_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__void_arg_void (self, None, connection_id)
  def __sig_bool_arg__ (self): pass # default handler
  def sig_bool_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__bool_arg_void_bool (self, func, 0)
  def sig_bool_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__bool_arg_void_bool (self, None, connection_id)
  def __sig_int_arg__ (self): pass # default handler
  def sig_int_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__int_arg_void_int (self, func, 0)
  def sig_int_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__int_arg_void_int (self, None, connection_id)
  def __sig_float_arg__ (self): pass # default handler
  def sig_float_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__float_arg_void_float (self, func, 0)
  def sig_float_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__float_arg_void_float (self, None, connection_id)
  def __sig_string_arg__ (self): pass # default handler
  def sig_string_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__string_arg_void_string (self, func, 0)
  def sig_string_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__string_arg_void_string (self, None, connection_id)
  def __sig_enum_arg__ (self): pass # default handler
  def sig_enum_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__enum_arg_void_InterfaceTests__QuickEnum (self, func, 0)
  def sig_enum_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__enum_arg_void_InterfaceTests__QuickEnum (self, None, connection_id)
  def __sig_record_arg__ (self): pass # default handler
  def sig_record_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__record_arg_void_InterfaceTests__QuickRecord (self, func, 0)
  def sig_record_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__record_arg_void_InterfaceTests__QuickRecord (self, None, connection_id)
  def __sig_sequence_arg__ (self): pass # default handler
  def sig_sequence_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__sequence_arg_void_InterfaceTests__QuickSequence (self, func, 0)
  def sig_sequence_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__sequence_arg_void_InterfaceTests__QuickSequence (self, None, connection_id)
  def __sig_interface_arg__ (self): pass # default handler
  def sig_interface_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__interface_arg_void_InterfaceTests__GrandChild (self, func, 0)
  def sig_interface_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__interface_arg_void_InterfaceTests__GrandChild (self, None, connection_id)
  def __sig_any_arg__ (self): pass # default handler
  def sig_any_arg_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__any_arg_void_any (self, func, 0)
  def sig_any_arg_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__any_arg_void_any (self, None, connection_id)
  def __sig_self_args__ (self): pass # default handler
  def sig_self_args_connect (self, func):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__self_args_void_InterfaceTests__SignalTestInterface (self, func, 0)
  def sig_self_args_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__SignalTestInterface__self_args_void_InterfaceTests__SignalTestInterface (self, None, connection_id)

class ChildInheritingSignals (SignalTestInterface):
  def __init__ (self, _plic_id):
    super (ChildInheritingSignals, self).__init__ (_plic_id)
    self.sig_child_signal = __Signal__ ('child_signal')
  def __sig_child_signal__ (self): pass # default handler
  def sig_child_signal_connect (self, func):
    return _CPY._AIDA_InterfaceTests__ChildInheritingSignals__child_signal_void_InterfaceTests__ChildInheritingSignals_InterfaceTests__SignalTestInterface_any_int_InterfaceTests__QuickRecord_InterfaceTests__QuickSequence (self, func, 0)
  def sig_child_signal_disconnect (self, connection_id):
    return _CPY._AIDA_InterfaceTests__ChildInheritingSignals__child_signal_void_InterfaceTests__ChildInheritingSignals_InterfaceTests__SignalTestInterface_any_int_InterfaceTests__QuickRecord_InterfaceTests__QuickSequence (self, None, connection_id)

class AnotherChild (SignalTestInterface):
  def __init__ (self, _plic_id):
    super (AnotherChild, self).__init__ (_plic_id)

class PropertyTester (_BaseClass_):
  def __init__ (self, _plic_id):
    super (PropertyTester, self).__init__ (_plic_id)

class ButtonArea (_BaseClass_):
  def __init__ (self, _plic_id):
    super (ButtonArea, self).__init__ (_plic_id)
    self.sig_check_activate = __Signal__ ('check_activate')
    self.sig_activate = __Signal__ ('activate')
  def __sig_check_activate__ (self): pass # default handler
  def sig_check_activate_connect (self, func):
    return _CPY._AIDA_RapicornPlicTest__ButtonArea__check_activate_bool (self, func, 0)
  def sig_check_activate_disconnect (self, connection_id):
    return _CPY._AIDA_RapicornPlicTest__ButtonArea__check_activate_bool (self, None, connection_id)
  def __sig_activate__ (self): pass # default handler
  def sig_activate_connect (self, func):
    return _CPY._AIDA_RapicornPlicTest__ButtonArea__activate_void (self, func, 0)
  def sig_activate_disconnect (self, connection_id):
    return _CPY._AIDA_RapicornPlicTest__ButtonArea__activate_void (self, None, connection_id)

class PureMethods (_BaseClass_):
  def __init__ (self, _plic_id):
    super (PureMethods, self).__init__ (_plic_id)
  def pure_method (self, f): # int
    ___ret = _CPY._AIDA_RapicornPlicTest__PureMethods__pure_method_int_float (self, f)
    return ___ret

