### --- Generated by Rapicorn-PyStub --- ###


class _BaseRecord_:
  def __init__ (self, **entries):
    self.__dict__.update (entries)
class _BaseClass_ (object):
  class _PlicID_:
    def __init__ (self, _plicid):
      self.id = _plicid
  def __init__ (self, _plic_id):
    assert isinstance (_plic_id, _BaseClass_._PlicID_)
    self.__plic__object__ = _plic_id.id
class __Signal__:
  def __init__ (self, signame):
    self.name = signame

class FirstInterface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (FirstInterface, self).__init__ (_plic_id)
  def void_func (self): # one way
    ___ret = _PLIC_MandatoryNamespace__FirstInterface_void_func_void (self)
    return ___ret

class XFooRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = XFooRecord()
    if hasattr (args, "__iter__") and len (args) == 14:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
      self.iface1 = args[11]
      #  self.iface1.vstring (Instance2StringCast (args[11]))
      self.iface2 = args[12]
      #  self.iface2.vstring (Instance2StringCast (args[12]))
      self.iface3 = args[13]
      #  self.iface3.vstring (Instance2StringCast (args[13]))
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface1))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface2))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface3))

class NestedTypesRec (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'rec' : None,  'seq' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NestedTypesRec()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.rec = args[0]
      #  XFooRecord.to_proto (self.rec.vrec, args[0])
      self.seq = args[1]
      #  XFooSequence.to_proto (self.seq.vseq, args[1])
    elif isinstance (args, dict):
      self.rec = args["rec"]
      self.seq = args["seq"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    XFooRecord.to_proto (_plic_field.vrec, self.rec)
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.seq)

class AliasRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = AliasRecord()
    if hasattr (args, "__iter__") and len (args) == 14:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
      self.iface1 = args[11]
      #  self.iface1.vstring (Instance2StringCast (args[11]))
      self.iface2 = args[12]
      #  self.iface2.vstring (Instance2StringCast (args[12]))
      self.iface3 = args[13]
      #  self.iface3.vstring (Instance2StringCast (args[13]))
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface1))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface2))
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring (Instance2StringCast (self.iface3))

class NewRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'i' : 0,  'enum1' : 0,  'xfs' : (),  'ntr' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NewRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.i = args[0]
      #  self.i.vint64 = args[0]
      self.enum1 = args[1]
      #  self.enum1.vint64 = args[1]
      self.xfs = args[2]
      #  XFooSequence.to_proto (self.xfs.vseq, args[2])
      self.ntr = args[3]
      #  NestedTypesRec.to_proto (self.ntr.vrec, args[3])
    elif isinstance (args, dict):
      self.i = args["i"]
      self.enum1 = args["enum1"]
      self.xfs = args["xfs"]
      self.ntr = args["ntr"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.i
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum1
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.xfs)
    _plic_field = _plic_rp.fields.add()
    NestedTypesRec.to_proto (_plic_field.vrec, self.ntr)

class InnerRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'x' : 0,  'y' : 0,  'rec' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = InnerRecord()
    if hasattr (args, "__iter__") and len (args) == 3:
      self.x = args[0]
      #  self.x.vint64 = args[0]
      self.y = args[1]
      #  self.y.vint64 = args[1]
      self.rec = args[2]
      #  NewRecord.to_proto (self.rec.vrec, args[2])
    elif isinstance (args, dict):
      self.x = args["x"]
      self.y = args["y"]
      self.rec = args["rec"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.x
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.y
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.rec)

class Refer2Inner (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'r' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = Refer2Inner()
    if hasattr (args, "__iter__") and len (args) == 1:
      self.r = args[0]
      #  InnerRecord.to_proto (self.r.vrec, args[0])
    elif isinstance (args, dict):
      self.r = args["r"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r)

class SomeRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'r1' : None,  'r2' : None,  'r3' : None,  'r4' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = SomeRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.r1 = args[0]
      #  NewRecord.to_proto (self.r1.vrec, args[0])
      self.r2 = args[1]
      #  NewRecord.to_proto (self.r2.vrec, args[1])
      self.r3 = args[2]
      #  InnerRecord.to_proto (self.r3.vrec, args[2])
      self.r4 = args[3]
      #  InnerRecord.to_proto (self.r4.vrec, args[3])
    elif isinstance (args, dict):
      self.r1 = args["r1"]
      self.r2 = args["r2"]
      self.r3 = args["r3"]
      self.r4 = args["r4"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r1)
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r2)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r3)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r4)

class UIWidgetArea (_BaseClass_):
  def __init__ (self, _plic_id):
    super (UIWidgetArea, self).__init__ (_plic_id)
    self.sig_void_signal = __Signal__ ('void_signal')
    self.sig_sample_signal = __Signal__ ('sample_signal')
  def simple_method (self): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_simple_method_float (self)
    return ___ret
  def single_arg (self, n): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_single_arg_float_int (self, n)
    return ___ret
  def single_arg2 (self, n = 5): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_single_arg2_float_int (self, n)
    return ___ret
  def two_args (self, n, r): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_two_args_float_int_float (self, n, r)
    return ___ret
  def two_args2 (self, n = 6, r = 7.7): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_two_args2_float_int_float (self, n, r)
    return ___ret
  def multi_args (self, n, r, i, s = "String ding", y = 5): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_multi_args_float_int_float_int_string_float (self, n, r, i, s, y)
    return ___ret
  def self_method (self, ba1, ba2): # float
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_self_method_float_InterfaceTests__UIWidgetArea_InterfaceTests__UIWidgetArea (self, ba1, ba2)
    return ___ret
  def void_method (self): # one way
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_void_method_void (self)
    return ___ret
  def on_click2out (self): # string
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_on_click2out_string (self)
    return ___ret
  def on_click2in (self, command): # one way
    ___ret = _PLIC_InterfaceTests__UIWidgetArea_on_click2in_void_string (self, command)
    return ___ret
  def __sig_void_signal__ (self): pass # default handler
  def __sig_sample_signal__ (self): pass # default handler

class Parent (_BaseClass_):
  def __init__ (self, _plic_id):
    super (Parent, self).__init__ (_plic_id)

class Child (Parent):
  def __init__ (self, _plic_id):
    super (Child, self).__init__ (_plic_id)

class Descendant (Child):
  def __init__ (self, _plic_id):
    super (Descendant, self).__init__ (_plic_id)

class GrandChild (Descendant):
  def __init__ (self, _plic_id):
    super (GrandChild, self).__init__ (_plic_id)

class QuickRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'int1' : 0,  'int2' : 0, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = QuickRecord()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.int1 = args[0]
      #  self.int1.vint64 = args[0]
      self.int2 = args[1]
      #  self.int2.vint64 = args[1]
    elif isinstance (args, dict):
      self.int1 = args["int1"]
      self.int2 = args["int2"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int2

class QuickIface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (QuickIface, self).__init__ (_plic_id)
  def simple_function (self, i = 9): # one way
    ___ret = _PLIC_InterfaceTests__QuickIface_simple_function_void_int (self, i)
    return ___ret

class MethodTestInterface (_BaseClass_):
  def __init__ (self, _plic_id):
    super (MethodTestInterface, self).__init__ (_plic_id)
  def method_with_void (self): # one way
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_void_void (self)
    return ___ret
  def method_with_bools (self, input, optval = 0): # bool
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_bools_bool_bool_bool (self, input, optval)
    return ___ret
  def method_with_ints (self, input, optval = -2): # int
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_ints_int_int_int (self, input, optval)
    return ___ret
  def method_with_floats (self, input, optval = 309.9): # float
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_floats_float_float_float (self, input, optval)
    return ___ret
  def method_with_string (self, input, optval = "default"): # string
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_string_string_string_string (self, input, optval)
    return ___ret
  def method_with_enum (self, input, optval = 0): # QuickEnum
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_enum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum (self, input, optval)
    return ___ret
  def method_with_record (self, input, optval = None): # QuickRecord
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_record_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord (self, input, optval)
    return ___ret
  def method_with_sequence (self, input, optval = ()): # QuickSequence
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_sequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence (self, input, optval)
    return ___ret
  def method_with_interface (self, input, optval = None): # GrandChild
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_interface_InterfaceTests__GrandChild_InterfaceTests__GrandChild_InterfaceTests__GrandChild (self, input, optval)
    ___ret = GrandChild (_BaseClass_._PlicID_ (___ret))
    return ___ret
  def method_with_quickiface (self, input, iface0 = None): # QuickIface
    ___ret = _PLIC_InterfaceTests__MethodTestInterface_method_with_quickiface_InterfaceTests__QuickIface_InterfaceTests__QuickIface_InterfaceTests__QuickIface (self, input, iface0)
    ___ret = QuickIface (_BaseClass_._PlicID_ (___ret))
    return ___ret

class ButtonArea (_BaseClass_):
  def __init__ (self, _plic_id):
    super (ButtonArea, self).__init__ (_plic_id)
    self.sig_check_activate = __Signal__ ('check_activate')
    self.sig_activate = __Signal__ ('activate')
  def __sig_check_activate__ (self): pass # default handler
  def __sig_activate__ (self): pass # default handler

class PureMethods (_BaseClass_):
  def __init__ (self, _plic_id):
    super (PureMethods, self).__init__ (_plic_id)
  def pure_method (self, f): # int
    ___ret = _PLIC_RapicornPlicTest__PureMethods_pure_method_int_float (self, f)
    return ___ret

