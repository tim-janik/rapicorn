/* --- Generated by Rapicorn-CxxPyStub --- */

#include <Python.h> // must be included first to configure std headers
#include <string>

#include <rapicorn-core.hh>

#define None_INCREF()   ({ Py_INCREF (Py_None); Py_None; })
#define GOTO_ERROR()    goto error
#define ERRORif(cond)   if (cond) goto error
#define ERRORifpy()     if (PyErr_Occurred()) goto error
#define ERRORpy(msg)    do { PyErr_Format (PyExc_RuntimeError, msg); goto error; } while (0)
#define ERRORifnotret(fr) do { if (PLIC_UNLIKELY (!fr) || \
                                   PLIC_UNLIKELY (!Plic::is_msgid_result (fr->first_id()))) { \
                                 PyErr_Format_from_PLIC_error (fr); \
                                 goto error; } } while (0)

using Plic::uint64;
using Plic::FieldBuffer;
using Plic::FieldBufferReader;

static PyObject*
PyErr_Format_from_PLIC_error (const FieldBuffer *fr)
{
  if (!fr)
    return PyErr_Format (PyExc_RuntimeError, "PLIC: missing return value");
  if (Plic::msgid_has_error (fr->first_id()))
    {
      FieldBufferReader frr (*fr);
      std::string msg = "unknown message", domain;
      frr.skip(); // proc_id
      if (Plic::is_msgid_error (frr.pop_int64()))
        msg = frr.pop_string(), domain = frr.pop_string();
      if (domain.size()) domain += ": ";
      msg = domain + msg;
      return PyErr_Format (PyExc_RuntimeError, "%s", msg.c_str());
    }

  return PyErr_Format (PyExc_RuntimeError, "PLIC: garbage return: 0x%s", fr->first_id_str().c_str());
}

static inline PY_LONG_LONG
PyIntLong_AsLongLong (PyObject *intlong)
{
  if (PyInt_Check (intlong))
    return PyInt_AS_LONG (intlong);
  else
    return PyLong_AsLongLong (intlong);
}

static inline std::string
PyString_As_std_string (PyObject *pystr)
{
  char *s = NULL;
  Py_ssize_t len = 0;
  PyString_AsStringAndSize (pystr, &s, &len);
  return std::string (s, len);
}

static inline Plic::uint64
PyAttr_As_uint64 (PyObject *pyobj, const char *attr_name)
{
  PyObject *o = PyObject_GetAttrString (pyobj, attr_name);
  if (o)
     return PyLong_AsUnsignedLongLong (o);
  return 0;
}

static inline PyObject*
PyString_From_std_string (const std::string &s)
{
  return PyString_FromStringAndSize (s.data(), s.size());
}

static inline int
PyDict_Take_Item (PyObject *pydict, const char *key, PyObject **pyitemp)
{
  int r = PyDict_SetItemString (pydict, key, *pyitemp);
  if (r >= 0)
    {
      Py_DECREF (*pyitemp);
      *pyitemp = NULL;
    }
  return r;
}

static inline int
PyList_Take_Item (PyObject *pylist, PyObject **pyitemp)
{
  int r = PyList_Append (pylist, *pyitemp);
  if (r >= 0)
    {
      Py_DECREF (*pyitemp);
      *pyitemp = NULL;
    }
  return r;
}

#ifndef PLIC_COUPLER
#define PLIC_COUPLER()  _plic_coupler_static
static struct _UnimplementedCoupler : public Plic::Coupler {
  virtual FieldBuffer* call_remote (FieldBuffer *fbcall) { return NULL; }
} _plic_coupler_static;
#endif

enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
struct XFooRecord;
struct NestedTypesRec;
struct NewRecord;
struct InnerRecord;
struct Refer2Inner;
struct SomeRecord;
enum QuickEnum {
  ZERO = 0,
};
struct QuickRecord;
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
static RAPICORN_UNUSED bool
plic_pyXFooRecord_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (14);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "single_bool"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "single_num"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "single_float"); ERRORif (!item);
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "single_string"); ERRORif (!item);
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "sibling1"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "sibling2"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi1"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi2"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi3"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi4"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "enum_field"); ERRORif (!item);
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "iface1"); ERRORif (!item);
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyDict_GetItemString (dictR, "iface2"); ERRORif (!item);
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyDict_GetItemString (dictR, "iface3"); ERRORif (!item);
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyXFooRecord_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 14) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "single_bool", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "single_num", &pyfoR) < 0) goto error;
  pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "single_float", &pyfoR) < 0) goto error;
  pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "single_string", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "sibling1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "sibling2", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi2", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi3", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi4", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "enum_field", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromUnsignedLongLong (fbr.pop_object()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "iface1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromUnsignedLongLong (fbr.pop_object()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "iface2", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromUnsignedLongLong (fbr.pop_object()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "iface3", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyXFooSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyXFooSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyIntSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyIntSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyFloatSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyFloatSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyStringSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyStringSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyExtensiveEnumSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyExtensiveEnumSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyRecordSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    if (!plic_pyXFooRecord_proto_add (item, fb)) goto error;
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyRecordSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = plic_pyXFooRecord_proto_pop (fbr); ERRORif (!pyfoR);
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pySequenceSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    if (!plic_pyIntSequence_proto_add (item, fb)) goto error;
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pySequenceSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = plic_pyIntSequence_proto_pop (fbr); ERRORif (!pyfoR);
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyInterfaceSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyInterfaceSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromUnsignedLongLong (fbr.pop_object()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyNestedTypesRec_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "rec"); ERRORif (!item);
  if (!plic_pyXFooRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "seq"); ERRORif (!item);
  if (!plic_pyXFooSequence_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyNestedTypesRec_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = plic_pyXFooRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "rec", &pyfoR) < 0) goto error;
  pyfoR = plic_pyXFooSequence_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "seq", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyNestedTypesSeq_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    if (!plic_pyNestedTypesRec_proto_add (item, fb)) goto error;
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyNestedTypesSeq_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = plic_pyNestedTypesRec_proto_pop (fbr); ERRORif (!pyfoR);
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyNewRecord_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "i"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "enum1"); ERRORif (!item);
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "xfs"); ERRORif (!item);
  if (!plic_pyXFooSequence_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "ntr"); ERRORif (!item);
  if (!plic_pyNestedTypesRec_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyNewRecord_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "i", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "enum1", &pyfoR) < 0) goto error;
  pyfoR = plic_pyXFooSequence_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "xfs", &pyfoR) < 0) goto error;
  pyfoR = plic_pyNestedTypesRec_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "ntr", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyInnerRecord_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "x"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "y"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "rec"); ERRORif (!item);
  if (!plic_pyNewRecord_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyInnerRecord_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 3) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "x", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "y", &pyfoR) < 0) goto error;
  pyfoR = plic_pyNewRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "rec", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyRefer2Inner_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "r"); ERRORif (!item);
  if (!plic_pyInnerRecord_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyRefer2Inner_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 1) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = plic_pyInnerRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pySomeRecord_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "r1"); ERRORif (!item);
  if (!plic_pyNewRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "r2"); ERRORif (!item);
  if (!plic_pyNewRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "r3"); ERRORif (!item);
  if (!plic_pyInnerRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "r4"); ERRORif (!item);
  if (!plic_pyInnerRecord_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pySomeRecord_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = plic_pyNewRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r1", &pyfoR) < 0) goto error;
  pyfoR = plic_pyNewRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r2", &pyfoR) < 0) goto error;
  pyfoR = plic_pyInnerRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r3", &pyfoR) < 0) goto error;
  pyfoR = plic_pyInnerRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r4", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyQuickRecord_proto_add (PyObject *pyrec, Plic::FieldBuffer &dst)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "int1"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "int2"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyQuickRecord_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "int1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "int2", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyQuickSequence_proto_add (PyObject *pyinput, Plic::FieldBuffer &dst)
{
  PyObject *pyseq = PySequence_Fast (pyinput, "expected a sequence"); if (!pyseq) return false;
  const ssize_t len = PySequence_Fast_GET_SIZE (pyseq); if (len < 0) return false;
  Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PySequence_Fast_GET_ITEM (pyseq, k);
    fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyQuickSequence_proto_pop (Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static PyObject*
_plic_rpc_MandatoryNamespace__FirstInterface_void_func_void (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 0), *fr = NULL;
  fb.add_type_hash (0x200000001dfd7256ULL, 0xdec25cd632ee83caULL, 0x06b4549d6fedf832ULL, 0x9a1e54caedf1db9bULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_simple_method_float (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 0), *fr = NULL;
  fb.add_type_hash (0x30000000fd8072dfULL, 0x591f7cce6e74034aULL, 0x419df82c635c78d1ULL, 0x1e2fc6cf88d761faULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_single_arg_float_int (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 1), *fr = NULL;
  fb.add_type_hash (0x3000000075ce4c8bULL, 0x1a40a9c8bd145a39ULL, 0x37b83f96f1d3168bULL, 0x3f57c461185c3752ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_single_arg2_float_int (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 1), *fr = NULL;
  fb.add_type_hash (0x30000000179c202fULL, 0xa554850da029f547ULL, 0xe2591a43b7c79a61ULL, 0xe19a6853f11b1b99ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_two_args_float_int_float (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x300000006a210506ULL, 0xa76bb7cd90d84838ULL, 0x8000823cfb905b8cULL, 0x39826abcf9caba00ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // r
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_two_args2_float_int_float (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x30000000ac125ff1ULL, 0xac6be3d45e25ada6ULL, 0x040efc8ab508b1d3ULL, 0x15e48df9e26c0caaULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // r
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_multi_args_float_int_float_int_string_float (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 5), *fr = NULL;
  fb.add_type_hash (0x300000000361838dULL, 0xc298afde820561a5ULL, 0x8fe8c83788c4bb38ULL, 0xb3179ae3d510e7b2ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 5) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // r
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // i
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 4); // s
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 5); // y
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_self_method_float_InterfaceTests__UIWidgetArea_InterfaceTests__UIWidgetArea (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x30000000b9d64621ULL, 0x3a96692d3e1ef7dbULL, 0xdced671b586f7aa7ULL, 0x1d3870f7ed0285e5ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // ba1
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // ba2
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_void_method_void (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 0), *fr = NULL;
  fb.add_type_hash (0x200000000ff38422ULL, 0x440e8e84942acf8eULL, 0x0c4945e5794d8356ULL, 0x2e2e61471f31bfbfULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_on_click2out_string (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 0), *fr = NULL;
  fb.add_type_hash (0x300000004b649644ULL, 0x8a9b2140ad7fc83dULL, 0x10b67ed382387b14ULL, 0xe7b6cc0714a17f30ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyString_From_std_string (frr.pop_string()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__UIWidgetArea_on_click2in_void_string (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 1), *fr = NULL;
  fb.add_type_hash (0x20000000f671167cULL, 0xdfc42ce42beb58f7ULL, 0x15afc969aae521d6ULL, 0xadbec8ab9522f6f8ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // command
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
class _EventDispatcher_InterfaceTests__UIWidgetArea_void_signal_void : public Plic::EventDispatcher {
  PyObject *m_callable;
public:
  ~_EventDispatcher_InterfaceTests__UIWidgetArea_void_signal_void() { Py_DECREF (m_callable); }
  _EventDispatcher_InterfaceTests__UIWidgetArea_void_signal_void (PyObject *callable) : m_callable ((Py_INCREF (callable), callable)) {}
  virtual FieldBuffer*
  dispatch_event (Plic::Coupler &cpl)
  {
    // uint64 msgid = frr.pop_int64();
    // assert (Plic::is_msgid_event (msgid));
    // uint handler_id = uint (frr.pop_int64());
    const uint length = 0;
    PyObject *result, *tuple = PyTuple_New (length);
    if (PyErr_Occurred()) goto error;
    result = PyObject_Call (m_callable, tuple, NULL);
    Py_XDECREF (result);
   error:
    Py_XDECREF (tuple);
    return NULL;
  }
};
static PyObject*
_plic_marshal__InterfaceTests__UIWidgetArea_void_signal_void (PyObject *pyself, PyObject *pyargs)
{
  Plic::Coupler &cpl = PLIC_COUPLER();
  PyObject *item, *pyfoR = NULL;
  FieldBuffer *fm = FieldBuffer::_new (4 + 1 + 2), &fb = *fm, *fr = NULL;
  fb.add_type_hash (0x50000000257c7180ULL, 0xfac77ebb19c6ab72ULL, 0xb34dd194f62b665dULL, 0x0c329a03aebf472bULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1);  // Closure
  if (item == Py_None) fb.add_int64 (0);
  else {
    if (!PyCallable_Check (item)) ERRORpy ("arg2 must be callable");
    std::auto_ptr<Plic::EventDispatcher> ap (new _EventDispatcher_InterfaceTests__UIWidgetArea_void_signal_void (item));
    uint64 handler_id = cpl.dispatcher_add (ap);
    fb.add_int64 (handler_id); }
  item = PyTuple_GET_ITEM (pyargs, 2);  // ConId for disconnect
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = cpl.call_remote (&fb); fm = NULL; // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
      pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
  }
 error:
  if (fm) delete fm;
  if (fr) delete fr;
  return pyfoR;
}
class _EventDispatcher_InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int : public Plic::EventDispatcher {
  PyObject *m_callable;
public:
  ~_EventDispatcher_InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int() { Py_DECREF (m_callable); }
  _EventDispatcher_InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int (PyObject *callable) : m_callable ((Py_INCREF (callable), callable)) {}
  virtual FieldBuffer*
  dispatch_event (Plic::Coupler &cpl)
  {
    FieldBufferReader &fbr = cpl.reader;
    // uint64 msgid = frr.pop_int64();
    // assert (Plic::is_msgid_event (msgid));
    // uint handler_id = uint (frr.pop_int64());
    const uint length = 2;
    PyObject *result, *tuple = PyTuple_New (length), *item;
    item = PyLong_FromUnsignedLongLong (fbr.pop_object()); ERRORifpy();
    PyTuple_SET_ITEM (tuple, 0, item);
    item = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
    PyTuple_SET_ITEM (tuple, 1, item);
    if (PyErr_Occurred()) goto error;
    result = PyObject_Call (m_callable, tuple, NULL);
    Py_XDECREF (result);
   error:
    Py_XDECREF (tuple);
    return NULL;
  }
};
static PyObject*
_plic_marshal__InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int (PyObject *pyself, PyObject *pyargs)
{
  Plic::Coupler &cpl = PLIC_COUPLER();
  PyObject *item, *pyfoR = NULL;
  FieldBuffer *fm = FieldBuffer::_new (4 + 1 + 2), &fb = *fm, *fr = NULL;
  fb.add_type_hash (0x50000000a31a6e24ULL, 0xfe2020b5b9671356ULL, 0x11e8a29ccb87db27ULL, 0xcbe662a2887ef78fULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1);  // Closure
  if (item == Py_None) fb.add_int64 (0);
  else {
    if (!PyCallable_Check (item)) ERRORpy ("arg2 must be callable");
    std::auto_ptr<Plic::EventDispatcher> ap (new _EventDispatcher_InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int (item));
    uint64 handler_id = cpl.dispatcher_add (ap);
    fb.add_int64 (handler_id); }
  item = PyTuple_GET_ITEM (pyargs, 2);  // ConId for disconnect
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = cpl.call_remote (&fb); fm = NULL; // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
      pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
  }
 error:
  if (fm) delete fm;
  if (fr) delete fr;
  return pyfoR;
}
static PyObject*
_plic_rpc_InterfaceTests__QuickIface_simple_function_void_int (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 1), *fr = NULL;
  fb.add_type_hash (0x20000000be855008ULL, 0x6bf2269ff6939544ULL, 0x6a0846e9f5a62da8ULL, 0x59c8e2a4e4629e80ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // i
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_void_void (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 0), *fr = NULL;
  fb.add_type_hash (0x20000000a426153aULL, 0x0a2f5758267a2651ULL, 0xd9bff16cf6755833ULL, 0x8959ddaf9e5b8a44ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_bools_bool_bool_bool (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x300000003917295eULL, 0x76cb59d18d695319ULL, 0x0fe6acdaa38d48dfULL, 0xa26ca0854c18e565ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_ints_int_int_int (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x3000000015f688dcULL, 0x4db9c06f4357aa4eULL, 0x902ee7647790de7cULL, 0x18aa217be2c83cbaULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_floats_float_float_float (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x30000000bfc2d47bULL, 0x70b13d1cdf2c9488ULL, 0x77c2ea3ad44c2625ULL, 0xd6093e05e70ea643ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyFloat_FromDouble (frr.pop_double()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_string_string_string_string (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x300000002732b2feULL, 0x6dfd49db44b97641ULL, 0x010dcacac6eb8ed7ULL, 0xa79383e035fc64e1ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyString_From_std_string (frr.pop_string()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_enum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x300000003f676d86ULL, 0x903cbdda7f9bf8e6ULL, 0xb56b87771cbd4b69ULL, 0x5723ee9d219ddda5ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyLong_FromLongLong (frr.pop_evalue()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_record_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x3000000004a0b014ULL, 0x7eef09335a6cd6afULL, 0xd80237b6e1df12f6ULL, 0x70618be70ed6e858ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  if (!plic_pyQuickRecord_proto_add (item, fb)) goto error;
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  if (!plic_pyQuickRecord_proto_add (item, fb)) goto error;
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = plic_pyQuickRecord_proto_pop (frr); ERRORif (!pyfoR);
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_sequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x30000000e92eb1f1ULL, 0xbc6d5e758278964aULL, 0xe88f958f88ca346cULL, 0xf29e446630c57f23ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  if (!plic_pyQuickSequence_proto_add (item, fb)) goto error;
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  if (!plic_pyQuickSequence_proto_add (item, fb)) goto error;
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = plic_pyQuickSequence_proto_pop (frr); ERRORif (!pyfoR);
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_interface_InterfaceTests__GrandChild_InterfaceTests__GrandChild_InterfaceTests__GrandChild (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x3000000001640ae0ULL, 0xf5403244c684c076ULL, 0x208c721dda088467ULL, 0x425f3425b0dcfad4ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // optval
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyLong_FromUnsignedLongLong (frr.pop_object()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
_plic_rpc_InterfaceTests__MethodTestInterface_method_with_quickiface_InterfaceTests__QuickIface_InterfaceTests__QuickIface_InterfaceTests__QuickIface (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 2), *fr = NULL;
  fb.add_type_hash (0x3000000082dc142eULL, 0x7d16cadebfca9b39ULL, 0x168d05eb3cf56adbULL, 0x31e28c41cf8bb4f9ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // input
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // iface0
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyLong_FromUnsignedLongLong (frr.pop_object()); ERRORifpy();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
class _EventDispatcher_RapicornPlicTest__ButtonArea_check_activate_bool : public Plic::EventDispatcher {
  PyObject *m_callable;
public:
  ~_EventDispatcher_RapicornPlicTest__ButtonArea_check_activate_bool() { Py_DECREF (m_callable); }
  _EventDispatcher_RapicornPlicTest__ButtonArea_check_activate_bool (PyObject *callable) : m_callable ((Py_INCREF (callable), callable)) {}
  virtual FieldBuffer*
  dispatch_event (Plic::Coupler &cpl)
  {
    // uint64 msgid = frr.pop_int64();
    // assert (Plic::is_msgid_event (msgid));
    // uint handler_id = uint (frr.pop_int64());
    const uint length = 0;
    PyObject *result, *tuple = PyTuple_New (length);
    if (PyErr_Occurred()) goto error;
    result = PyObject_Call (m_callable, tuple, NULL);
    Py_XDECREF (result);
   error:
    Py_XDECREF (tuple);
    return NULL;
  }
};
static PyObject*
_plic_marshal__RapicornPlicTest__ButtonArea_check_activate_bool (PyObject *pyself, PyObject *pyargs)
{
  Plic::Coupler &cpl = PLIC_COUPLER();
  PyObject *item, *pyfoR = NULL;
  FieldBuffer *fm = FieldBuffer::_new (4 + 1 + 2), &fb = *fm, *fr = NULL;
  fb.add_type_hash (0x500000002002b254ULL, 0x237b6d00631699f2ULL, 0xaa4a2bf137175f39ULL, 0x16724232857b7195ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1);  // Closure
  if (item == Py_None) fb.add_int64 (0);
  else {
    if (!PyCallable_Check (item)) ERRORpy ("arg2 must be callable");
    std::auto_ptr<Plic::EventDispatcher> ap (new _EventDispatcher_RapicornPlicTest__ButtonArea_check_activate_bool (item));
    uint64 handler_id = cpl.dispatcher_add (ap);
    fb.add_int64 (handler_id); }
  item = PyTuple_GET_ITEM (pyargs, 2);  // ConId for disconnect
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = cpl.call_remote (&fb); fm = NULL; // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
      pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
  }
 error:
  if (fm) delete fm;
  if (fr) delete fr;
  return pyfoR;
}
class _EventDispatcher_RapicornPlicTest__ButtonArea_activate_void : public Plic::EventDispatcher {
  PyObject *m_callable;
public:
  ~_EventDispatcher_RapicornPlicTest__ButtonArea_activate_void() { Py_DECREF (m_callable); }
  _EventDispatcher_RapicornPlicTest__ButtonArea_activate_void (PyObject *callable) : m_callable ((Py_INCREF (callable), callable)) {}
  virtual FieldBuffer*
  dispatch_event (Plic::Coupler &cpl)
  {
    // uint64 msgid = frr.pop_int64();
    // assert (Plic::is_msgid_event (msgid));
    // uint handler_id = uint (frr.pop_int64());
    const uint length = 0;
    PyObject *result, *tuple = PyTuple_New (length);
    if (PyErr_Occurred()) goto error;
    result = PyObject_Call (m_callable, tuple, NULL);
    Py_XDECREF (result);
   error:
    Py_XDECREF (tuple);
    return NULL;
  }
};
static PyObject*
_plic_marshal__RapicornPlicTest__ButtonArea_activate_void (PyObject *pyself, PyObject *pyargs)
{
  Plic::Coupler &cpl = PLIC_COUPLER();
  PyObject *item, *pyfoR = NULL;
  FieldBuffer *fm = FieldBuffer::_new (4 + 1 + 2), &fb = *fm, *fr = NULL;
  fb.add_type_hash (0x500000001eea842bULL, 0xdb7ee9164c9f8a60ULL, 0x1d0b0a314944036aULL, 0xfc73ff4aec88f8ffULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 2) ERRORpy ("wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1);  // Closure
  if (item == Py_None) fb.add_int64 (0);
  else {
    if (!PyCallable_Check (item)) ERRORpy ("arg2 must be callable");
    std::auto_ptr<Plic::EventDispatcher> ap (new _EventDispatcher_RapicornPlicTest__ButtonArea_activate_void (item));
    uint64 handler_id = cpl.dispatcher_add (ap);
    fb.add_int64 (handler_id); }
  item = PyTuple_GET_ITEM (pyargs, 2);  // ConId for disconnect
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = cpl.call_remote (&fb); fm = NULL; // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
      pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
  }
 error:
  if (fm) delete fm;
  if (fr) delete fr;
  return pyfoR;
}
static PyObject*
_plic_rpc_RapicornPlicTest__PureMethods_pure_method_int_float (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (4 + 1 + 1), *fr = NULL;
  fb.add_type_hash (0x30000000e96382b8ULL, 0x8c16fe069c1d6b1eULL, 0x002e82b90c7db308ULL, 0x9c8a9e5a95b6ea99ULL); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 0);  // self
  fb.add_object (PyAttr_As_uint64 (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 1); // f
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = PLIC_COUPLER().call_remote (&fb); // deletes fb
  ERRORifnotret (fr);
  if (fr) {
    Plic::FieldBufferReader frr (*fr);
    frr.skip(); // proc_id for return
    if (frr.remaining() == 1) {
        pyfoR = PyLong_FromLongLong (frr.pop_int64()); ERRORifpy ();
    }
    delete fr; fr = NULL;
  }
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
#define PLIC_PYSTUB_METHOD_DEFS() \
  { "_PLIC_MandatoryNamespace__FirstInterface_void_func_void", _plic_rpc_MandatoryNamespace__FirstInterface_void_func_void, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_simple_method_float", _plic_rpc_InterfaceTests__UIWidgetArea_simple_method_float, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_single_arg_float_int", _plic_rpc_InterfaceTests__UIWidgetArea_single_arg_float_int, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_single_arg2_float_int", _plic_rpc_InterfaceTests__UIWidgetArea_single_arg2_float_int, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_two_args_float_int_float", _plic_rpc_InterfaceTests__UIWidgetArea_two_args_float_int_float, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_two_args2_float_int_float", _plic_rpc_InterfaceTests__UIWidgetArea_two_args2_float_int_float, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_multi_args_float_int_float_int_string_float", _plic_rpc_InterfaceTests__UIWidgetArea_multi_args_float_int_float_int_string_float, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_self_method_float_InterfaceTests__UIWidgetArea_InterfaceTests__UIWidgetArea", _plic_rpc_InterfaceTests__UIWidgetArea_self_method_float_InterfaceTests__UIWidgetArea_InterfaceTests__UIWidgetArea, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_void_method_void", _plic_rpc_InterfaceTests__UIWidgetArea_void_method_void, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_on_click2out_string", _plic_rpc_InterfaceTests__UIWidgetArea_on_click2out_string, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_on_click2in_void_string", _plic_rpc_InterfaceTests__UIWidgetArea_on_click2in_void_string, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_void_signal_void", _plic_marshal__InterfaceTests__UIWidgetArea_void_signal_void, METH_VARARGS, "pyRapicorn signal call" },\
  { "_PLIC_InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int", _plic_marshal__InterfaceTests__UIWidgetArea_sample_signal_float_InterfaceTests__UIWidgetArea_int, METH_VARARGS, "pyRapicorn signal call" },\
  { "_PLIC_InterfaceTests__QuickIface_simple_function_void_int", _plic_rpc_InterfaceTests__QuickIface_simple_function_void_int, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_void_void", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_void_void, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_bools_bool_bool_bool", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_bools_bool_bool_bool, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_ints_int_int_int", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_ints_int_int_int, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_floats_float_float_float", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_floats_float_float_float, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_string_string_string_string", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_string_string_string_string, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_enum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_enum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum_InterfaceTests__QuickEnum, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_record_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_record_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord_InterfaceTests__QuickRecord, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_sequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_sequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence_InterfaceTests__QuickSequence, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_interface_InterfaceTests__GrandChild_InterfaceTests__GrandChild_InterfaceTests__GrandChild", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_interface_InterfaceTests__GrandChild_InterfaceTests__GrandChild_InterfaceTests__GrandChild, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_InterfaceTests__MethodTestInterface_method_with_quickiface_InterfaceTests__QuickIface_InterfaceTests__QuickIface_InterfaceTests__QuickIface", _plic_rpc_InterfaceTests__MethodTestInterface_method_with_quickiface_InterfaceTests__QuickIface_InterfaceTests__QuickIface_InterfaceTests__QuickIface, METH_VARARGS, "pyRapicorn rpc call" },\
  { "_PLIC_RapicornPlicTest__ButtonArea_check_activate_bool", _plic_marshal__RapicornPlicTest__ButtonArea_check_activate_bool, METH_VARARGS, "pyRapicorn signal call" },\
  { "_PLIC_RapicornPlicTest__ButtonArea_activate_void", _plic_marshal__RapicornPlicTest__ButtonArea_activate_void, METH_VARARGS, "pyRapicorn signal call" },\
  { "_PLIC_RapicornPlicTest__PureMethods_pure_method_int_float", _plic_rpc_RapicornPlicTest__PureMethods_pure_method_int_float, METH_VARARGS, "pyRapicorn rpc call" }
static PLIC_UNUSED PyMethodDef dummy[] = { PLIC_PYSTUB_METHOD_DEFS(), { 0 } };
