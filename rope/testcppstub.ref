/* --- Generated by Rapicorn-CppStub --- */

#include <core/rapicornsignal.hh>
#include <string>
#include <vector>

class ProtoRecord;
class ProtoSequence;
class ProtoArg;
class ProtoMessage;

// FIXME:
#include "protocol-pb2.hh"
typedef Rapicorn::Rope::RemoteProcedure RemoteProcedure;
typedef Rapicorn::Rope::RemoteProcedure_Sequence RemoteProcedure_Sequence;
typedef Rapicorn::Rope::RemoteProcedure_Record RemoteProcedure_Record;
typedef Rapicorn::Rope::RemoteProcedure_Argument RemoteProcedure_Argument;
static inline RemoteProcedure_Record& RPRecordCast (ProtoRecord &r) {
  return *(RemoteProcedure_Record*) &r;
}
static inline const RemoteProcedure_Record& RPRecordCast (const ProtoRecord &r) {
  return *(const RemoteProcedure_Record*) &r;
}
static inline ProtoRecord& ProtoRecordCast (RemoteProcedure_Record &r) {
  return *(ProtoRecord*) &r;
}
static inline const ProtoRecord& ProtoRecordCast (const RemoteProcedure_Record &r) {
  return *(const ProtoRecord*) &r;
}
static inline RemoteProcedure_Sequence& RPSequenceCast (ProtoSequence &r) {
  return *(RemoteProcedure_Sequence*) &r;
}
static inline const RemoteProcedure_Sequence& RPSequenceCast (const ProtoSequence &r) {
  return *(const RemoteProcedure_Sequence*) &r;
}
static inline ProtoSequence& ProtoSequenceCast (RemoteProcedure_Sequence &r) {
  return *(ProtoSequence*) &r;
}
static inline const ProtoSequence& ProtoSequenceCast (const RemoteProcedure_Sequence &r) {
  return *(const ProtoSequence*) &r;
}
template<class CLASS> static inline std::string Instance2StringCast (const CLASS &obj) {
  return ""; // FIXME
}
template<class CLASS> static inline CLASS* Instance4StringCast (const std::string &objstring) {
  return NULL; // FIXME
}
#define die()      (void) 0 // FIXME

// Base classes...


// --- Skeletons ---
enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
struct XFooRecord {
  bool            single_bool;
  int             single_num;
  double          single_float;
  std::string     single_string;
  int             sibling1;
  int             sibling2;
  int             multi1;
  int             multi2;
  int             multi3;
  int             multi4;
  ExtensiveEnum   enum_field;
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline XFooRecord () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
struct XFooSequence {
  std::vector<bool> single_bool;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct IntSequence {
  std::vector<int> numx;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct FloatSequence {
  std::vector<double> fractalvalue;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct StringSequence {
  std::vector<std::string> blurb;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct ExtensiveEnumSequence {
  std::vector<ExtensiveEnum> enum_elements;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct RecordSequence {
  std::vector<XFooRecord> repeatedfield;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct SequenceSequence {
  std::vector<IntSequence> moreints;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct NestedTypesRec {
  XFooRecord      rec;
  XFooSequence    seq;
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline NestedTypesRec () { }
};
struct NestedTypesSeq {
  std::vector<NestedTypesRec> ntr;
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
typedef int AliasInt;
typedef double AliasFloat;
typedef bool AliasBool;
typedef std::string AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;
struct NewRecord {
  int             i;
  Enum1           enum1;
  XFooSequence    xfs;
  NestedTypesRec  ntr;
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline NewRecord () { i = 0; enum1 = Enum1 (0); }
};
struct InnerRecord {
  int             x;
  int             y;
  NewRecord       rec;
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline InnerRecord () { x = 0; y = 0; }
};
struct Refer2Inner {
  InnerRecord     r;
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline Refer2Inner () { }
};
struct SomeRecord {
  NewRecord       r1;
  NewRecord       r2;
  InnerRecord     r3;
  InnerRecord     r4;
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline SomeRecord () { }
};
typedef int bar;
typedef double x;
typedef std::string s;

class UIWidgetArea {
public:
  typedef Rapicorn::Signals::Signal<UIWidgetArea, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<UIWidgetArea, double (UIWidgetArea &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  double          simple_method ();
  double          single_arg (int n);
  double          single_arg2 (int n);
  double          two_args (int n,
                            double r);
  double          two_args2 (int n,
                             double r);
  double          multi_args (int n,
                              double r,
                              int i,
                              std::string s,
                              double y);
  double          self_method (UIWidgetArea &ba1,
                               UIWidgetArea &ba2);
  void            void_method ();
  std::string     on_click2out ();
  void            on_click2in (std::string command);
};

class Parent {
public:
};

class Child : public Parent {
public:
};

class Descendant : public Child {
public:
};

class GrandChild : public Descendant {
public:
};

class SomeInterface {
public:
  void            use_record (SomeRecord rr);
};
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class ButtonArea {
public:
  typedef Rapicorn::Signals::Signal<ButtonArea, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<ButtonArea, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};

// --- Stubs ---
bool XFooRecord::to_proto (ProtoRecord &dst) const {
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (single_bool);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (single_num);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::FLOAT);
  field->set_vdouble (single_float);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::STRING);
  field->set_vstring (single_string);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (sibling1);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (sibling2);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (multi1);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (multi2);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (multi3);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (multi4);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::ENUM);
  field->set_vint64 (enum_field);
  return true;
}
bool XFooRecord::from_proto (const ProtoRecord &src) {
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 11) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  single_bool = field->vint64();
  field = &rpr.fields (1);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  single_num = field->vint64();
  field = &rpr.fields (2);
  if (field->type() != RemoteProcedure::FLOAT) return false;
  if (!field->has_vdouble()) return false;  single_float = field->vdouble();
  field = &rpr.fields (3);
  if (field->type() != RemoteProcedure::STRING) return false;
  if (!field->has_vstring()) return false;  single_string = field->vstring();
  field = &rpr.fields (4);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  sibling1 = field->vint64();
  field = &rpr.fields (5);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  sibling2 = field->vint64();
  field = &rpr.fields (6);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  multi1 = field->vint64();
  field = &rpr.fields (7);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  multi2 = field->vint64();
  field = &rpr.fields (8);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  multi3 = field->vint64();
  field = &rpr.fields (9);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  multi4 = field->vint64();
  field = &rpr.fields (10);
  if (field->type() != RemoteProcedure::ENUM) return false;
  if (!field->has_vint64()) return false;  enum_field = ExtensiveEnum (field->vint64());
  return true;
}

bool XFooSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = single_bool.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vint64 (single_bool[k]);
  }
  return true;
}
bool XFooSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vint64_size();
  for (size_t k = 0; k < len; k++) {
    single_bool.push_back (rps.vint64 (k));
  }
  return true;
}

bool IntSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = numx.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vint64 (numx[k]);
  }
  return true;
}
bool IntSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vint64_size();
  for (size_t k = 0; k < len; k++) {
    numx.push_back (rps.vint64 (k));
  }
  return true;
}

bool FloatSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = fractalvalue.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vdouble (fractalvalue[k]);
  }
  return true;
}
bool FloatSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vdouble_size();
  for (size_t k = 0; k < len; k++) {
    fractalvalue.push_back (rps.vdouble (k));
  }
  return true;
}

bool StringSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = blurb.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vstring (blurb[k]);
  }
  return true;
}
bool StringSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vstring_size();
  for (size_t k = 0; k < len; k++) {
    blurb.push_back (rps.vstring (k));
  }
  return true;
}

bool ExtensiveEnumSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = enum_elements.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vint64 (enum_elements[k]);
  }
  return true;
}
bool ExtensiveEnumSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vint64_size();
  for (size_t k = 0; k < len; k++) {
    enum_elements.push_back (ExtensiveEnum (rps.vint64 (k)));
  }
  return true;
}

bool RecordSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = repeatedfield.size();
  for (size_t k = 0; k < len; k++) {
    if (!repeatedfield[k].to_proto (ProtoRecordCast (*rps.add_vrec()))) return false;
  }
  return true;
}
bool RecordSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vrec_size();
  repeatedfield.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!repeatedfield[k].from_proto (ProtoRecordCast (rps.vrec (k)))) return false;
  }
  return true;
}

bool SequenceSequence::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = moreints.size();
  for (size_t k = 0; k < len; k++) {
    if (!moreints[k].to_proto (ProtoSequenceCast (*rps.add_vseq()))) return false;
  }
  return true;
}
bool SequenceSequence::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vseq_size();
  moreints.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!moreints[k].from_proto (ProtoSequenceCast (rps.vseq (k)))) return false;
  }
  return true;
}

bool NestedTypesRec::to_proto (ProtoRecord &dst) const {
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!rec.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::SEQUENCE);
  if (!seq.to_proto (ProtoSequenceCast (*field->mutable_vseq()))) return false;
  return true;
}
bool NestedTypesRec::from_proto (const ProtoRecord &src) {
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 2) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !rec.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (1);
  if (field->type() != RemoteProcedure::SEQUENCE) return false;
  if (!field->has_vseq() || !seq.from_proto (ProtoSequenceCast (field->vseq()))) return false;
  return true;
}

bool NestedTypesSeq::to_proto (ProtoSequence &dst) const {
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = ntr.size();
  for (size_t k = 0; k < len; k++) {
    if (!ntr[k].to_proto (ProtoRecordCast (*rps.add_vrec()))) return false;
  }
  return true;
}
bool NestedTypesSeq::from_proto (const ProtoSequence &src) {
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vrec_size();
  ntr.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!ntr[k].from_proto (ProtoRecordCast (rps.vrec (k)))) return false;
  }
  return true;
}

bool NewRecord::to_proto (ProtoRecord &dst) const {
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (i);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::ENUM);
  field->set_vint64 (enum1);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::SEQUENCE);
  if (!xfs.to_proto (ProtoSequenceCast (*field->mutable_vseq()))) return false;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!ntr.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool NewRecord::from_proto (const ProtoRecord &src) {
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 4) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  i = field->vint64();
  field = &rpr.fields (1);
  if (field->type() != RemoteProcedure::ENUM) return false;
  if (!field->has_vint64()) return false;  enum1 = Enum1 (field->vint64());
  field = &rpr.fields (2);
  if (field->type() != RemoteProcedure::SEQUENCE) return false;
  if (!field->has_vseq() || !xfs.from_proto (ProtoSequenceCast (field->vseq()))) return false;
  field = &rpr.fields (3);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !ntr.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

bool InnerRecord::to_proto (ProtoRecord &dst) const {
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (x);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::INT);
  field->set_vint64 (y);
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!rec.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool InnerRecord::from_proto (const ProtoRecord &src) {
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 3) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  x = field->vint64();
  field = &rpr.fields (1);
  if (field->type() != RemoteProcedure::INT) return false;
  if (!field->has_vint64()) return false;  y = field->vint64();
  field = &rpr.fields (2);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !rec.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

bool Refer2Inner::to_proto (ProtoRecord &dst) const {
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!r.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool Refer2Inner::from_proto (const ProtoRecord &src) {
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 1) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !r.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

bool SomeRecord::to_proto (ProtoRecord &dst) const {
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!r1.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!r2.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!r3.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  field->set_type (RemoteProcedure::RECORD);
  if (!r4.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool SomeRecord::from_proto (const ProtoRecord &src) {
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 4) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !r1.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (1);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !r2.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (2);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !r3.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (3);
  if (field->type() != RemoteProcedure::RECORD) return false;
  if (!field->has_vrec() || !r4.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

double UIWidgetArea::simple_method () {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0001);
  return 0; // FIXME
}
double UIWidgetArea::single_arg (int n) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0002);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INT);
  arg->set_vint64 (n);
  return 0; // FIXME
}
double UIWidgetArea::single_arg2 (int n) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0003);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INT);
  arg->set_vint64 (n);
  return 0; // FIXME
}
double UIWidgetArea::two_args (int n,
                               double r) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0004);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INT);
  arg->set_vint64 (n);
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::FLOAT);
  arg->set_vdouble (r);
  return 0; // FIXME
}
double UIWidgetArea::two_args2 (int n,
                                double r) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0005);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INT);
  arg->set_vint64 (n);
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::FLOAT);
  arg->set_vdouble (r);
  return 0; // FIXME
}
double UIWidgetArea::multi_args (int n,
                                 double r,
                                 int i,
                                 std::string s,
                                 double y) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0006);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INT);
  arg->set_vint64 (n);
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::FLOAT);
  arg->set_vdouble (r);
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INT);
  arg->set_vint64 (i);
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::STRING);
  arg->set_vstring (s);
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::FLOAT);
  arg->set_vdouble (y);
  return 0; // FIXME
}
double UIWidgetArea::self_method (UIWidgetArea &ba1,
                                  UIWidgetArea &ba2) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0007);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INTERFACE);
  arg->set_vstring (Instance2StringCast (ba1));
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::INTERFACE);
  arg->set_vstring (Instance2StringCast (ba2));
  return 0; // FIXME
}
void UIWidgetArea::void_method () {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0008);
}
std::string UIWidgetArea::on_click2out () {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def0009);
  return 0; // FIXME
}
void UIWidgetArea::on_click2in (std::string command) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def000a);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::STRING);
  arg->set_vstring (command);
}

static bool handle_UIWidgetArea_simple_method (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  if (_rope_rp.args_size() != 0) return false;
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_single_arg (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  int n;
  if (_rope_rp.args_size() != 1) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::INT) return false;
  if (!_rope_arg->has_vint64()) return false;  n = _rope_arg->vint64();
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_single_arg2 (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  int n;
  if (_rope_rp.args_size() != 1) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::INT) return false;
  if (!_rope_arg->has_vint64()) return false;  n = _rope_arg->vint64();
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_two_args (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  int n;
  double r;
  if (_rope_rp.args_size() != 2) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::INT) return false;
  if (!_rope_arg->has_vint64()) return false;  n = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (1);
  if (_rope_arg->type() != RemoteProcedure::FLOAT) return false;
  if (!_rope_arg->has_vdouble()) return false;  r = _rope_arg->vdouble();
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_two_args2 (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  int n;
  double r;
  if (_rope_rp.args_size() != 2) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::INT) return false;
  if (!_rope_arg->has_vint64()) return false;  n = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (1);
  if (_rope_arg->type() != RemoteProcedure::FLOAT) return false;
  if (!_rope_arg->has_vdouble()) return false;  r = _rope_arg->vdouble();
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_multi_args (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  int n;
  double r;
  int i;
  std::string s;
  double y;
  if (_rope_rp.args_size() != 5) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::INT) return false;
  if (!_rope_arg->has_vint64()) return false;  n = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (1);
  if (_rope_arg->type() != RemoteProcedure::FLOAT) return false;
  if (!_rope_arg->has_vdouble()) return false;  r = _rope_arg->vdouble();
  _rope_arg = &_rope_rp.args (2);
  if (_rope_arg->type() != RemoteProcedure::INT) return false;
  if (!_rope_arg->has_vint64()) return false;  i = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (3);
  if (_rope_arg->type() != RemoteProcedure::STRING) return false;
  if (!_rope_arg->has_vstring()) return false;  s = _rope_arg->vstring();
  _rope_arg = &_rope_rp.args (4);
  if (_rope_arg->type() != RemoteProcedure::FLOAT) return false;
  if (!_rope_arg->has_vdouble()) return false;  y = _rope_arg->vdouble();
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_self_method (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  UIWidgetArea *ba1;
  UIWidgetArea *ba2;
  if (_rope_rp.args_size() != 2) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::INTERFACE) return false;
  if (!_rope_arg->has_vstring()) return false;  ba1 = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  _rope_arg = &_rope_rp.args (1);
  if (_rope_arg->type() != RemoteProcedure::INTERFACE) return false;
  if (!_rope_arg->has_vstring()) return false;  ba2 = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_void_method (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  if (_rope_rp.args_size() != 0) return false;
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_on_click2out (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  if (_rope_rp.args_size() != 0) return false;
  (void) _rope_aret;
  return true;
}
static bool handle_UIWidgetArea_on_click2in (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  std::string command;
  if (_rope_rp.args_size() != 1) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::STRING) return false;
  if (!_rope_arg->has_vstring()) return false;  command = _rope_arg->vstring();
  (void) _rope_aret;
  return true;
}









void SomeInterface::use_record (SomeRecord rr) {
  RemoteProcedure rp;
  rp.set_proc_id (0x0def000b);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_type (RemoteProcedure::RECORD);
  if (!rr.to_proto (ProtoRecordCast (*arg->mutable_vrec()))) die();
}

static bool handle_SomeInterface_use_record (const RemoteProcedure &_rope_rp,
                          RemoteProcedure_Argument *_rope_aret) {
  SomeRecord rr;
  if (_rope_rp.args_size() != 1) return false;
  const RemoteProcedure_Argument *_rope_arg;
  _rope_arg = &_rope_rp.args (0);
  if (_rope_arg->type() != RemoteProcedure::RECORD) return false;
  if (!_rope_arg->has_vrec() || !rr.from_proto (ProtoRecordCast (_rope_arg->vrec()))) return false;
  (void) _rope_aret;
  return true;
}



bool rope_callee_handler () {
  const RemoteProcedure _rope_rp;
  RemoteProcedure_Argument _rope_aretmem, *_rope_aret = &_rope_aretmem;
  switch (_rope_rp.proc_id()) {
  case 0x0def0001: // UIWidgetArea::simple_method
    return handle_UIWidgetArea_simple_method (_rope_rp, _rope_aret);
  case 0x0def0002: // UIWidgetArea::single_arg
    return handle_UIWidgetArea_single_arg (_rope_rp, _rope_aret);
  case 0x0def0003: // UIWidgetArea::single_arg2
    return handle_UIWidgetArea_single_arg2 (_rope_rp, _rope_aret);
  case 0x0def0004: // UIWidgetArea::two_args
    return handle_UIWidgetArea_two_args (_rope_rp, _rope_aret);
  case 0x0def0005: // UIWidgetArea::two_args2
    return handle_UIWidgetArea_two_args2 (_rope_rp, _rope_aret);
  case 0x0def0006: // UIWidgetArea::multi_args
    return handle_UIWidgetArea_multi_args (_rope_rp, _rope_aret);
  case 0x0def0007: // UIWidgetArea::self_method
    return handle_UIWidgetArea_self_method (_rope_rp, _rope_aret);
  case 0x0def0008: // UIWidgetArea::void_method
    return handle_UIWidgetArea_void_method (_rope_rp, _rope_aret);
  case 0x0def0009: // UIWidgetArea::on_click2out
    return handle_UIWidgetArea_on_click2out (_rope_rp, _rope_aret);
  case 0x0def000a: // UIWidgetArea::on_click2in
    return handle_UIWidgetArea_on_click2in (_rope_rp, _rope_aret);
  case 0x0def000b: // SomeInterface::use_record
    return handle_SomeInterface_use_record (_rope_rp, _rope_aret);
  default:
    die();
  }
  return false;
}

