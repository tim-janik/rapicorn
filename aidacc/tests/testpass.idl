/* IDL test file					 	-*-mode:c++;-*-
 *
 * This work is provided "as is"; redistribution and modification
 * in whole or in part, in any medium, physical or electronic is
 * permitted without restriction.
 *
 * This work is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * In no event shall the authors or contributors be liable for any
 * direct, indirect, incidental, special, exemplary, or consequential
 * damages (including, but not limited to, procurement of substitute
 * goods or services; loss of use, data, or profits; or business
 * interruption) however caused and on any theory of liability, whether
 * in contract, strict liability, or tort (including negligence or
 * otherwise) arising in any way out of the use of this software, even
 * if advised of the possibility of such damage.
 */

// single line comment

/* multi line comment on single line */

/* multi line comment with embedded single line slashes //
// still in multi line comment
// */

;;;;;;;	// multi semicolon test

namespace EmptyNamespace1 { }

namespace EmptyNamespace2 {
;;;;;;;	// multi semicolon in namespace test
}

namespace MandatoryNamespace {

// simple constant tests
Const S = "string";
Const S2 = "concatenated" "string";
Const A = 1 + 3 * 5 + 2 ** 3 % 11 + 1.5;	// 25.5
// reassignment: Const A = 1;
// invalid: Const TRUE = 17;
Const B = A**3;					// 16581.375
Const C = 5;
Const D = (5);
Const E = 5 * (3 + 4);                          // 35
Const F = 5 * 3 + 4;                            // 19
Const G = (5 * 3 + 4);                          // 19
Const Signs = +1 + -2 + - -3 - +-+-+-+-+- 4;    // 6
Const Pows = 1**1 - -1**1 + 1**-1 - -1**-1 - -(1 + 1)**-(1 + 1) + +1**+1;
Const Floats = 0 + 0. + .0 + 1. + 10. + .011 + 101. + 1.1e+1 + .1e+1 + 1e-1 + 1E+1 + 1E-1 + 1e+01 + 1e-02; // 144.221
Const Bools = TRUE + True + true + FALSE + False + false + 0 + 1; // 4
Const Vint = 42;

/* test that C++ style commments are properly ignored within strings */
Const CXX_COMMENT_TEST_1 = "Foo // bar";
Const CXX_COMMENT_TEST_2 = "Foo \" // bar";
Const CXX_COMMENT_TEST_3 = "Foo \\";//bar
Const CXX_COMMENT_TEST_4 = "Foo /**/ bar";
Const CXX_COMMENT_TEST_5 = "Foo /*//*/ bar";
Const CXX_COMMENT_TEST_6 = "Foo /* */ */ bar";
Const CXX_COMMENT_TEST_7 = "Foo /* /* /* bar";
Const CXX_COMMENT_TEST_8 = "Foo /* /* */ /* bar";
Const String1 = "1";
Const String2 = "2";
Const String3 = "first" "+" "second";
Const String4 = "" String1 "+" String2;
Const Vistring = _("foo");
// Const tmp = "" Vistring "error: i18n string concatenation";
Const Vstring = "foo";

// enumerations
// enumeration Empty  { };
enumeration Enum1  { E1_A };
enumeration Enum1c { E1C_A, };
enumeration Enum2  { E2_A,  E2_B };
enumeration Enum2c { E2C_A, E2C_B, };
enumeration Enum3  { E3_A,  E3_B,  E3_C };
enumeration Enum3c { E3C_A, E3C_B, E3C_C, };
enumeration Enum4a { E4A_A, E4A_B, E4A_C, E4A_D  /**/ };
enumeration Enum4b { E4B_A, E4B_B, E4B_C, E4B_D, /**/ };
enumeration Enum4c { E4C_A, E4C_B, E4C_C, E4C_D  //
                       };
enumeration Enum4d { E4D_A, E4D_B, E4D_C, E4D_D, //
                       };

// enumeration arguments
enum ExtensiveEnum {
  V1a,  // 1
  V1b =  1,
  V2  = (2),
  V3  = (3,   "v3"),
  V4  = (4, _("v4")),
  V5  = (5,   "v5",    "V5"),
  V6  = (6, _("v6"),   "V6"),
  V7  = (7,   "v7",  _("V7")),
  V8  = (8, _("v8"), _("V8")),
  V9  = (((9))),
  /* check string expressions */
  V10 =    "v10",
  V11 =  _("v11"),
  V12 = (  "v12"),
  V13,
  V14 = (_("v14")),
  V15 = (  "v15",    "V15"),
  V16 = (_("v16"),   "V16"),
  V17 = (  "v17",  _("V17")),
  V18 = (_("v18"), _("V18")),
  /* check number parsing */
  V20 = 20,
  V21 = -(-20 - - + -1),
  V22 = 2 * 10 + 2,
  V23 = 2 * (5 + 5) + 3,
  V24 = 2 ** 4 + 8,
  V25 = -2 ** (2 + 2),
  V26 = +(2 ** (2 + 2)),
  V27 = -(2 ** (2 + 2)),
  V28 = - /*comment*/ (28),
  /* constants */
  V30 = Vint,
  V31 = Vstring,
  V32 = (Vint),
  V33 = (Vstring),
  V34 = (Vstring, Vstring),
  V35 = (Vint, Vstring),
  V36 = (Vint, Vstring, Vstring "4"),
};
// reassignment: Const V36 = 36;
Const enum_math = V36 + V34 + V24 + V13 + V3;

// simple interface
interface FirstInterface {
  void void_func ();
};

// record tests
record XFooRecord {
  bool   single_bool;
  int    single_num;
  float  single_float;
  string single_string;
  int    sibling1;
  int    sibling2;
  int    multi1;
  int    multi2;
  int    multi3;
  int    multi4;
  ExtensiveEnum enum_field;
  FirstInterface iface1;
  FirstInterface iface2;
  FirstInterface iface3;
  any    any1;
  any    any2;
  any    any3;
};

// sequence tests
sequence XFooSequence {
  bool   single_bool;
};
sequence IntSequence {
  int   numx;
};
sequence FloatSequence {
  float fractalvalue;
};
sequence StringSequence {
  string blurb;
};
sequence ExtensiveEnumSequence {
  ExtensiveEnum enum_elements;
};
sequence RecordSequence {
  XFooRecord repeatedfield;
};
sequence SequenceSequence {
  IntSequence moreints;
};
sequence InterfaceSequence {
  FirstInterface iface1;
};
sequence AnySequence {
  any any_value;
};

// test nested types
record NestedTypesRec {
  XFooRecord    rec;
  XFooSequence  seq;
};
sequence NestedTypesSeq {
  NestedTypesRec ntr;
};

// typedef tests
typedef any AliasAny;
typedef bool AliasBool;
typedef int  AliasInt;
typedef float AliasFloat;
typedef string AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;

} // MandatoryNamespace

// Test namespace continuation
namespace MandatoryNamespace {
record NewRecord {
  int            i;
  Enum1          enum1;
  XFooSequence   xfs;
  NestedTypesRec ntr;
};

// namespace nesting
namespace Inner {
record InnerRecord {
  int           x;
  int           y;
  NewRecord     rec;
};
} // Inner

record Refer2Inner {
  Inner::InnerRecord r;
};

} // MandatoryNamespace

// cross-namespace references
namespace OtherNamespace {
record SomeRecord {
  MandatoryNamespace::NewRecord            r1;
  ::MandatoryNamespace::NewRecord          r2;
  MandatoryNamespace::Inner::InnerRecord   r3;
  ::MandatoryNamespace::Inner::InnerRecord r4;
};
}

// references to outer namespaces
namespace Outer {
Const FromOuter = 3;
namespace Middle {
Const FromMiddle = 2;
namespace Inner {
Const FromInner = 1;
Const dummy = FromInner + FromMiddle + FromOuter;
} // Outer::Middle::Inner
} // Outer::Middle
} // Outer

// Auxdata tests
namespace Auxdata {
// FIXME: can't check auxdata of record fields yet
//record RecordWithAuxdata {
  typedef bool bfoo   = Bool   ("Bool Foo", "A Boolean", "rw");
  typedef int  ifoo   = Int    ("Int Foo", "The Bar number", "rw", 10007.000);
  typedef float ffoo  = Float  ("auxtest1", "X coordinate", "ro", 19e-3);
  typedef string sfoo = String ("auxtest2", "Specify text here", "rw", "auxtest3");
  /* auxtest1 and auxtest2 are explicit testing keywords */
//};
}

namespace InterfaceTests {
interface UIWidgetArea {
  bool  dummy;
  float simple_method ();
  float single_arg (int n);
  float single_arg2 (int n = 5);
  float two_args (int n, float r);
  float two_args2 (int n = 6, float r = 7.7);
  float multi_args (bool b, int n, float r, int i, string s = ("String ding"), float y = 5);
  float self_method (UIWidgetArea ba1, InterfaceTests::UIWidgetArea ba2);
  void void_method();
  /* sample property accessors: */
  string on_click2out ();
  void   on_click2in  (string command);
  /* property: */
  string on_click = String (_("On CLick"), _("Command on button1 click"), "rw");
  /* signals: */
  signal void void_signal ();
  signal float sample_signal (UIWidgetArea ba1, int someint);
  //bool check_activate (void) = signal (CollectUntil0);
  //void activate       (void);
};
interface Parent {};
interface Child : Parent {}; // interface inheritance
interface Descendant : Parent, Child {}; // multiple interface inheritance
interface GrandChild : Parent, Child, Descendant {}; // multiple interface inheritance

enum QuickEnum         { ZERO = 0, };
record   QuickRecord   { int   int1; int int2; };
sequence QuickSequence { float somefloat; };

interface QuickIface {
  void simple_function (int i = 9);
};

interface MethodTestInterface {
  void           method_with_void       ();
  bool           method_with_bools      (bool   input, bool   optval = FALSE);
  int            method_with_ints       (int    input, int    optval = -3 - -1);
  float          method_with_floats     (float  input, float  optval = 9.9 + 3.e+2);
  string         method_with_string     (string input, string optval = "default");
  QuickEnum      method_with_enum       (QuickEnum      input, QuickEnum     optval = ZERO);
  QuickRecord    method_with_record     (QuickRecord    input, QuickRecord   optval = 0);
  QuickSequence  method_with_sequence   (QuickSequence  input, QuickSequence optval = 0);
  GrandChild     method_with_interface  (GrandChild     input, GrandChild    optval = 0);
  any            method_with_anys       (any            input, any           optval);
  QuickIface     method_with_quickiface (QuickIface     input, QuickIface    iface0 = 0);
};

interface SignalTestInterface {
  signal void                void_result      ();
  signal bool                bool_result      ();
  signal int                 int_result       ();
  signal float               float_result     ();
  signal string              string_result    ();
  signal QuickEnum           enum_result      ();
  signal QuickRecord         record_result    ();
  signal QuickSequence       sequence_result  ();
  signal GrandChild          interface_result ();
  signal any                 any_result       ();
  signal SignalTestInterface self_result      ();
  signal void                void_arg         ();
  signal void                bool_arg         (bool b);
  signal void                int_arg          (int i);
  signal void                float_arg        (float f);
  signal void                string_arg       (string s);
  signal void                enum_arg         (QuickEnum e);
  signal void                record_arg       (QuickRecord r);
  signal void                sequence_arg     (QuickSequence s);
  signal void                interface_arg    (GrandChild i);
  signal void                any_arg          (any a);
  signal void                self_args        (SignalTestInterface self_);
};

interface ChildInheritingSignals : SignalTestInterface {
  signal void child_signal (ChildInheritingSignals c, SignalTestInterface p, any a, int i, QuickRecord r, QuickSequence s);
};

interface AnotherChild : SignalTestInterface {
};

interface PropertyTester {
  // void        void_prop;
  bool           bool_prop;
  int            int_prop;
  float          float_prop;
  string         string_prop;
  QuickEnum      enum_prop;
  QuickRecord    record_prop;
  QuickSequence  sequence_prop;
  GrandChild     interface_prop;
  PropertyTester self_prop;
  any            any_prop;
};

} // InterfaceTests

include "include-p1.idl"; // test includes

namespace RapicornAidaTest {

enum ClickType {
  CLICK_ON_PRESS        = 1,
  CLICK_ON_RELEASE,
  CLICK_SLOW_REPEAT,
  CLICK_FAST_REPEAT,
  CLICK_KEY_REPEAT,
};

interface ButtonArea // : public virtual Container, public virtual FocusFrame::Client
{
  signal<until0> bool check_activate  ();
  signal void         activate        ();
  // protected: explicit              ButtonArea();
  string        on_click;
  string        on_click2;
  string        on_click3;
  ClickType     click_type;
  // virtual const PropertyList&   list_properties ();
};

interface PureMethods; // interface prototyping

interface PureMethods {
  int pure_method (float f) = 0;
};

interface PureMethods; // interface prototyping

// math expression tests
enum MathExpressions {
  RESULT_2      = 1 + 1,
  RESULT_5      = 4 | 5,
  RESULT_8      = 15 & 8,
  RESULT_6      = 7 ^ 1,
  RESULT_7      = 6 ^ 1,
  RESULT_16     = 2 << 3,
  RESULT_3      = 13 >> 2,
  RESULT_24     = 3 << 2 + 1,
  RESULT_13     = ((3 << 2) + 1),
  RESULT_m2     = ~1,
  RESULT_77     = ~-78,
  RESULT_511    = 0x01ff,
};

} // RapicornAidaTest

namespace Other {

interface NameTests {
  void  args_from_other_namespace (InterfaceTests::QuickRecord qr, ::RapicornAidaTest::ClickType qe);
};

} // Other
