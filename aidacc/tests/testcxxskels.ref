// --- Generated by AidaCxxStub ---

// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

#include <rapicorn-core.hh> // for rcore/signal.hh

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

/** @interface FirstInterface
 * See also the corresponding C++ servant class I_FirstInterfaceIface. */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_FirstInterfaceIface ();
  virtual /*Des*/                       ~I_FirstInterfaceIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "MandatoryNamespace::FirstInterface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          void_func             ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterfaceIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterfaceIface*&);
I_FirstInterfaceIface* operator->* (FirstInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
FirstInterfaceHandle operator->* (I_FirstInterfaceIface *obj, Rapicorn::Aida::_HandleType);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64 AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecord AliasRecord;

typedef XFooSequence AliasSequence;

typedef ExtensiveEnum AliasEnum;
} // MandatoryNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64 Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ servant class I_UIWidgetAreaIface. */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_UIWidgetAreaIface ();
  virtual /*Des*/                       ~I_UIWidgetAreaIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::UIWidgetArea"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_signal;
  typedef Rapicorn::Aida::AsyncSignal<double (I_UIWidgetAreaIface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method       ();
  virtual double                        single_arg          (int n);
  virtual double                        single_arg2         (int n = 5);
  virtual double                        two_args            (int n,
                                                             double r);
  virtual double                        two_args2           (int n = 6,
                                                             double r = 7.7);
  virtual double                        multi_args          (bool b,
                                                             Rapicorn::Aida::int64 n,
                                                             double r,
                                                             int i,
                                                             const std::string &s = "String ding",
                                                             double y = 5);
  virtual double                        self_method         (I_UIWidgetAreaIface &ba1,
                                                             I_UIWidgetAreaIface &ba2);
  virtual void                          void_method         ();
  virtual std::string                   on_click2out        ();
  virtual void                          on_click2in         (const std::string &command);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetAreaIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetAreaIface*&);
I_UIWidgetAreaIface* operator->* (UIWidgetAreaHandle &sh, Rapicorn::Aida::_ServantType);
UIWidgetAreaHandle operator->* (I_UIWidgetAreaIface *obj, Rapicorn::Aida::_HandleType);

/** @interface Parent
 * See also the corresponding C++ servant class I_ParentIface. */
/// See also the corresponding IDL class Parent.
class I_ParentIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ParentIface ();
  virtual /*Des*/                       ~I_ParentIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::Parent"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ParentIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ParentIface*&);
I_ParentIface* operator->* (ParentHandle &sh, Rapicorn::Aida::_ServantType);
ParentHandle operator->* (I_ParentIface *obj, Rapicorn::Aida::_HandleType);

/** @interface Child
 * See also the corresponding C++ servant class I_ChildIface. */
/// See also the corresponding IDL class Child.
class I_ChildIface : public virtual I_ParentIface
{
protected:
  explicit                               I_ChildIface ();
  virtual /*Des*/                       ~I_ChildIface () = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::Child"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildIface*&);
I_ChildIface* operator->* (ChildHandle &sh, Rapicorn::Aida::_ServantType);
ChildHandle operator->* (I_ChildIface *obj, Rapicorn::Aida::_HandleType);

/** @interface Descendant
 * See also the corresponding C++ servant class I_DescendantIface. */
/// See also the corresponding IDL class Descendant.
class I_DescendantIface : public virtual I_ChildIface
{
protected:
  explicit                               I_DescendantIface ();
  virtual /*Des*/                       ~I_DescendantIface () = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::Descendant"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_DescendantIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_DescendantIface*&);
I_DescendantIface* operator->* (DescendantHandle &sh, Rapicorn::Aida::_ServantType);
DescendantHandle operator->* (I_DescendantIface *obj, Rapicorn::Aida::_HandleType);

/** @interface GrandChild
 * See also the corresponding C++ servant class I_GrandChildIface. */
/// See also the corresponding IDL class GrandChild.
class I_GrandChildIface : public virtual I_DescendantIface
{
protected:
  explicit                               I_GrandChildIface ();
  virtual /*Des*/                       ~I_GrandChildIface () = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::GrandChild"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChildIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChildIface*&);
I_GrandChildIface* operator->* (GrandChildHandle &sh, Rapicorn::Aida::_ServantType);
GrandChildHandle operator->* (I_GrandChildIface *obj, Rapicorn::Aida::_HandleType);

/** @interface QuickIface
 * See also the corresponding C++ servant class I_QuickIfaceIface. */
/// See also the corresponding IDL class QuickIface.
class I_QuickIfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_QuickIfaceIface ();
  virtual /*Des*/                       ~I_QuickIfaceIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::QuickIface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          simple_function   (int i = 9);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIfaceIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIfaceIface*&);
I_QuickIfaceIface* operator->* (QuickIfaceHandle &sh, Rapicorn::Aida::_ServantType);
QuickIfaceHandle operator->* (I_QuickIfaceIface *obj, Rapicorn::Aida::_HandleType);

/** @interface MethodTestInterface
 * See also the corresponding C++ servant class I_MethodTestInterfaceIface. */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_MethodTestInterfaceIface ();
  virtual /*Des*/                       ~I_MethodTestInterfaceIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::MethodTestInterface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          method_with_void           ();
  virtual bool                          method_with_bools          (bool input,
                                                                    bool optval = 0);
  virtual int                           method_with_ints32         (int input,
                                                                    int optval = -2);
  virtual Rapicorn::Aida::int64         method_with_ints64         (Rapicorn::Aida::int64 input,
                                                                    Rapicorn::Aida::int64 optval = 576460752303423488);
  virtual double                        method_with_floats         (double input,
                                                                    double optval = 309.9);
  virtual std::string                   method_with_string         (const std::string &input,
                                                                    const std::string &optval = "default");
  virtual QuickEnum                     method_with_enum           (QuickEnum input,
                                                                    QuickEnum optval = QuickEnum (0));
  virtual QuickRecord                   method_with_record         (const QuickRecord &input,
                                                                    const QuickRecord &optval = QuickRecord());
  virtual QuickSequence                 method_with_sequence       (const QuickSequence &input,
                                                                    const QuickSequence &optval = QuickSequence());
  virtual I_GrandChildIface*            method_with_interface      (I_GrandChildIface &input,
                                                                    I_GrandChildIface &optval = *(I_GrandChildIface*) NULL);
  virtual Rapicorn::Aida::Any           method_with_anys           (const Rapicorn::Aida::Any &input,
                                                                    const Rapicorn::Aida::Any &optval);
  virtual I_QuickIfaceIface*            method_with_quickiface     (I_QuickIfaceIface &input,
                                                                    I_QuickIfaceIface &iface0 = *(I_QuickIfaceIface*) NULL);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterfaceIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterfaceIface*&);
I_MethodTestInterfaceIface* operator->* (MethodTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
MethodTestInterfaceHandle operator->* (I_MethodTestInterfaceIface *obj, Rapicorn::Aida::_HandleType);

/** @interface SignalTestInterface
 * See also the corresponding C++ servant class I_SignalTestInterfaceIface. */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SignalTestInterfaceIface ();
  virtual /*Des*/                       ~I_SignalTestInterfaceIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::SignalTestInterface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_result;
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_bool_result;
  typedef Rapicorn::Aida::AsyncSignal<int ()> Signal_int32_result;
  typedef Rapicorn::Aida::AsyncSignal<Rapicorn::Aida::int64 ()> Signal_int64_result;
  typedef Rapicorn::Aida::AsyncSignal<double ()> Signal_float64_result;
  typedef Rapicorn::Aida::AsyncSignal<std::string ()> Signal_string_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Aida::AsyncSignal<I_GrandChildIface* ()> Signal_interface_result;
  typedef Rapicorn::Aida::AsyncSignal<Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Aida::AsyncSignal<I_SignalTestInterfaceIface* ()> Signal_self_result;
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_arg;
  typedef Rapicorn::Aida::Signal<void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Aida::Signal<void (int i)> Signal_int32_arg;
  typedef Rapicorn::Aida::Signal<void (Rapicorn::Aida::int64 i)> Signal_int64_arg;
  typedef Rapicorn::Aida::Signal<void (double f)> Signal_float64_arg;
  typedef Rapicorn::Aida::Signal<void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Aida::Signal<void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Aida::Signal<void (const QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Aida::Signal<void (const QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Aida::Signal<void (I_GrandChildIface &i)> Signal_interface_arg;
  typedef Rapicorn::Aida::Signal<void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Aida::Signal<void (I_SignalTestInterfaceIface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterfaceIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterfaceIface*&);
I_SignalTestInterfaceIface* operator->* (SignalTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
SignalTestInterfaceHandle operator->* (I_SignalTestInterfaceIface *obj, Rapicorn::Aida::_HandleType);

/** @interface ChildInheritingSignals
 * See also the corresponding C++ servant class I_ChildInheritingSignalsIface. */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignalsIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_ChildInheritingSignalsIface ();
  virtual /*Des*/                       ~I_ChildInheritingSignalsIface () = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::ChildInheritingSignals"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void (I_ChildInheritingSignalsIface &c, I_SignalTestInterfaceIface &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignalsIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignalsIface*&);
I_ChildInheritingSignalsIface* operator->* (ChildInheritingSignalsHandle &sh, Rapicorn::Aida::_ServantType);
ChildInheritingSignalsHandle operator->* (I_ChildInheritingSignalsIface *obj, Rapicorn::Aida::_HandleType);

/** @interface AnotherChild
 * See also the corresponding C++ servant class I_AnotherChildIface. */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChildIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_AnotherChildIface ();
  virtual /*Des*/                       ~I_AnotherChildIface () = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::AnotherChild"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChildIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChildIface*&);
I_AnotherChildIface* operator->* (AnotherChildHandle &sh, Rapicorn::Aida::_ServantType);
AnotherChildHandle operator->* (I_AnotherChildIface *obj, Rapicorn::Aida::_HandleType);

/** @interface PropertyTester
 * See also the corresponding C++ servant class I_PropertyTesterIface. */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTesterIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PropertyTesterIface ();
  virtual /*Des*/                       ~I_PropertyTesterIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::PropertyTester"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual Rapicorn::Aida::int64         int64_prop     () const = 0;
  virtual void                          int64_prop     (Rapicorn::Aida::int64) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecord                   record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecord&) = 0;
  virtual QuickSequence                 sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequence&) = 0;
  virtual I_GrandChildIface*            interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChildIface*) = 0;
  virtual I_PropertyTesterIface*        self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTesterIface*) = 0;
  virtual Rapicorn::Aida::Any           any_prop       () const = 0;
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTesterIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTesterIface*&);
I_PropertyTesterIface* operator->* (PropertyTesterHandle &sh, Rapicorn::Aida::_ServantType);
PropertyTesterHandle operator->* (I_PropertyTesterIface *obj, Rapicorn::Aida::_HandleType);
} // InterfaceTests

namespace RapicornAidaTest {

/** @interface ButtonArea
 * See also the corresponding C++ servant class I_ButtonAreaIface. */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ButtonAreaIface ();
  virtual /*Des*/                       ~I_ButtonAreaIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "RapicornAidaTest::ButtonArea"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_check_activate;
  typedef Rapicorn::Aida::Signal<void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonAreaIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonAreaIface*&);
I_ButtonAreaIface* operator->* (ButtonAreaHandle &sh, Rapicorn::Aida::_ServantType);
ButtonAreaHandle operator->* (I_ButtonAreaIface *obj, Rapicorn::Aida::_HandleType);

class I_PureMethodsIface;

/** @interface PureMethods
 * See also the corresponding C++ servant class I_PureMethodsIface. */
/// See also the corresponding IDL class PureMethods.
class I_PureMethodsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PureMethodsIface ();
  virtual /*Des*/                       ~I_PureMethodsIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "RapicornAidaTest::PureMethods"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual int                           pure_method        (double f) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethodsIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethodsIface*&);
I_PureMethodsIface* operator->* (PureMethodsHandle &sh, Rapicorn::Aida::_ServantType);
PureMethodsHandle operator->* (I_PureMethodsIface *obj, Rapicorn::Aida::_HandleType);
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ servant class I_NameTestsIface. */
/// See also the corresponding IDL class NameTests.
class I_NameTestsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_NameTestsIface ();
  virtual /*Des*/                       ~I_NameTestsIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "Other::NameTests"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecord &sr);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTestsIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTestsIface*&);
I_NameTestsIface* operator->* (NameTestsHandle &sh, Rapicorn::Aida::_ServantType);
NameTestsHandle operator->* (I_NameTestsIface *obj, Rapicorn::Aida::_HandleType);
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ servant class I_CompressorIface. */
/// See also the corresponding IDL class Compressor.
class I_CompressorIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_CompressorIface ();
  virtual /*Des*/                       ~I_CompressorIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "BseTest::Compressor"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_CompressorIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_CompressorIface*&);
I_CompressorIface* operator->* (CompressorHandle &sh, Rapicorn::Aida::_ServantType);
CompressorHandle operator->* (I_CompressorIface *obj, Rapicorn::Aida::_HandleType);

/** @interface SoundModule
 * See also the corresponding C++ servant class I_SoundModuleIface. */
/// See also the corresponding IDL class SoundModule.
class I_SoundModuleIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SoundModuleIface ();
  virtual /*Des*/                       ~I_SoundModuleIface () = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  Rapicorn::Aida::TypeCode               __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
  virtual std::string                    __aida_type_name__ () const	{ return "BseTest::SoundModule"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModuleIface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModuleIface*&);
I_SoundModuleIface* operator->* (SoundModuleHandle &sh, Rapicorn::Aida::_ServantType);
SoundModuleHandle operator->* (I_SoundModuleIface *obj, Rapicorn::Aida::_HandleType);
} // BseTest

// --- Interface Skeletons ---

void
MandatoryNamespace::I_FirstInterfaceIface::void_func ()
{
}

double
InterfaceTests::I_UIWidgetAreaIface::simple_method ()
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::single_arg (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::single_arg2 (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::two_args (int n,
                                               double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::two_args2 (int n,
                                                double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::multi_args (bool b,
                                                 Rapicorn::Aida::int64 n,
                                                 double r,
                                                 int i,
                                                 const std::string &s,
                                                 double y)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::self_method (InterfaceTests::I_UIWidgetAreaIface &ba1,
                                                  InterfaceTests::I_UIWidgetAreaIface &ba2)
{
  return 0;
}

void
InterfaceTests::I_UIWidgetAreaIface::void_method ()
{
}

std::string
InterfaceTests::I_UIWidgetAreaIface::on_click2out ()
{
  return "";
}

void
InterfaceTests::I_UIWidgetAreaIface::on_click2in (const std::string &command)
{
}

void
InterfaceTests::I_QuickIfaceIface::simple_function (int i)
{
}

void
InterfaceTests::I_MethodTestInterfaceIface::method_with_void ()
{
}

bool
InterfaceTests::I_MethodTestInterfaceIface::method_with_bools (bool input,
                                                               bool optval)
{
  return 0;
}

int
InterfaceTests::I_MethodTestInterfaceIface::method_with_ints32 (int input,
                                                                int optval)
{
  return 0;
}

Rapicorn::Aida::int64
InterfaceTests::I_MethodTestInterfaceIface::method_with_ints64 (Rapicorn::Aida::int64 input,
                                                                Rapicorn::Aida::int64 optval)
{
  return 0;
}

double
InterfaceTests::I_MethodTestInterfaceIface::method_with_floats (double input,
                                                                double optval)
{
  return 0;
}

std::string
InterfaceTests::I_MethodTestInterfaceIface::method_with_string (const std::string &input,
                                                                const std::string &optval)
{
  return "";
}

InterfaceTests::QuickEnum
InterfaceTests::I_MethodTestInterfaceIface::method_with_enum (InterfaceTests::QuickEnum input,
                                                              InterfaceTests::QuickEnum optval)
{
  return InterfaceTests::QuickEnum (0);
}

InterfaceTests::QuickRecord
InterfaceTests::I_MethodTestInterfaceIface::method_with_record (const InterfaceTests::QuickRecord &input,
                                                                const InterfaceTests::QuickRecord &optval)
{
  return InterfaceTests::QuickRecord();
}

InterfaceTests::QuickSequence
InterfaceTests::I_MethodTestInterfaceIface::method_with_sequence (const InterfaceTests::QuickSequence &input,
                                                                  const InterfaceTests::QuickSequence &optval)
{
  return InterfaceTests::QuickSequence();
}

InterfaceTests::I_GrandChildIface*
InterfaceTests::I_MethodTestInterfaceIface::method_with_interface (InterfaceTests::I_GrandChildIface &input,
                                                                   InterfaceTests::I_GrandChildIface &optval)
{
  return 0;
}

Rapicorn::Aida::Any
InterfaceTests::I_MethodTestInterfaceIface::method_with_anys (const Rapicorn::Aida::Any &input,
                                                              const Rapicorn::Aida::Any &optval)
{
  return Rapicorn::Aida::Any();
}

InterfaceTests::I_QuickIfaceIface*
InterfaceTests::I_MethodTestInterfaceIface::method_with_quickiface (InterfaceTests::I_QuickIfaceIface &input,
                                                                    InterfaceTests::I_QuickIfaceIface &iface0)
{
  return 0;
}

void
Other::I_NameTestsIface::args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                    RapicornAidaTest::ClickType qe,
                                                    const OtherNamespace::SomeRecord &sr)
{
}

