// --- Generated by AidaCxxStub ---
#ifndef __SRVT____testpass_idl
#define __SRVT____testpass_idl


// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

#include <rapicorn-core.hh> // for rcore/signal.hh

#ifndef __ENUMHH____testpass_idl__
#define __ENUMHH____testpass_idl__

namespace MandatoryNamespace {

/// @cond GeneratedEnums
enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum1  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum1 &e) { e = Enum1 (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum1c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum1c &e) { e = Enum1c (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum2  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum2 &e) { e = Enum2 (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum2c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum2c &e) { e = Enum2c (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum3  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum3 &e) { e = Enum3 (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum3c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum3c &e) { e = Enum3c (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4a  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4a &e) { e = Enum4a (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4b  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4b &e) { e = Enum4b (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4c  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4c &e) { e = Enum4c (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  Enum4d  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, Enum4d &e) { e = Enum4d (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  ExtensiveEnum  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, ExtensiveEnum &e) { e = ExtensiveEnum (__f_.pop_evalue()); }
/// @endcond
} // MandatoryNamespace

namespace InterfaceTests {

/// @cond GeneratedEnums
enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  QuickEnum  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, QuickEnum &e) { e = QuickEnum (__f_.pop_evalue()); }
/// @endcond
} // InterfaceTests

namespace RapicornAidaTest {

/// @cond GeneratedEnums
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  ClickType  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, ClickType &e) { e = ClickType (__f_.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum MathExpressions {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline void operator<<= (Rapicorn::Aida::ProtoMsg &__p_,  MathExpressions  e) { __p_ <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::ProtoReader &__f_, MathExpressions &e) { e = MathExpressions (__f_.pop_evalue()); }
/// @endcond
} // RapicornAidaTest

namespace Rapicorn {

namespace Aida {
template<> EnumInfo enum_info<MandatoryNamespace::Enum1> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum1c> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum2> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum2c> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum3> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum3c> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum4a> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum4b> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum4c> ();
template<> EnumInfo enum_info<MandatoryNamespace::Enum4d> ();
template<> EnumInfo enum_info<MandatoryNamespace::ExtensiveEnum> ();
template<> EnumInfo enum_info<InterfaceTests::QuickEnum> ();
template<> EnumInfo enum_info<RapicornAidaTest::ClickType> ();
template<> EnumInfo enum_info<RapicornAidaTest::MathExpressions> ();
} // Aida
} // Rapicorn

#endif // __ENUMHH____testpass_idl__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

class I_FirstInterfaceIface;
typedef std::shared_ptr<I_FirstInterfaceIface> I_FirstInterfaceIfaceP;
typedef std::weak_ptr  <I_FirstInterfaceIface> I_FirstInterfaceIfaceW;

/** @interface FirstInterface
 * See also the corresponding C++ servant class I_FirstInterfaceIface. */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_FirstInterfaceIface ();
  virtual /*Des*/                       ~I_FirstInterfaceIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "MandatoryNamespace::FirstInterface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          void_func             () = 0; 	///< See FirstInterface::void_func()
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_FirstInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_FirstInterfaceIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_FirstInterfaceIfaceP&);

struct SrvT_XFooRecord
{
  /// @cond GeneratedFields
  bool                          single_bool;
  int                           single_num;
  int64_t                       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  I_FirstInterfaceIfaceP        iface1;
  I_FirstInterfaceIfaceP        iface2;
  I_FirstInterfaceIfaceP        iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  /// @endcond
  inline                        SrvT_XFooRecord () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::XFooRecord"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_XFooRecord &other) const;
  bool                          operator!=  (const SrvT_XFooRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (single_bool, "single_bool");
    _visitor_ (single_num, "single_num");
    _visitor_ (num64, "num64");
    _visitor_ (single_float, "single_float");
    _visitor_ (single_string, "single_string");
    _visitor_ (sibling1, "sibling1");
    _visitor_ (sibling2, "sibling2");
    _visitor_ (multi1, "multi1");
    _visitor_ (multi2, "multi2");
    _visitor_ (multi3, "multi3");
    _visitor_ (multi4, "multi4");
    _visitor_ (enum_field, "enum_field");
    _visitor_ (iface1, "iface1");
    _visitor_ (iface2, "iface2");
    _visitor_ (iface3, "iface3");
    _visitor_ (any1, "any1");
    _visitor_ (any2, "any2");
    _visitor_ (any3, "any3");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_XFooRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_XFooRecord&);

struct SrvT_XFooSequence : public std::vector<bool>
{
  typedef std::vector<bool> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::XFooSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_XFooSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_XFooSequence&);

struct SrvT_IntSequence : public std::vector<int>
{
  typedef std::vector<int> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::IntSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_IntSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_IntSequence&);

struct SrvT_FloatSequence : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::FloatSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_FloatSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_FloatSequence&);

struct SrvT_StringSequence : public std::vector<std::string>
{
  typedef std::vector<std::string> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::StringSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_StringSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_StringSequence&);

struct SrvT_ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::ExtensiveEnumSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_ExtensiveEnumSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_ExtensiveEnumSequence&);

struct SrvT_RecordSequence : public std::vector<SrvT_XFooRecord>
{
  typedef std::vector<SrvT_XFooRecord> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::RecordSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_RecordSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_RecordSequence&);

struct SrvT_SequenceSequence : public std::vector<SrvT_IntSequence>
{
  typedef std::vector<SrvT_IntSequence> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::SequenceSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_SequenceSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_SequenceSequence&);

struct SrvT_InterfaceSequence : public std::vector<I_FirstInterfaceIfaceP>
{
  typedef std::vector<I_FirstInterfaceIfaceP> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::InterfaceSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_InterfaceSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_InterfaceSequence&);

struct SrvT_AnySequence : public std::vector<Rapicorn::Aida::Any>
{
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::AnySequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_AnySequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_AnySequence&);

class SrvT_NestedTypesRec;

class SrvT_NestedTypesSeq;

struct SrvT_NestedTypesRec
{
  /// @cond GeneratedFields
  SrvT_XFooRecord               rec;
  SrvT_XFooSequence             seq;
  /// @endcond
  inline                        SrvT_NestedTypesRec () { }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::NestedTypesRec"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_NestedTypesRec &other) const;
  bool                          operator!=  (const SrvT_NestedTypesRec &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (rec, "rec");
    _visitor_ (seq, "seq");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_NestedTypesRec&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_NestedTypesRec&);

struct SrvT_NestedTypesSeq : public std::vector<SrvT_NestedTypesRec>
{
  typedef std::vector<SrvT_NestedTypesRec> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::NestedTypesSeq"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_NestedTypesSeq&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_NestedTypesSeq&);

struct SrvT_NewRecord
{
  /// @cond GeneratedFields
  int                           i;
  Enum1                         enum1;
  SrvT_XFooSequence             xfs;
  SrvT_NestedTypesRec           ntr;
  /// @endcond
  inline                        SrvT_NewRecord () { i = 0; enum1 = Enum1 (0); }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::NewRecord"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_NewRecord &other) const;
  bool                          operator!=  (const SrvT_NewRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (i, "i");
    _visitor_ (enum1, "enum1");
    _visitor_ (xfs, "xfs");
    _visitor_ (ntr, "ntr");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_NewRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_NewRecord&);

namespace Inner {

struct SrvT_InnerRecord
{
  /// @cond GeneratedFields
  int                           x;
  int                           y;
  SrvT_NewRecord                rec;
  /// @endcond
  inline                        SrvT_InnerRecord () { x = 0; y = 0; }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::Inner::InnerRecord"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_InnerRecord &other) const;
  bool                          operator!=  (const SrvT_InnerRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (x, "x");
    _visitor_ (y, "y");
    _visitor_ (rec, "rec");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_InnerRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_InnerRecord&);
} // Inner

struct SrvT_Refer2Inner
{
  /// @cond GeneratedFields
  Inner::SrvT_InnerRecord       r;
  /// @endcond
  inline                        SrvT_Refer2Inner () { }
  std::string                     __aida_type_name__ () const	{ return "MandatoryNamespace::Refer2Inner"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_Refer2Inner &other) const;
  bool                          operator!=  (const SrvT_Refer2Inner &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (r, "r");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_Refer2Inner&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_Refer2Inner&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SrvT_SomeRecord
{
  /// @cond GeneratedFields
  MandatoryNamespace::SrvT_NewRecord r1;
  MandatoryNamespace::SrvT_NewRecord r2;
  MandatoryNamespace::Inner::SrvT_InnerRecord r3;
  MandatoryNamespace::Inner::SrvT_InnerRecord r4;
  /// @endcond
  inline                        SrvT_SomeRecord () { }
  std::string                     __aida_type_name__ () const	{ return "OtherNamespace::SomeRecord"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_SomeRecord &other) const;
  bool                          operator!=  (const SrvT_SomeRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (r1, "r1");
    _visitor_ (r2, "r2");
    _visitor_ (r3, "r3");
    _visitor_ (r4, "r4");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_SomeRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_SomeRecord&);
} // OtherNamespace

namespace Auxdata {

struct SrvT_RecordWithAuxdata
{
  /// @cond GeneratedFields
  bool                          aux_bool;
  int                           aux32;
  int64_t                       aux64;
  double                        auxf64;
  std::string                   aux_str;
  /// @endcond
  inline                        SrvT_RecordWithAuxdata () { aux_bool = 0; aux32 = 0; aux64 = 0; auxf64 = 0; }
  std::string                     __aida_type_name__ () const	{ return "Auxdata::RecordWithAuxdata"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_RecordWithAuxdata &other) const;
  bool                          operator!=  (const SrvT_RecordWithAuxdata &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (aux_bool, "aux_bool");
    _visitor_ (aux32, "aux32");
    _visitor_ (aux64, "aux64");
    _visitor_ (auxf64, "auxf64");
    _visitor_ (aux_str, "aux_str");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_RecordWithAuxdata&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_RecordWithAuxdata&);
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetAreaIface;
typedef std::shared_ptr<I_UIWidgetAreaIface> I_UIWidgetAreaIfaceP;
typedef std::weak_ptr  <I_UIWidgetAreaIface> I_UIWidgetAreaIfaceW;

/** @interface UIWidgetArea
 * See also the corresponding C++ servant class I_UIWidgetAreaIface. */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_UIWidgetAreaIface ();
  virtual /*Des*/                       ~I_UIWidgetAreaIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::UIWidgetArea"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          dummy    () const = 0; 	///< See UIWidgetArea::dummy
  virtual void                          dummy    (bool) = 0; 	///< See UIWidgetArea::dummy
  virtual std::string                   on_click () const = 0; 	///< See UIWidgetArea::on_click
  virtual void                          on_click (const std::string&) = 0; 	///< See UIWidgetArea::on_click
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_signal;
  typedef Rapicorn::Aida::AsyncSignal<double (I_UIWidgetAreaIface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method       () = 0; 	///< See UIWidgetArea::simple_method()
  virtual double                        single_arg          (int n) = 0; 	///< See UIWidgetArea::single_arg()
  virtual double                        single_arg2         (int n = 5) = 0; 	///< See UIWidgetArea::single_arg2()
  virtual double                        two_args            (int n,
                                                             double r) = 0; 	///< See UIWidgetArea::two_args()
  virtual double                        two_args2           (int n = 6,
                                                             double r = 7.7) = 0; 	///< See UIWidgetArea::two_args2()
  virtual double                        multi_args          (bool b,
                                                             int64_t n,
                                                             double r,
                                                             int i,
                                                             const std::string &s = "String ding",
                                                             double y = 5) = 0; 	///< See UIWidgetArea::multi_args()
  virtual double                        self_method         (I_UIWidgetAreaIface &ba1,
                                                             I_UIWidgetAreaIface &ba2) = 0; 	///< See UIWidgetArea::self_method()
  virtual void                          void_method         () = 0; 	///< See UIWidgetArea::void_method()
  virtual std::string                   on_click2out        () = 0; 	///< See UIWidgetArea::on_click2out()
  virtual void                          on_click2in         (const std::string &command) = 0; 	///< See UIWidgetArea::on_click2in()
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_UIWidgetAreaIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_UIWidgetAreaIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_UIWidgetAreaIfaceP&);

class I_ParentIface;
typedef std::shared_ptr<I_ParentIface> I_ParentIfaceP;
typedef std::weak_ptr  <I_ParentIface> I_ParentIfaceW;

/** @interface Parent
 * See also the corresponding C++ servant class I_ParentIface. */
/// See also the corresponding IDL class Parent.
class I_ParentIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ParentIface ();
  virtual /*Des*/                       ~I_ParentIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::Parent"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_ParentIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ParentIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ParentIfaceP&);

class I_ChildIface;
typedef std::shared_ptr<I_ChildIface> I_ChildIfaceP;
typedef std::weak_ptr  <I_ChildIface> I_ChildIfaceW;

/** @interface Child
 * See also the corresponding C++ servant class I_ChildIface. */
/// See also the corresponding IDL class Child.
class I_ChildIface : public virtual I_ParentIface
{
protected:
  explicit                               I_ChildIface ();
  virtual /*Des*/                       ~I_ChildIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::Child"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_ChildIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ChildIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ChildIfaceP&);

class I_DescendantIface;
typedef std::shared_ptr<I_DescendantIface> I_DescendantIfaceP;
typedef std::weak_ptr  <I_DescendantIface> I_DescendantIfaceW;

/** @interface Descendant
 * See also the corresponding C++ servant class I_DescendantIface. */
/// See also the corresponding IDL class Descendant.
class I_DescendantIface : public virtual I_ChildIface
{
protected:
  explicit                               I_DescendantIface ();
  virtual /*Des*/                       ~I_DescendantIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::Descendant"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_DescendantIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_DescendantIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_DescendantIfaceP&);

class I_GrandChildIface;
typedef std::shared_ptr<I_GrandChildIface> I_GrandChildIfaceP;
typedef std::weak_ptr  <I_GrandChildIface> I_GrandChildIfaceW;

/** @interface GrandChild
 * See also the corresponding C++ servant class I_GrandChildIface. */
/// See also the corresponding IDL class GrandChild.
class I_GrandChildIface : public virtual I_DescendantIface
{
protected:
  explicit                               I_GrandChildIface ();
  virtual /*Des*/                       ~I_GrandChildIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::GrandChild"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_GrandChildIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_GrandChildIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_GrandChildIfaceP&);

struct SrvT_QuickRecord
{
  /// @cond GeneratedFields
  int                           int1;
  int                           int2;
  /// @endcond
  inline                        SrvT_QuickRecord () { int1 = 0; int2 = 0; }
  std::string                     __aida_type_name__ () const	{ return "InterfaceTests::QuickRecord"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_QuickRecord &other) const;
  bool                          operator!=  (const SrvT_QuickRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (int1, "int1");
    _visitor_ (int2, "int2");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_QuickRecord&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_QuickRecord&);

struct SrvT_QuickSequence : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  std::string                     __aida_type_name__ () const	{ return "InterfaceTests::QuickSequence"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_sequence (any, *this); }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_QuickSequence&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_QuickSequence&);

class I_QuickIfaceIface;
typedef std::shared_ptr<I_QuickIfaceIface> I_QuickIfaceIfaceP;
typedef std::weak_ptr  <I_QuickIfaceIface> I_QuickIfaceIfaceW;

/** @interface QuickIface
 * See also the corresponding C++ servant class I_QuickIfaceIface. */
/// See also the corresponding IDL class QuickIface.
class I_QuickIfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_QuickIfaceIface ();
  virtual /*Des*/                       ~I_QuickIfaceIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::QuickIface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          simple_function   (int i = 9) = 0; 	///< See QuickIface::simple_function()
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_QuickIfaceIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_QuickIfaceIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_QuickIfaceIfaceP&);

class I_MethodTestInterfaceIface;
typedef std::shared_ptr<I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceP;
typedef std::weak_ptr  <I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceW;

/** @interface MethodTestInterface
 * See also the corresponding C++ servant class I_MethodTestInterfaceIface. */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_MethodTestInterfaceIface ();
  virtual /*Des*/                       ~I_MethodTestInterfaceIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::MethodTestInterface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          method_with_void           () = 0; 	///< See MethodTestInterface::method_with_void()
  virtual bool                          method_with_bools          (bool input,
                                                                    bool optval = 0) = 0; 	///< See MethodTestInterface::method_with_bools()
  virtual int                           method_with_ints32         (int input,
                                                                    int optval = -2) = 0; 	///< See MethodTestInterface::method_with_ints32()
  virtual int64_t                       method_with_ints64         (int64_t input,
                                                                    int64_t optval = 576460752303423488) = 0; 	///< See MethodTestInterface::method_with_ints64()
  virtual double                        method_with_floats         (double input,
                                                                    double optval = 309.9) = 0; 	///< See MethodTestInterface::method_with_floats()
  virtual std::string                   method_with_string         (const std::string &input,
                                                                    const std::string &optval = "default") = 0; 	///< See MethodTestInterface::method_with_string()
  virtual QuickEnum                     method_with_enum           (QuickEnum input,
                                                                    QuickEnum optval = QuickEnum (0)) = 0; 	///< See MethodTestInterface::method_with_enum()
  virtual SrvT_QuickRecord              method_with_record         (const SrvT_QuickRecord &input,
                                                                    const SrvT_QuickRecord &optval = SrvT_QuickRecord()) = 0; 	///< See MethodTestInterface::method_with_record()
  virtual SrvT_QuickSequence            method_with_sequence       (const SrvT_QuickSequence &input,
                                                                    const SrvT_QuickSequence &optval = SrvT_QuickSequence()) = 0; 	///< See MethodTestInterface::method_with_sequence()
  virtual I_GrandChildIfaceP            method_with_interface      (I_GrandChildIface &input,
                                                                    I_GrandChildIface &optval = *(I_GrandChildIface*) NULL) = 0; 	///< See MethodTestInterface::method_with_interface()
  virtual Rapicorn::Aida::Any           method_with_anys           (const Rapicorn::Aida::Any &input,
                                                                    const Rapicorn::Aida::Any &optval) = 0; 	///< See MethodTestInterface::method_with_anys()
  virtual I_QuickIfaceIfaceP            method_with_quickiface     (I_QuickIfaceIface &input,
                                                                    I_QuickIfaceIface &iface0 = *(I_QuickIfaceIface*) NULL) = 0; 	///< See MethodTestInterface::method_with_quickiface()
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_MethodTestInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_MethodTestInterfaceIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_MethodTestInterfaceIfaceP&);

class I_SignalTestInterfaceIface;
typedef std::shared_ptr<I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceP;
typedef std::weak_ptr  <I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceW;

/** @interface SignalTestInterface
 * See also the corresponding C++ servant class I_SignalTestInterfaceIface. */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SignalTestInterfaceIface ();
  virtual /*Des*/                       ~I_SignalTestInterfaceIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::SignalTestInterface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_result;
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_bool_result;
  typedef Rapicorn::Aida::AsyncSignal<int ()> Signal_int32_result;
  typedef Rapicorn::Aida::AsyncSignal<int64_t ()> Signal_int64_result;
  typedef Rapicorn::Aida::AsyncSignal<double ()> Signal_float64_result;
  typedef Rapicorn::Aida::AsyncSignal<std::string ()> Signal_string_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Aida::AsyncSignal<SrvT_QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Aida::AsyncSignal<SrvT_QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Aida::AsyncSignal<I_GrandChildIfaceP ()> Signal_interface_result;
  typedef Rapicorn::Aida::AsyncSignal<Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Aida::AsyncSignal<I_SignalTestInterfaceIfaceP ()> Signal_self_result;
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_arg;
  typedef Rapicorn::Aida::Signal<void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Aida::Signal<void (int i)> Signal_int32_arg;
  typedef Rapicorn::Aida::Signal<void (int64_t i)> Signal_int64_arg;
  typedef Rapicorn::Aida::Signal<void (double f)> Signal_float64_arg;
  typedef Rapicorn::Aida::Signal<void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Aida::Signal<void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Aida::Signal<void (const SrvT_QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Aida::Signal<void (const SrvT_QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Aida::Signal<void (I_GrandChildIface &i)> Signal_interface_arg;
  typedef Rapicorn::Aida::Signal<void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Aida::Signal<void (I_SignalTestInterfaceIface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_SignalTestInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_SignalTestInterfaceIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_SignalTestInterfaceIfaceP&);

class I_ChildInheritingSignalsIface;
typedef std::shared_ptr<I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceP;
typedef std::weak_ptr  <I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceW;

/** @interface ChildInheritingSignals
 * See also the corresponding C++ servant class I_ChildInheritingSignalsIface. */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignalsIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_ChildInheritingSignalsIface ();
  virtual /*Des*/                       ~I_ChildInheritingSignalsIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::ChildInheritingSignals"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void (I_ChildInheritingSignalsIface &c, I_SignalTestInterfaceIface &p, const Rapicorn::Aida::Any &a, int i, const SrvT_QuickRecord &r, const SrvT_QuickSequence &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_ChildInheritingSignalsIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ChildInheritingSignalsIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ChildInheritingSignalsIfaceP&);

class I_AnotherChildIface;
typedef std::shared_ptr<I_AnotherChildIface> I_AnotherChildIfaceP;
typedef std::weak_ptr  <I_AnotherChildIface> I_AnotherChildIfaceW;

/** @interface AnotherChild
 * See also the corresponding C++ servant class I_AnotherChildIface. */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChildIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_AnotherChildIface ();
  virtual /*Des*/                       ~I_AnotherChildIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::AnotherChild"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_AnotherChildIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_AnotherChildIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_AnotherChildIfaceP&);

class I_PropertyTesterIface;
typedef std::shared_ptr<I_PropertyTesterIface> I_PropertyTesterIfaceP;
typedef std::weak_ptr  <I_PropertyTesterIface> I_PropertyTesterIfaceW;

/** @interface PropertyTester
 * See also the corresponding C++ servant class I_PropertyTesterIface. */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTesterIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PropertyTesterIface ();
  virtual /*Des*/                       ~I_PropertyTesterIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::PropertyTester"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          bool_prop      () const = 0; 	///< See PropertyTester::bool_prop
  virtual void                          bool_prop      (bool) = 0; 	///< See PropertyTester::bool_prop
  virtual int                           int32_prop     () const = 0; 	///< See PropertyTester::int32_prop
  virtual void                          int32_prop     (int) = 0; 	///< See PropertyTester::int32_prop
  virtual int64_t                       int64_prop     () const = 0; 	///< See PropertyTester::int64_prop
  virtual void                          int64_prop     (int64_t) = 0; 	///< See PropertyTester::int64_prop
  virtual double                        float64_prop   () const = 0; 	///< See PropertyTester::float64_prop
  virtual void                          float64_prop   (double) = 0; 	///< See PropertyTester::float64_prop
  virtual std::string                   string_prop    () const = 0; 	///< See PropertyTester::string_prop
  virtual void                          string_prop    (const std::string&) = 0; 	///< See PropertyTester::string_prop
  virtual QuickEnum                     enum_prop      () const = 0; 	///< See PropertyTester::enum_prop
  virtual void                          enum_prop      (QuickEnum) = 0; 	///< See PropertyTester::enum_prop
  virtual SrvT_QuickRecord              record_prop    () const = 0; 	///< See PropertyTester::record_prop
  virtual void                          record_prop    (const SrvT_QuickRecord&) = 0; 	///< See PropertyTester::record_prop
  virtual SrvT_QuickSequence            sequence_prop  () const = 0; 	///< See PropertyTester::sequence_prop
  virtual void                          sequence_prop  (const SrvT_QuickSequence&) = 0; 	///< See PropertyTester::sequence_prop
  virtual I_GrandChildIfaceP            interface_prop () const = 0; 	///< See PropertyTester::interface_prop
  virtual void                          interface_prop (I_GrandChildIface*) = 0; 	///< See PropertyTester::interface_prop
  virtual I_PropertyTesterIfaceP        self_prop      () const = 0; 	///< See PropertyTester::self_prop
  virtual void                          self_prop      (I_PropertyTesterIface*) = 0; 	///< See PropertyTester::self_prop
  virtual Rapicorn::Aida::Any           any_prop       () const = 0; 	///< See PropertyTester::any_prop
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0; 	///< See PropertyTester::any_prop
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_PropertyTesterIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_PropertyTesterIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_PropertyTesterIfaceP&);
} // InterfaceTests

namespace RapicornAidaTest {

class I_ButtonAreaIface;
typedef std::shared_ptr<I_ButtonAreaIface> I_ButtonAreaIfaceP;
typedef std::weak_ptr  <I_ButtonAreaIface> I_ButtonAreaIfaceW;

/** @interface ButtonArea
 * See also the corresponding C++ servant class I_ButtonAreaIface. */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ButtonAreaIface ();
  virtual /*Des*/                       ~I_ButtonAreaIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "RapicornAidaTest::ButtonArea"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual std::string                   on_click   () const = 0; 	///< See ButtonArea::on_click
  virtual void                          on_click   (const std::string&) = 0; 	///< See ButtonArea::on_click
  virtual std::string                   on_click2  () const = 0; 	///< See ButtonArea::on_click2
  virtual void                          on_click2  (const std::string&) = 0; 	///< See ButtonArea::on_click2
  virtual std::string                   on_click3  () const = 0; 	///< See ButtonArea::on_click3
  virtual void                          on_click3  (const std::string&) = 0; 	///< See ButtonArea::on_click3
  virtual ClickType                     click_type () const = 0; 	///< See ButtonArea::click_type
  virtual void                          click_type (ClickType) = 0; 	///< See ButtonArea::click_type
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_check_activate;
  typedef Rapicorn::Aida::Signal<void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_ButtonAreaIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ButtonAreaIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_ButtonAreaIfaceP&);

class I_PureMethodsIface;
typedef std::shared_ptr<I_PureMethodsIface> I_PureMethodsIfaceP;
typedef std::weak_ptr  <I_PureMethodsIface> I_PureMethodsIfaceW;


/** @interface PureMethods
 * See also the corresponding C++ servant class I_PureMethodsIface. */
/// See also the corresponding IDL class PureMethods.
class I_PureMethodsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PureMethodsIface ();
  virtual /*Des*/                       ~I_PureMethodsIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "RapicornAidaTest::PureMethods"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual int                           pure_method        (double f) = 0; 	///< See PureMethods::pure_method()
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_PureMethodsIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_PureMethodsIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_PureMethodsIfaceP&);
} // RapicornAidaTest

namespace Other {

class I_NameTestsIface;
typedef std::shared_ptr<I_NameTestsIface> I_NameTestsIfaceP;
typedef std::weak_ptr  <I_NameTestsIface> I_NameTestsIfaceW;

/** @interface NameTests
 * See also the corresponding C++ servant class I_NameTestsIface. */
/// See also the corresponding IDL class NameTests.
class I_NameTestsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_NameTestsIface ();
  virtual /*Des*/                       ~I_NameTestsIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "Other::NameTests"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          args_from_other_namespace (const InterfaceTests::SrvT_QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SrvT_SomeRecord &sr) = 0; 	///< See NameTests::args_from_other_namespace()
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_NameTestsIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_NameTestsIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_NameTestsIfaceP&);
} // Other

namespace BseTest {

class I_CompressorIface;
typedef std::shared_ptr<I_CompressorIface> I_CompressorIfaceP;
typedef std::weak_ptr  <I_CompressorIface> I_CompressorIfaceW;

/** @interface Compressor
 * See also the corresponding C++ servant class I_CompressorIface. */
/// See also the corresponding IDL class Compressor.
class I_CompressorIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_CompressorIface ();
  virtual /*Des*/                       ~I_CompressorIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "BseTest::Compressor"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual double                        threshold () const = 0; 	///< See Compressor::threshold
  virtual void                          threshold (double) = 0; 	///< See Compressor::threshold
  virtual double                        ratio     () const = 0; 	///< See Compressor::ratio
  virtual void                          ratio     (double) = 0; 	///< See Compressor::ratio
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_CompressorIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_CompressorIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_CompressorIfaceP&);

struct SrvT_RecordForGroups
{
  /// @cond GeneratedFields
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  /// @endcond
  inline                        SrvT_RecordForGroups () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
  std::string                     __aida_type_name__ () const	{ return "BseTest::RecordForGroups"; }
  const std::vector<const char*>& __aida_aux_data__ () const;
  Rapicorn::Aida::Any           __aida_to_any__   () { return Rapicorn::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Rapicorn::Aida::Any &any) { return Rapicorn::any_to_visitable (any, *this); }
  bool                          operator==  (const SrvT_RecordForGroups &other) const;
  bool                          operator!=  (const SrvT_RecordForGroups &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor _visitor_)
  {
    _visitor_ (i, "i");
    _visitor_ (ratio, "ratio");
    _visitor_ (ordinary_bool, "ordinary_bool");
    _visitor_ (threshold1, "threshold1");
    _visitor_ (threshold2, "threshold2");
  }
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const SrvT_RecordForGroups&);
void operator>>= (Rapicorn::Aida::ProtoReader&, SrvT_RecordForGroups&);

class I_SoundModuleIface;
typedef std::shared_ptr<I_SoundModuleIface> I_SoundModuleIfaceP;
typedef std::weak_ptr  <I_SoundModuleIface> I_SoundModuleIfaceW;

/** @interface SoundModule
 * See also the corresponding C++ servant class I_SoundModuleIface. */
/// See also the corresponding IDL class SoundModule.
class I_SoundModuleIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SoundModuleIface ();
  virtual /*Des*/                       ~I_SoundModuleIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "BseTest::SoundModule"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::ProtoMsg&, const I_SoundModuleIfaceP&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_SoundModuleIface*&);
void operator>>= (Rapicorn::Aida::ProtoReader&, I_SoundModuleIfaceP&);
} // BseTest

#define __testpass_idl_INTERFACE_LIST \
	  __testpass_idl_INTERFACE_NAME (MandatoryNamespace::FirstInterface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::UIWidgetArea) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::Parent) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::Child) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::Descendant) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::GrandChild) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::QuickIface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::MethodTestInterface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::SignalTestInterface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::ChildInheritingSignals) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::AnotherChild) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::PropertyTester) \
	  __testpass_idl_INTERFACE_NAME (RapicornAidaTest::ButtonArea) \
	  __testpass_idl_INTERFACE_NAME (RapicornAidaTest::PureMethods) \
	  __testpass_idl_INTERFACE_NAME (Other::NameTests) \
	  __testpass_idl_INTERFACE_NAME (BseTest::Compressor) \
	  __testpass_idl_INTERFACE_NAME (BseTest::SoundModule)

// --- Interface Skeletons ---
#endif /* __SRVT____testpass_idl */
