// --- Generated by AidaCxxStub ---

// --- ClientHH Boilerplate ---
#include <rapicorn-core.hh>

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __AIDA_GENERIC_CC_BOILERPLATE__
#define __AIDA_GENERIC_CC_BOILERPLATE__

#define AIDA_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("AIDA-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Rapicorn::Aida::uint64_t;

static __attribute__ ((__format__ (__printf__, 1, 2), unused))
Rapicorn::Aida::FieldBuffer* aida$_error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  Rapicorn::Aida::error_vprintf (format, args);
  va_end (args);
  return NULL;
}

} // Anonymous
#endif // __AIDA_GENERIC_CC_BOILERPLATE__


#ifndef AIDA_CONNECTION
#define AIDA_CONNECTION()       (*(Rapicorn::Aida::ClientConnection*)NULL)
template<class C> C*     connection_id2context (Rapicorn::Aida::uint64_t oid) { return (C*) NULL; }
#endif // !AIDA_CONNECTION
namespace { // Anon
namespace __AIDA_Local__ {
  inline ptrdiff_t       smh2id (const Rapicorn::Aida::SmartHandle &h) { return h._rpc_id(); }
} } // Anon::__AIDA_Local__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); }

enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); }

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); }

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); }

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); }

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); }

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4a  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); }

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4b  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); }

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); }

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4d  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); }

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ExtensiveEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); }

/** @interface FirstInterface
 * See also the corresponding C++ class FirstInterfaceHandle (client side). */
/// See also the corresponding IDL class FirstInterface.
class FirstInterfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static FirstInterfaceHandle   _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static FirstInterfaceHandle   downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      FirstInterfaceHandle ();
  void                          void_func            ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const FirstInterfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, FirstInterfaceHandle&);

/** @interface XFooRecord
 * See also the corresponding C++ class XFooRecordStruct (client side). */
/// See also the corresponding IDL class XFooRecord.
struct XFooRecordStruct
{
  bool                          single_bool;
  int                           single_num;
  Rapicorn::Aida::int64_t       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  FirstInterfaceHandle          iface1;
  FirstInterfaceHandle          iface2;
  FirstInterfaceHandle          iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  inline                        XFooRecordStruct () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooRecordStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooRecordStruct&);

/** @interface XFooSequence
 * See also the corresponding C++ class XFooSequenceStruct (client side). */
/// See also the corresponding IDL class XFooSequence.
struct XFooSequenceStruct : public std::vector<bool>
{
  typedef std::vector<bool> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooSequenceStruct&);

/** @interface IntSequence
 * See also the corresponding C++ class IntSequenceStruct (client side). */
/// See also the corresponding IDL class IntSequence.
struct IntSequenceStruct : public std::vector<int>
{
  typedef std::vector<int> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const IntSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, IntSequenceStruct&);

/** @interface FloatSequence
 * See also the corresponding C++ class FloatSequenceStruct (client side). */
/// See also the corresponding IDL class FloatSequence.
struct FloatSequenceStruct : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const FloatSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, FloatSequenceStruct&);

/** @interface StringSequence
 * See also the corresponding C++ class StringSequenceStruct (client side). */
/// See also the corresponding IDL class StringSequence.
struct StringSequenceStruct : public std::vector<std::string>
{
  typedef std::vector<std::string> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const StringSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, StringSequenceStruct&);

/** @interface ExtensiveEnumSequence
 * See also the corresponding C++ class ExtensiveEnumSequenceStruct (client side). */
/// See also the corresponding IDL class ExtensiveEnumSequence.
struct ExtensiveEnumSequenceStruct : public std::vector<ExtensiveEnum>
{
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ExtensiveEnumSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, ExtensiveEnumSequenceStruct&);

/** @interface RecordSequence
 * See also the corresponding C++ class RecordSequenceStruct (client side). */
/// See also the corresponding IDL class RecordSequence.
struct RecordSequenceStruct : public std::vector<XFooRecordStruct>
{
  typedef std::vector<XFooRecordStruct> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordSequenceStruct&);

/** @interface SequenceSequence
 * See also the corresponding C++ class SequenceSequenceStruct (client side). */
/// See also the corresponding IDL class SequenceSequence.
struct SequenceSequenceStruct : public std::vector<IntSequenceStruct>
{
  typedef std::vector<IntSequenceStruct> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SequenceSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, SequenceSequenceStruct&);

/** @interface InterfaceSequence
 * See also the corresponding C++ class InterfaceSequenceStruct (client side). */
/// See also the corresponding IDL class InterfaceSequence.
struct InterfaceSequenceStruct : public std::vector<FirstInterfaceHandle>
{
  typedef std::vector<FirstInterfaceHandle> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InterfaceSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, InterfaceSequenceStruct&);

/** @interface AnySequence
 * See also the corresponding C++ class AnySequenceStruct (client side). */
/// See also the corresponding IDL class AnySequence.
struct AnySequenceStruct : public std::vector<Rapicorn::Aida::Any>
{
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const AnySequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, AnySequenceStruct&);

/** @interface NestedTypesRec
 * See also the corresponding C++ class NestedTypesRecStruct (client side). */
/// See also the corresponding IDL class NestedTypesRec.
struct NestedTypesRecStruct
{
  XFooRecordStruct              rec;
  XFooSequenceStruct            seq;
  inline                        NestedTypesRecStruct () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesRecStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesRecStruct&);

/** @interface NestedTypesSeq
 * See also the corresponding C++ class NestedTypesSeqStruct (client side). */
/// See also the corresponding IDL class NestedTypesSeq.
struct NestedTypesSeqStruct : public std::vector<NestedTypesRecStruct>
{
  typedef std::vector<NestedTypesRecStruct> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesSeqStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesSeqStruct&);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64_t AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecordStruct AliasRecord;

typedef XFooSequenceStruct AliasSequence;

typedef ExtensiveEnum AliasEnum;

/** @interface NewRecord
 * See also the corresponding C++ class NewRecordStruct (client side). */
/// See also the corresponding IDL class NewRecord.
struct NewRecordStruct
{
  int                           i;
  Enum1                         enum1;
  XFooSequenceStruct            xfs;
  NestedTypesRecStruct          ntr;
  inline                        NewRecordStruct () { i = 0; enum1 = Enum1 (0); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NewRecordStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, NewRecordStruct&);

namespace Inner {

/** @interface InnerRecord
 * See also the corresponding C++ class InnerRecordStruct (client side). */
/// See also the corresponding IDL class InnerRecord.
struct InnerRecordStruct
{
  int                           x;
  int                           y;
  NewRecordStruct               rec;
  inline                        InnerRecordStruct () { x = 0; y = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InnerRecordStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, InnerRecordStruct&);
} // Inner

/** @interface Refer2Inner
 * See also the corresponding C++ class Refer2InnerStruct (client side). */
/// See also the corresponding IDL class Refer2Inner.
struct Refer2InnerStruct
{
  Inner::InnerRecordStruct      r;
  inline                        Refer2InnerStruct () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const Refer2InnerStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, Refer2InnerStruct&);
} // MandatoryNamespace

namespace OtherNamespace {

/** @interface SomeRecord
 * See also the corresponding C++ class SomeRecordStruct (client side). */
/// See also the corresponding IDL class SomeRecord.
struct SomeRecordStruct
{
  MandatoryNamespace::NewRecordStruct r1;
  MandatoryNamespace::NewRecordStruct r2;
  MandatoryNamespace::Inner::InnerRecordStruct r3;
  MandatoryNamespace::Inner::InnerRecordStruct r4;
  inline                        SomeRecordStruct () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SomeRecordStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, SomeRecordStruct&);
} // OtherNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64_t Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ class UIWidgetAreaHandle (client side). */
/// See also the corresponding IDL class UIWidgetArea.
class UIWidgetAreaHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static UIWidgetAreaHandle     _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static UIWidgetAreaHandle     downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      UIWidgetAreaHandle ();
  bool                          dummy    () const;
  void                          dummy    (bool);
  std::string                   on_click () const;
  void                          on_click (const std::string&);
  typedef void                  Callback_void_signal ();
  Rapicorn::Aida::uint64_t      sig_void_signal (const std::function<Callback_void_signal> &callback);
  bool                          sig_void_signal (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef double                Callback_sample_signal (UIWidgetAreaHandle &ba1, int someint);
  Rapicorn::Aida::uint64_t      sig_sample_signal (const std::function<Callback_sample_signal> &callback);
  bool                          sig_sample_signal (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  double                        simple_method      ();
  double                        single_arg         (int n);
  double                        single_arg2        (int n = 5);
  double                        two_args           (int n,
                                                    double r);
  double                        two_args2          (int n = 6,
                                                    double r = 7.7);
  double                        multi_args         (bool b,
                                                    Rapicorn::Aida::int64_t n,
                                                    double r,
                                                    int i,
                                                    const std::string &s = "String ding",
                                                    double y = 5);
  double                        self_method        (UIWidgetAreaHandle &ba1,
                                                    UIWidgetAreaHandle &ba2);
  void                          void_method        ();
  std::string                   on_click2out       ();
  void                          on_click2in        (const std::string &command);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const UIWidgetAreaHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, UIWidgetAreaHandle&);

/** @interface Parent
 * See also the corresponding C++ class ParentHandle (client side). */
/// See also the corresponding IDL class Parent.
class ParentHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static ParentHandle           _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static ParentHandle           downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      ParentHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ParentHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ParentHandle&);

/** @interface Child
 * See also the corresponding C++ class ChildHandle (client side). */
/// See also the corresponding IDL class Child.
class ChildHandle : public ParentHandle
{
  static ChildHandle            _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static ChildHandle            downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      ChildHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ChildHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ChildHandle&);

/** @interface Descendant
 * See also the corresponding C++ class DescendantHandle (client side). */
/// See also the corresponding IDL class Descendant.
class DescendantHandle : public ChildHandle
{
  static DescendantHandle       _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static DescendantHandle       downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      DescendantHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const DescendantHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, DescendantHandle&);

/** @interface GrandChild
 * See also the corresponding C++ class GrandChildHandle (client side). */
/// See also the corresponding IDL class GrandChild.
class GrandChildHandle : public DescendantHandle
{
  static GrandChildHandle       _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static GrandChildHandle       downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      GrandChildHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const GrandChildHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, GrandChildHandle&);

enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  QuickEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); }

/** @interface QuickRecord
 * See also the corresponding C++ class QuickRecordStruct (client side). */
/// See also the corresponding IDL class QuickRecord.
struct QuickRecordStruct
{
  int                           int1;
  int                           int2;
  inline                        QuickRecordStruct () { int1 = 0; int2 = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickRecordStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickRecordStruct&);

/** @interface QuickSequence
 * See also the corresponding C++ class QuickSequenceStruct (client side). */
/// See also the corresponding IDL class QuickSequence.
struct QuickSequenceStruct : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickSequenceStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickSequenceStruct&);

/** @interface QuickIface
 * See also the corresponding C++ class QuickIfaceHandle (client side). */
/// See also the corresponding IDL class QuickIface.
class QuickIfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static QuickIfaceHandle       _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static QuickIfaceHandle       downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      QuickIfaceHandle ();
  void                          simple_function  (int i = 9);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickIfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickIfaceHandle&);

/** @interface MethodTestInterface
 * See also the corresponding C++ class MethodTestInterfaceHandle (client side). */
/// See also the corresponding IDL class MethodTestInterface.
class MethodTestInterfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static MethodTestInterfaceHandle _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static MethodTestInterfaceHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      MethodTestInterfaceHandle ();
  void                          method_with_void          ();
  bool                          method_with_bools         (bool input,
                                                           bool optval = 0);
  int                           method_with_ints32        (int input,
                                                           int optval = -2);
  Rapicorn::Aida::int64_t       method_with_ints64        (Rapicorn::Aida::int64_t input,
                                                           Rapicorn::Aida::int64_t optval = 576460752303423488);
  double                        method_with_floats        (double input,
                                                           double optval = 309.9);
  std::string                   method_with_string        (const std::string &input,
                                                           const std::string &optval = "default");
  QuickEnum                     method_with_enum          (QuickEnum input,
                                                           QuickEnum optval = QuickEnum (0));
  QuickRecordStruct             method_with_record        (const QuickRecordStruct &input,
                                                           const QuickRecordStruct &optval = QuickRecordStruct());
  QuickSequenceStruct           method_with_sequence      (const QuickSequenceStruct &input,
                                                           const QuickSequenceStruct &optval = QuickSequenceStruct());
  GrandChildHandle              method_with_interface     (GrandChildHandle &input,
                                                           GrandChildHandle &optval = *(GrandChildHandle*) NULL);
  Rapicorn::Aida::Any           method_with_anys          (const Rapicorn::Aida::Any &input,
                                                           const Rapicorn::Aida::Any &optval);
  QuickIfaceHandle              method_with_quickiface    (QuickIfaceHandle &input,
                                                           QuickIfaceHandle &iface0 = *(QuickIfaceHandle*) NULL);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const MethodTestInterfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, MethodTestInterfaceHandle&);

/** @interface SignalTestInterface
 * See also the corresponding C++ class SignalTestInterfaceHandle (client side). */
/// See also the corresponding IDL class SignalTestInterface.
class SignalTestInterfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static SignalTestInterfaceHandle _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static SignalTestInterfaceHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      SignalTestInterfaceHandle ();
  typedef void                  Callback_void_result ();
  Rapicorn::Aida::uint64_t      sig_void_result (const std::function<Callback_void_result> &callback);
  bool                          sig_void_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef bool                  Callback_bool_result ();
  Rapicorn::Aida::uint64_t      sig_bool_result (const std::function<Callback_bool_result> &callback);
  bool                          sig_bool_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef int                   Callback_int32_result ();
  Rapicorn::Aida::uint64_t      sig_int32_result (const std::function<Callback_int32_result> &callback);
  bool                          sig_int32_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef Rapicorn::Aida::int64_t Callback_int64_result ();
  Rapicorn::Aida::uint64_t      sig_int64_result (const std::function<Callback_int64_result> &callback);
  bool                          sig_int64_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef double                Callback_float64_result ();
  Rapicorn::Aida::uint64_t      sig_float64_result (const std::function<Callback_float64_result> &callback);
  bool                          sig_float64_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef std::string           Callback_string_result ();
  Rapicorn::Aida::uint64_t      sig_string_result (const std::function<Callback_string_result> &callback);
  bool                          sig_string_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef QuickEnum             Callback_enum_result ();
  Rapicorn::Aida::uint64_t      sig_enum_result (const std::function<Callback_enum_result> &callback);
  bool                          sig_enum_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef QuickRecordStruct     Callback_record_result ();
  Rapicorn::Aida::uint64_t      sig_record_result (const std::function<Callback_record_result> &callback);
  bool                          sig_record_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef QuickSequenceStruct   Callback_sequence_result ();
  Rapicorn::Aida::uint64_t      sig_sequence_result (const std::function<Callback_sequence_result> &callback);
  bool                          sig_sequence_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef GrandChildHandle      Callback_interface_result ();
  Rapicorn::Aida::uint64_t      sig_interface_result (const std::function<Callback_interface_result> &callback);
  bool                          sig_interface_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef Rapicorn::Aida::Any   Callback_any_result ();
  Rapicorn::Aida::uint64_t      sig_any_result (const std::function<Callback_any_result> &callback);
  bool                          sig_any_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef SignalTestInterfaceHandle Callback_self_result ();
  Rapicorn::Aida::uint64_t      sig_self_result (const std::function<Callback_self_result> &callback);
  bool                          sig_self_result (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_void_arg ();
  Rapicorn::Aida::uint64_t      sig_void_arg (const std::function<Callback_void_arg> &callback);
  bool                          sig_void_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_bool_arg (bool b);
  Rapicorn::Aida::uint64_t      sig_bool_arg (const std::function<Callback_bool_arg> &callback);
  bool                          sig_bool_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_int32_arg (int i);
  Rapicorn::Aida::uint64_t      sig_int32_arg (const std::function<Callback_int32_arg> &callback);
  bool                          sig_int32_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_int64_arg (Rapicorn::Aida::int64_t i);
  Rapicorn::Aida::uint64_t      sig_int64_arg (const std::function<Callback_int64_arg> &callback);
  bool                          sig_int64_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_float64_arg (double f);
  Rapicorn::Aida::uint64_t      sig_float64_arg (const std::function<Callback_float64_arg> &callback);
  bool                          sig_float64_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_string_arg (const std::string &s);
  Rapicorn::Aida::uint64_t      sig_string_arg (const std::function<Callback_string_arg> &callback);
  bool                          sig_string_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_enum_arg (QuickEnum e);
  Rapicorn::Aida::uint64_t      sig_enum_arg (const std::function<Callback_enum_arg> &callback);
  bool                          sig_enum_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_record_arg (const QuickRecordStruct &r);
  Rapicorn::Aida::uint64_t      sig_record_arg (const std::function<Callback_record_arg> &callback);
  bool                          sig_record_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_sequence_arg (const QuickSequenceStruct &s);
  Rapicorn::Aida::uint64_t      sig_sequence_arg (const std::function<Callback_sequence_arg> &callback);
  bool                          sig_sequence_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_interface_arg (GrandChildHandle &i);
  Rapicorn::Aida::uint64_t      sig_interface_arg (const std::function<Callback_interface_arg> &callback);
  bool                          sig_interface_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_any_arg (const Rapicorn::Aida::Any &a);
  Rapicorn::Aida::uint64_t      sig_any_arg (const std::function<Callback_any_arg> &callback);
  bool                          sig_any_arg (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_self_args (SignalTestInterfaceHandle &self_);
  Rapicorn::Aida::uint64_t      sig_self_args (const std::function<Callback_self_args> &callback);
  bool                          sig_self_args (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SignalTestInterfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, SignalTestInterfaceHandle&);

/** @interface ChildInheritingSignals
 * See also the corresponding C++ class ChildInheritingSignalsHandle (client side). */
/// See also the corresponding IDL class ChildInheritingSignals.
class ChildInheritingSignalsHandle : public SignalTestInterfaceHandle
{
  static ChildInheritingSignalsHandle _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static ChildInheritingSignalsHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      ChildInheritingSignalsHandle ();
  typedef void                  Callback_child_signal (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const QuickRecordStruct &r, const QuickSequenceStruct &s);
  Rapicorn::Aida::uint64_t      sig_child_signal (const std::function<Callback_child_signal> &callback);
  bool                          sig_child_signal (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ChildInheritingSignalsHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ChildInheritingSignalsHandle&);

/** @interface AnotherChild
 * See also the corresponding C++ class AnotherChildHandle (client side). */
/// See also the corresponding IDL class AnotherChild.
class AnotherChildHandle : public SignalTestInterfaceHandle
{
  static AnotherChildHandle     _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static AnotherChildHandle     downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      AnotherChildHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const AnotherChildHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, AnotherChildHandle&);

/** @interface PropertyTester
 * See also the corresponding C++ class PropertyTesterHandle (client side). */
/// See also the corresponding IDL class PropertyTester.
class PropertyTesterHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static PropertyTesterHandle   _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static PropertyTesterHandle   downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      PropertyTesterHandle ();
  bool                          bool_prop      () const;
  void                          bool_prop      (bool);
  int                           int32_prop     () const;
  void                          int32_prop     (int);
  Rapicorn::Aida::int64_t       int64_prop     () const;
  void                          int64_prop     (Rapicorn::Aida::int64_t);
  double                        float64_prop   () const;
  void                          float64_prop   (double);
  std::string                   string_prop    () const;
  void                          string_prop    (const std::string&);
  QuickEnum                     enum_prop      () const;
  void                          enum_prop      (QuickEnum);
  QuickRecordStruct             record_prop    () const;
  void                          record_prop    (const QuickRecordStruct&);
  QuickSequenceStruct           sequence_prop  () const;
  void                          sequence_prop  (const QuickSequenceStruct&);
  GrandChildHandle              interface_prop () const;
  void                          interface_prop (GrandChildHandle);
  PropertyTesterHandle          self_prop      () const;
  void                          self_prop      (PropertyTesterHandle);
  Rapicorn::Aida::Any           any_prop       () const;
  void                          any_prop       (const Rapicorn::Aida::Any&);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const PropertyTesterHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, PropertyTesterHandle&);
} // InterfaceTests

namespace RapicornAidaTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ClickType  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); }

/** @interface ButtonArea
 * See also the corresponding C++ class ButtonAreaHandle (client side). */
/// See also the corresponding IDL class ButtonArea.
class ButtonAreaHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static ButtonAreaHandle       _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static ButtonAreaHandle       downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      ButtonAreaHandle ();
  std::string                   on_click   () const;
  void                          on_click   (const std::string&);
  std::string                   on_click2  () const;
  void                          on_click2  (const std::string&);
  std::string                   on_click3  () const;
  void                          on_click3  (const std::string&);
  ClickType                     click_type () const;
  void                          click_type (ClickType);
  typedef bool                  Callback_check_activate ();
  Rapicorn::Aida::uint64_t      sig_check_activate (const std::function<Callback_check_activate> &callback);
  bool                          sig_check_activate (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
  typedef void                  Callback_activate ();
  Rapicorn::Aida::uint64_t      sig_activate (const std::function<Callback_activate> &callback);
  bool                          sig_activate (Rapicorn::Aida::uint64_t signal_id); ///< Disconnect Signal
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ButtonAreaHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ButtonAreaHandle&);

class PureMethodsHandle;

/** @interface PureMethods
 * See also the corresponding C++ class PureMethodsHandle (client side). */
/// See also the corresponding IDL class PureMethods.
class PureMethodsHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static PureMethodsHandle      _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static PureMethodsHandle      downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      PureMethodsHandle ();
  int                           pure_method       (double f);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const PureMethodsHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, PureMethodsHandle&);

enum MathExpressions {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  MathExpressions  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, MathExpressions &e) { e = MathExpressions (frr.pop_evalue()); }
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ class NameTestsHandle (client side). */
/// See also the corresponding IDL class NameTests.
class NameTestsHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static NameTestsHandle        _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static NameTestsHandle        downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      NameTestsHandle ();
  void                          args_from_other_namespace (const InterfaceTests::QuickRecordStruct &qr,
                                                           RapicornAidaTest::ClickType qe,
                                                           const OtherNamespace::SomeRecordStruct &sr);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NameTestsHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, NameTestsHandle&);
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ class CompressorHandle (client side). */
/// See also the corresponding IDL class Compressor.
class CompressorHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static CompressorHandle       _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static CompressorHandle       downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      CompressorHandle ();
  double                        threshold () const;
  void                          threshold (double);
  double                        ratio     () const;
  void                          ratio     (double);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const CompressorHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, CompressorHandle&);

/** @interface RecordForGroups
 * See also the corresponding C++ class RecordForGroupsStruct (client side). */
/// See also the corresponding IDL class RecordForGroups.
struct RecordForGroupsStruct
{
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  inline                        RecordForGroupsStruct () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordForGroupsStruct&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordForGroupsStruct&);

/** @interface SoundModule
 * See also the corresponding C++ class SoundModuleHandle (client side). */
/// See also the corresponding IDL class SoundModule.
class SoundModuleHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static SoundModuleHandle      _cast (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& _type ();
protected:
public:
  template<class C>
  static SoundModuleHandle      downcast (C c) { return _cast (c, c.cast_types()); }
  const Rapicorn::Aida::TypeHashList& cast_types ();
  explicit                      SoundModuleHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SoundModuleHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, SoundModuleHandle&);
} // BseTest

namespace Rapicorn {

namespace Aida {

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4a>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4a"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4b>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4b"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4d>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4d"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::ExtensiveEnum>() { return EnumInfo::from_nsid ("MandatoryNamespace", "ExtensiveEnum"); }

template<> inline EnumInfo enum_info<InterfaceTests::QuickEnum>() { return EnumInfo::from_nsid ("InterfaceTests", "QuickEnum"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::ClickType>() { return EnumInfo::from_nsid ("RapicornAidaTest", "ClickType"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::MathExpressions>() { return EnumInfo::from_nsid ("RapicornAidaTest", "MathExpressions"); }
} // Aida
} // Rapicorn

// --- Implementations ---

namespace MandatoryNamespace {

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum1_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E1_A),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum1", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum1c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E1C_A),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum1c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum2_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2_B),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum2", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum2c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2C_B),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum2c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum3_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_C),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum3", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum3c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_C),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum3c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4a_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4a", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4b_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4b", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4d_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4d", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__ExtensiveEnum_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (V1a),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V1b),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V3),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V4),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V5),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V6),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V7),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V8),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V9),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V10),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V11),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V12),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V13),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V14),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V15),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V16),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V17),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V18),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V20),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V21),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V22),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V23),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V24),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V25),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V26),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V27),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V28),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V30),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V31),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V32),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V33),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V34),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V35),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V36),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "ExtensiveEnum", enum_values);
});

// === FirstInterface ===
struct FirstInterface_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (FirstInterface_Context$);
public:
  struct SmartHandle$ : public FirstInterfaceHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  FirstInterface_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
FirstInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3dacdb0c72319c6dULL, 0xd0a4dababf07cfb8ULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
FirstInterfaceHandle::FirstInterfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const FirstInterfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, FirstInterfaceHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<FirstInterface_Context$> (ipcid)->handle$ : FirstInterfaceHandle();
}
const Rapicorn::Aida::TypeHash&
FirstInterfaceHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x04be3719c81a379bULL, 0x1079454a90442f2cULL);
  return type_hash;
}
FirstInterfaceHandle
FirstInterfaceHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<FirstInterface_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return FirstInterfaceHandle();
}
const Rapicorn::Aida::TypeHashList&
FirstInterfaceHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<FirstInterface_Context$> (ipcid)->list_types();
}
void
FirstInterfaceHandle::void_func ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x209463c55becedadULL, 0x39ddfcb9aadc3c74ULL); // msgid
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const XFooRecordStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (18);
  fb <<= self.single_bool;
  fb <<= self.single_num;
  fb <<= self.num64;
  fb <<= self.single_float;
  fb <<= self.single_string;
  fb <<= self.sibling1;
  fb <<= self.sibling2;
  fb <<= self.multi1;
  fb <<= self.multi2;
  fb <<= self.multi3;
  fb <<= self.multi4;
  fb <<= self.enum_field;
  fb <<= self.iface1;
  fb <<= self.iface2;
  fb <<= self.iface3;
  fb <<= self.any1;
  fb <<= self.any2;
  fb <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, XFooRecordStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 18) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.num64;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const XFooSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, XFooSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
XFooSequenceStruct::reference
XFooSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const IntSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, IntSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
IntSequenceStruct::reference
IntSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const FloatSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, FloatSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
FloatSequenceStruct::reference
FloatSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const StringSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, StringSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
StringSequenceStruct::reference
StringSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const ExtensiveEnumSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, ExtensiveEnumSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
ExtensiveEnumSequenceStruct::reference
ExtensiveEnumSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const RecordSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, RecordSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
RecordSequenceStruct::reference
RecordSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SequenceSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SequenceSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SequenceSequenceStruct::reference
SequenceSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const InterfaceSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, InterfaceSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
InterfaceSequenceStruct::reference
InterfaceSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const AnySequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, AnySequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
AnySequenceStruct::reference
AnySequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NestedTypesRecStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.rec;
  fb <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NestedTypesRecStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NestedTypesSeqStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NestedTypesSeqStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
NestedTypesSeqStruct::reference
NestedTypesSeqStruct::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NewRecordStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.i;
  fb <<= self.enum1;
  fb <<= self.xfs;
  fb <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NewRecordStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const InnerRecordStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (3);
  fb <<= self.x;
  fb <<= self.y;
  fb <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, InnerRecordStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const Refer2InnerStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (1);
  fb <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, Refer2InnerStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SomeRecordStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.r1;
  fb <<= self.r2;
  fb <<= self.r3;
  fb <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SomeRecordStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace InterfaceTests {

// === UIWidgetArea ===
struct UIWidgetArea_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (UIWidgetArea_Context$);
public:
  struct SmartHandle$ : public UIWidgetAreaHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  UIWidgetArea_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
UIWidgetArea_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3ced16bab1c08fe8ULL, 0xd1fa4cb922b6d7deULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__UIWidgetAreaHandle__void_signal (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<UIWidgetAreaHandle::Callback_void_signal>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
UIWidgetAreaHandle::sig_void_signal (const std::function<Callback_void_signal> &func)
{
  void *fptr = new std::function<Callback_void_signal> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x52ef738c2571d0f2ULL, 0x05b653adf0a80acfULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__UIWidgetAreaHandle__void_signal, fptr);
  return id;
}
bool
UIWidgetAreaHandle::sig_void_signal (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__UIWidgetAreaHandle__sample_signal (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<UIWidgetAreaHandle::Callback_sample_signal>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
UIWidgetAreaHandle::sig_sample_signal (const std::function<Callback_sample_signal> &func)
{
  void *fptr = new std::function<Callback_sample_signal> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x506409a3044ac65eULL, 0xda804abb85f8c1e8ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__UIWidgetAreaHandle__sample_signal, fptr);
  return id;
}
bool
UIWidgetAreaHandle::sig_sample_signal (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
UIWidgetAreaHandle::UIWidgetAreaHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const UIWidgetAreaHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, UIWidgetAreaHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<UIWidgetArea_Context$> (ipcid)->handle$ : UIWidgetAreaHandle();
}
const Rapicorn::Aida::TypeHash&
UIWidgetAreaHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0c1b9195fa9a5a6cULL, 0xc1f636e721317b86ULL);
  return type_hash;
}
UIWidgetAreaHandle
UIWidgetAreaHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<UIWidgetArea_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return UIWidgetAreaHandle();
}
const Rapicorn::Aida::TypeHashList&
UIWidgetAreaHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<UIWidgetArea_Context$> (ipcid)->list_types();
}
bool
UIWidgetAreaHandle::dummy () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x311213c7f9f683fbULL, 0x5ce277b1d4ad5f84ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::dummy (bool value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2cd4545fdbf8e1bcULL, 0xf980e99fa9f34ab1ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
UIWidgetAreaHandle::on_click () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x389d73bb93692d3eULL, 0xe60676c6ab0ecd60ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::on_click (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x201f34e07478bbcbULL, 0x7fa4069706e6233aULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
UIWidgetAreaHandle::simple_method ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x3a2f8d1c42ac1785ULL, 0x58b20fa269c0bd5eULL); // msgid
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::single_arg (int arg_n)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3ea3da9f2d46a894ULL, 0xa37baf774b855c65ULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::single_arg2 (int arg_n)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x323870aec608428aULL, 0x3e4eb826e4565354ULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::two_args (int arg_n,
                              double arg_r)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x372d3445333b29d9ULL, 0x2a1b6a54e409ca63ULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fb <<= arg_r;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::two_args2 (int arg_n,
                               double arg_r)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3a5296dee6dca6f6ULL, 0xbe00f1270b1a7a1cULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fb <<= arg_r;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::multi_args (bool arg_b,
                                Rapicorn::Aida::int64_t arg_n,
                                double arg_r,
                                int arg_i,
                                const std::string &arg_s,
                                double arg_y)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 6), *fr = NULL;
  fb.add_msgid (0x3da25289fcf7fe26ULL, 0xf2dfa2d031dd302cULL); // msgid
  fb <<= (*this);
  fb <<= arg_b;
  fb <<= arg_n;
  fb <<= arg_r;
  fb <<= arg_i;
  fb <<= arg_s;
  fb <<= arg_y;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::self_method (UIWidgetAreaHandle &arg_ba1,
                                 UIWidgetAreaHandle &arg_ba2)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b4bb0d6b3f38abdULL, 0x80e1a7b9347c576aULL); // msgid
  fb <<= (*this);
  fb <<= arg_ba1;
  fb <<= arg_ba2;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::void_method ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x2e02c52c84773703ULL, 0x00027e452edb615cULL); // msgid
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
std::string
UIWidgetAreaHandle::on_click2out ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x3550e7348466c129ULL, 0x1ea5baf75297246fULL); // msgid
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::on_click2in (const std::string &arg_command)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x24ee88e59b05bae4ULL, 0x879ebaad31e6d20eULL); // msgid
  fb <<= (*this);
  fb <<= arg_command;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}

// === Parent ===
struct Parent_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (Parent_Context$);
public:
  struct SmartHandle$ : public ParentHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  Parent_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
Parent_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x364b25c79aef2195ULL, 0x61e123d5c1b02ffeULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
ParentHandle::ParentHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ParentHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ParentHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<Parent_Context$> (ipcid)->handle$ : ParentHandle();
}
const Rapicorn::Aida::TypeHash&
ParentHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL);
  return type_hash;
}
ParentHandle
ParentHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Parent_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return ParentHandle();
}
const Rapicorn::Aida::TypeHashList&
ParentHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Parent_Context$> (ipcid)->list_types();
}

// === Child ===
struct Child_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (Child_Context$);
public:
  struct SmartHandle$ : public ChildHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  Child_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
Child_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3c8323457768deefULL, 0x3d61b2123c42c46bULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
ChildHandle::ChildHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ChildHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ChildHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<Child_Context$> (ipcid)->handle$ : ChildHandle();
}
const Rapicorn::Aida::TypeHash&
ChildHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0a44a1b5cf26cfc0ULL, 0xcd6e05d08ba2667eULL);
  return type_hash;
}
ChildHandle
ChildHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Child_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return ChildHandle();
}
const Rapicorn::Aida::TypeHashList&
ChildHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Child_Context$> (ipcid)->list_types();
}

// === Descendant ===
struct Descendant_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (Descendant_Context$);
public:
  struct SmartHandle$ : public DescendantHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  Descendant_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
Descendant_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x32d59697075869a1ULL, 0x9f10f279be69b4e2ULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
DescendantHandle::DescendantHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const DescendantHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, DescendantHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<Descendant_Context$> (ipcid)->handle$ : DescendantHandle();
}
const Rapicorn::Aida::TypeHash&
DescendantHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0980fc7a8521c350ULL, 0x641568ba1f461de2ULL);
  return type_hash;
}
DescendantHandle
DescendantHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Descendant_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return DescendantHandle();
}
const Rapicorn::Aida::TypeHashList&
DescendantHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Descendant_Context$> (ipcid)->list_types();
}

// === GrandChild ===
struct GrandChild_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (GrandChild_Context$);
public:
  struct SmartHandle$ : public GrandChildHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  GrandChild_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
GrandChild_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x320a324ec480c060ULL, 0x86f1af86bd39afc2ULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
GrandChildHandle::GrandChildHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const GrandChildHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, GrandChildHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<GrandChild_Context$> (ipcid)->handle$ : GrandChildHandle();
}
const Rapicorn::Aida::TypeHash&
GrandChildHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x001a87e60ed9bd66ULL, 0xfff1a96d7bab9cd9ULL);
  return type_hash;
}
GrandChildHandle
GrandChildHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<GrandChild_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return GrandChildHandle();
}
const Rapicorn::Aida::TypeHashList&
GrandChildHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<GrandChild_Context$> (ipcid)->list_types();
}

static Rapicorn::Init _Rapicorn_Aida__INIT__QuickEnum_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (ZERO),
  };
  Rapicorn::Aida::EnumInfo::enlist ("InterfaceTests", "QuickEnum", enum_values);
});
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const QuickRecordStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.int1;
  fb <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, QuickRecordStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const QuickSequenceStruct &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, QuickSequenceStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
QuickSequenceStruct::reference
QuickSequenceStruct::append_back()
{
  resize (size() + 1);
  return back();
}

// === QuickIface ===
struct QuickIface_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (QuickIface_Context$);
public:
  struct SmartHandle$ : public QuickIfaceHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  QuickIface_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
QuickIface_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3bfdb92d01f4df38ULL, 0x09c3ffac5658b30eULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
QuickIfaceHandle::QuickIfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const QuickIfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, QuickIfaceHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<QuickIface_Context$> (ipcid)->handle$ : QuickIfaceHandle();
}
const Rapicorn::Aida::TypeHash&
QuickIfaceHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0ce40c896cfa0177ULL, 0x5ab6faf97ff6fed2ULL);
  return type_hash;
}
QuickIfaceHandle
QuickIfaceHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<QuickIface_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return QuickIfaceHandle();
}
const Rapicorn::Aida::TypeHashList&
QuickIfaceHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<QuickIface_Context$> (ipcid)->list_types();
}
void
QuickIfaceHandle::simple_function (int arg_i)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2b860359fa7e3dceULL, 0x198d5fe242474308ULL); // msgid
  fb <<= (*this);
  fb <<= arg_i;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}

// === MethodTestInterface ===
struct MethodTestInterface_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (MethodTestInterface_Context$);
public:
  struct SmartHandle$ : public MethodTestInterfaceHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  MethodTestInterface_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
MethodTestInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x38887fce34a056a1ULL, 0xdfafd7692069f2bcULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
MethodTestInterfaceHandle::MethodTestInterfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const MethodTestInterfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, MethodTestInterfaceHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<MethodTestInterface_Context$> (ipcid)->handle$ : MethodTestInterfaceHandle();
}
const Rapicorn::Aida::TypeHash&
MethodTestInterfaceHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x03befccd5d5ee8d5ULL, 0x7f1f65a869ad267fULL);
  return type_hash;
}
MethodTestInterfaceHandle
MethodTestInterfaceHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<MethodTestInterface_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return MethodTestInterfaceHandle();
}
const Rapicorn::Aida::TypeHashList&
MethodTestInterfaceHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<MethodTestInterface_Context$> (ipcid)->list_types();
}
void
MethodTestInterfaceHandle::method_with_void ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x281392e54343bee9ULL, 0x0dbeb788728dbff4ULL); // msgid
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
bool
MethodTestInterfaceHandle::method_with_bools (bool arg_input,
                                              bool arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b68546991e25342ULL, 0xa71399caec9ccfc7ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
int
MethodTestInterfaceHandle::method_with_ints32 (int arg_input,
                                               int arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3c7dd838073a8a92ULL, 0xddd57eef6f36ab11ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
Rapicorn::Aida::int64_t
MethodTestInterfaceHandle::method_with_ints64 (Rapicorn::Aida::int64_t arg_input,
                                               Rapicorn::Aida::int64_t arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x394bb1c2a7be91fbULL, 0x3f077bb42a25d6e4ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  Rapicorn::Aida::int64_t  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
MethodTestInterfaceHandle::method_with_floats (double arg_input,
                                               double arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x368776130b055120ULL, 0x64281c55fbfe5bb9ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
std::string
MethodTestInterfaceHandle::method_with_string (const std::string &arg_input,
                                               const std::string &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x378c9594060f2266ULL, 0x5331c53659132c99ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickEnum
MethodTestInterfaceHandle::method_with_enum (QuickEnum arg_input,
                                             QuickEnum arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x387f08a5c150e6a7ULL, 0x83c133fcd2be3200ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickRecordStruct
MethodTestInterfaceHandle::method_with_record (const QuickRecordStruct &arg_input,
                                               const QuickRecordStruct &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b59b493f287edf0ULL, 0x4771d353c78389d1ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecordStruct  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickSequenceStruct
MethodTestInterfaceHandle::method_with_sequence (const QuickSequenceStruct &arg_input,
                                                 const QuickSequenceStruct &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34c9e8a686a7f261ULL, 0x9af099b173ac979cULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequenceStruct  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
GrandChildHandle
MethodTestInterfaceHandle::method_with_interface (GrandChildHandle &arg_input,
                                                  GrandChildHandle &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34619983babcee5bULL, 0x9875f78f28f381b7ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  GrandChildHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
Rapicorn::Aida::Any
MethodTestInterfaceHandle::method_with_anys (const Rapicorn::Aida::Any &arg_input,
                                             const Rapicorn::Aida::Any &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x362c672843766d85ULL, 0x6ed30851db440471ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  Rapicorn::Aida::Any  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickIfaceHandle
MethodTestInterfaceHandle::method_with_quickiface (QuickIfaceHandle &arg_input,
                                                   QuickIfaceHandle &arg_iface0)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3a2ab33a8358edcbULL, 0x7c028db9464052a0ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_iface0;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickIfaceHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}

// === SignalTestInterface ===
struct SignalTestInterface_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (SignalTestInterface_Context$);
public:
  struct SmartHandle$ : public SignalTestInterfaceHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  SignalTestInterface_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
SignalTestInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3b8444b272305b05ULL, 0xeeb938b589d70b8cULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__void_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_void_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_void_result (const std::function<Callback_void_result> &func)
{
  void *fptr = new std::function<Callback_void_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x535d5e95471873b6ULL, 0x7a9f5692ce00e007ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__void_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_void_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__bool_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_bool_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_bool_result (const std::function<Callback_bool_result> &func)
{
  void *fptr = new std::function<Callback_bool_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x51ffffa2f8db1b1bULL, 0x3e01434baf49eceeULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__bool_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_bool_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__int32_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_int32_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_int32_result (const std::function<Callback_int32_result> &func)
{
  void *fptr = new std::function<Callback_int32_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x503a5722f565a9faULL, 0x0c5aed4d39b9ca12ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__int32_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_int32_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__int64_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_int64_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_int64_result (const std::function<Callback_int64_result> &func)
{
  void *fptr = new std::function<Callback_int64_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5670d5594a24b2d9ULL, 0x8ad93cc1a1e9bb50ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__int64_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_int64_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__float64_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_float64_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_float64_result (const std::function<Callback_float64_result> &func)
{
  void *fptr = new std::function<Callback_float64_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x51aee1ad06b0e2ffULL, 0x0a7f816f9bdaf008ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__float64_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_float64_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__string_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_string_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_string_result (const std::function<Callback_string_result> &func)
{
  void *fptr = new std::function<Callback_string_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5daa2a4439deab5fULL, 0xc0580f71a4d7d1d6ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__string_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_string_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__enum_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_enum_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_enum_result (const std::function<Callback_enum_result> &func)
{
  void *fptr = new std::function<Callback_enum_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x56fc6f3f4946e7b2ULL, 0x0fe0cc5f83d2ab84ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__enum_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_enum_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__record_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_record_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_record_result (const std::function<Callback_record_result> &func)
{
  void *fptr = new std::function<Callback_record_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x50b723665ed298a5ULL, 0x32aa063680a4e3c0ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__record_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_record_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__sequence_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_sequence_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_sequence_result (const std::function<Callback_sequence_result> &func)
{
  void *fptr = new std::function<Callback_sequence_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5ef00325dfcf4552ULL, 0x991130ecddd21730ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__sequence_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_sequence_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__interface_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_interface_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_interface_result (const std::function<Callback_interface_result> &func)
{
  void *fptr = new std::function<Callback_interface_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x58e8587c542d85ceULL, 0xe2b572e902c69f7cULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__interface_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_interface_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__any_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_any_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_any_result (const std::function<Callback_any_result> &func)
{
  void *fptr = new std::function<Callback_any_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5ae2293e0b4f9854ULL, 0xbb549e7d52c43e50ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__any_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_any_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__self_result (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_self_result>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_self_result (const std::function<Callback_self_result> &func)
{
  void *fptr = new std::function<Callback_self_result> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x59bb2da621bab28fULL, 0x32bc82e7eb9bc512ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__self_result, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_self_result (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__void_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_void_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_void_arg (const std::function<Callback_void_arg> &func)
{
  void *fptr = new std::function<Callback_void_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x583dc36c7785c7f3ULL, 0xb330cefa4e8247a9ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__void_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_void_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__bool_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_bool_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_bool_arg (const std::function<Callback_bool_arg> &func)
{
  void *fptr = new std::function<Callback_bool_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5f7ba898d12986bfULL, 0x8a1143a5f6dc85b8ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__bool_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_bool_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__int32_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_int32_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_int32_arg (const std::function<Callback_int32_arg> &func)
{
  void *fptr = new std::function<Callback_int32_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x583ed84bd4d820efULL, 0x87214001f1934890ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__int32_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_int32_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__int64_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_int64_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_int64_arg (const std::function<Callback_int64_arg> &func)
{
  void *fptr = new std::function<Callback_int64_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5d6ed628b051e336ULL, 0x442670f1eba34b7bULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__int64_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_int64_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__float64_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_float64_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_float64_arg (const std::function<Callback_float64_arg> &func)
{
  void *fptr = new std::function<Callback_float64_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5d937b3a9a059ff0ULL, 0x641851b425c3f91cULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__float64_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_float64_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__string_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_string_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_string_arg (const std::function<Callback_string_arg> &func)
{
  void *fptr = new std::function<Callback_string_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x524e550794aaa1e8ULL, 0x093b71ccace2863bULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__string_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_string_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__enum_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_enum_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_enum_arg (const std::function<Callback_enum_arg> &func)
{
  void *fptr = new std::function<Callback_enum_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x586138796f133c4dULL, 0x1c7573f2d30ac907ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__enum_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_enum_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__record_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_record_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_record_arg (const std::function<Callback_record_arg> &func)
{
  void *fptr = new std::function<Callback_record_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x59cb77461ddeac82ULL, 0xfeaa98721bd8ecd3ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__record_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_record_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__sequence_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_sequence_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_sequence_arg (const std::function<Callback_sequence_arg> &func)
{
  void *fptr = new std::function<Callback_sequence_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x547b4dd41606b568ULL, 0x1d763791a33d2bc9ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__sequence_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_sequence_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__interface_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_interface_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_interface_arg (const std::function<Callback_interface_arg> &func)
{
  void *fptr = new std::function<Callback_interface_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x57a5dbfbeb5a4ef9ULL, 0xb5df0c3b3bba4b22ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__interface_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_interface_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__any_arg (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_any_arg>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_any_arg (const std::function<Callback_any_arg> &func)
{
  void *fptr = new std::function<Callback_any_arg> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x51355ac177cc776eULL, 0x8b062ce8d8442de0ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__any_arg, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_any_arg (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__SignalTestInterfaceHandle__self_args (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle::Callback_self_args>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
SignalTestInterfaceHandle::sig_self_args (const std::function<Callback_self_args> &func)
{
  void *fptr = new std::function<Callback_self_args> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5c515ee37b78a970ULL, 0xe89c2af2f29359a0ULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__SignalTestInterfaceHandle__self_args, fptr);
  return id;
}
bool
SignalTestInterfaceHandle::sig_self_args (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
SignalTestInterfaceHandle::SignalTestInterfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const SignalTestInterfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, SignalTestInterfaceHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<SignalTestInterface_Context$> (ipcid)->handle$ : SignalTestInterfaceHandle();
}
const Rapicorn::Aida::TypeHash&
SignalTestInterfaceHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0acc338edd01a172ULL, 0x27c5f8854a5f9458ULL);
  return type_hash;
}
SignalTestInterfaceHandle
SignalTestInterfaceHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<SignalTestInterface_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return SignalTestInterfaceHandle();
}
const Rapicorn::Aida::TypeHashList&
SignalTestInterfaceHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<SignalTestInterface_Context$> (ipcid)->list_types();
}

// === ChildInheritingSignals ===
struct ChildInheritingSignals_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (ChildInheritingSignals_Context$);
public:
  struct SmartHandle$ : public ChildInheritingSignalsHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  ChildInheritingSignals_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
ChildInheritingSignals_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3e2ad0e03001d9acULL, 0x29b504a5e59d6c5fULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__ChildInheritingSignalsHandle__child_signal (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<ChildInheritingSignalsHandle::Callback_child_signal>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
ChildInheritingSignalsHandle::sig_child_signal (const std::function<Callback_child_signal> &func)
{
  void *fptr = new std::function<Callback_child_signal> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5ffad83b68b79139ULL, 0x7175e65d7705749fULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__ChildInheritingSignalsHandle__child_signal, fptr);
  return id;
}
bool
ChildInheritingSignalsHandle::sig_child_signal (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
ChildInheritingSignalsHandle::ChildInheritingSignalsHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ChildInheritingSignalsHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ChildInheritingSignalsHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<ChildInheritingSignals_Context$> (ipcid)->handle$ : ChildInheritingSignalsHandle();
}
const Rapicorn::Aida::TypeHash&
ChildInheritingSignalsHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0d6e67873f4098cbULL, 0xe7f2eb93eb46037cULL);
  return type_hash;
}
ChildInheritingSignalsHandle
ChildInheritingSignalsHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<ChildInheritingSignals_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return ChildInheritingSignalsHandle();
}
const Rapicorn::Aida::TypeHashList&
ChildInheritingSignalsHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<ChildInheritingSignals_Context$> (ipcid)->list_types();
}

// === AnotherChild ===
struct AnotherChild_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (AnotherChild_Context$);
public:
  struct SmartHandle$ : public AnotherChildHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  AnotherChild_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
AnotherChild_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3d193e12c75ef8cdULL, 0x583552525e108c61ULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
AnotherChildHandle::AnotherChildHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const AnotherChildHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, AnotherChildHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<AnotherChild_Context$> (ipcid)->handle$ : AnotherChildHandle();
}
const Rapicorn::Aida::TypeHash&
AnotherChildHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0e2870deaacf05f9ULL, 0x2851002b6bd14b7aULL);
  return type_hash;
}
AnotherChildHandle
AnotherChildHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<AnotherChild_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return AnotherChildHandle();
}
const Rapicorn::Aida::TypeHashList&
AnotherChildHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<AnotherChild_Context$> (ipcid)->list_types();
}

// === PropertyTester ===
struct PropertyTester_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (PropertyTester_Context$);
public:
  struct SmartHandle$ : public PropertyTesterHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  PropertyTester_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
PropertyTester_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x342f93a48aa12aebULL, 0x06c2ed978db9d30eULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
PropertyTesterHandle::PropertyTesterHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const PropertyTesterHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, PropertyTesterHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<PropertyTester_Context$> (ipcid)->handle$ : PropertyTesterHandle();
}
const Rapicorn::Aida::TypeHash&
PropertyTesterHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0de89d5c207bc662ULL, 0x846800e315917b46ULL);
  return type_hash;
}
PropertyTesterHandle
PropertyTesterHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<PropertyTester_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return PropertyTesterHandle();
}
const Rapicorn::Aida::TypeHashList&
PropertyTesterHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<PropertyTester_Context$> (ipcid)->list_types();
}
bool
PropertyTesterHandle::bool_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x396c5b1aaf49cec6ULL, 0xb6218ab5ac6b82c3ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::bool_prop (bool value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2bd3c8fc8f71f8b4ULL, 0x2dde5c2c8fcf750cULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
int
PropertyTesterHandle::int32_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3fc09bee2af126a2ULL, 0xc3a6e67a53c81eb1ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::int32_prop (int value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x26fd925ece96e768ULL, 0xac82e725f914b79dULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
Rapicorn::Aida::int64_t
PropertyTesterHandle::int64_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3731039da4eac87cULL, 0x78ad56f71ec3500aULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  Rapicorn::Aida::int64_t  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::int64_prop (Rapicorn::Aida::int64_t value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2231b1bcd886b3c0ULL, 0x84a1427a737bc687ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
PropertyTesterHandle::float64_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x36e831c918e287dfULL, 0x6bd2c7a7a75237faULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::float64_prop (double value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2e886d9d9b74fd50ULL, 0xf218d40a5edc2eb9ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
PropertyTesterHandle::string_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x31541f027fda353dULL, 0x578dfb53a92c60edULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::string_prop (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x28966e5a860d2cf1ULL, 0x23ba16b5fffc368dULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickEnum
PropertyTesterHandle::enum_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d09e074f5d2f8edULL, 0x38e8a275e29c3fc2ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::enum_prop (QuickEnum value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2b77a2f3a3c4d5b4ULL, 0x4d5b96d1adf5f7ccULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickRecordStruct
PropertyTesterHandle::record_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x31443949c61d0fecULL, 0xeb221638d6ffd3cfULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecordStruct  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::record_prop (const QuickRecordStruct &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a5f5c212625f446ULL, 0x30d24123307269ceULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickSequenceStruct
PropertyTesterHandle::sequence_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3f323c929c803ea8ULL, 0x6ebf49e977bfb699ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequenceStruct  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::sequence_prop (const QuickSequenceStruct &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x232174952090a941ULL, 0xae8b7a3e13fdfde7ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
GrandChildHandle
PropertyTesterHandle::interface_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x33a8b72ea92bb600ULL, 0x3837c1118556aaedULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  GrandChildHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::interface_prop (GrandChildHandle value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x29163b10631cf4b4ULL, 0xf014d69b1a1153e9ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
PropertyTesterHandle
PropertyTesterHandle::self_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e6b07e114fab96bULL, 0x45a97f76ee1a7bcfULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  PropertyTesterHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::self_prop (PropertyTesterHandle value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2c1aea6b5567c7beULL, 0x8f21acd05f5030deULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
Rapicorn::Aida::Any
PropertyTesterHandle::any_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x385bac7894911455ULL, 0x4d74265aa4c9d3b8ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  Rapicorn::Aida::Any  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::any_prop (const Rapicorn::Aida::Any &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x25ed5049e1dab81dULL, 0x30b595a3c260b96fULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
} // InterfaceTests

namespace RapicornAidaTest {

static Rapicorn::Init _Rapicorn_Aida__INIT__ClickType_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_ON_PRESS),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_ON_RELEASE),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_SLOW_REPEAT),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_FAST_REPEAT),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_KEY_REPEAT),
  };
  Rapicorn::Aida::EnumInfo::enlist ("RapicornAidaTest", "ClickType", enum_values);
});

// === ButtonArea ===
struct ButtonArea_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (ButtonArea_Context$);
public:
  struct SmartHandle$ : public ButtonAreaHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  ButtonArea_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
ButtonArea_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3ba079ca93d55fb3ULL, 0xf9944831dc1fc726ULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__ButtonAreaHandle__check_activate (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<ButtonAreaHandle::Callback_check_activate>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
ButtonAreaHandle::sig_check_activate (const std::function<Callback_check_activate> &func)
{
  void *fptr = new std::function<Callback_check_activate> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x5ed315978fdefdcaULL, 0x9efe9e4845d8907eULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__ButtonAreaHandle__check_activate, fptr);
  return id;
}
bool
ButtonAreaHandle::sig_check_activate (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_emit__ButtonAreaHandle__activate (Rapicorn::Aida::ClientConnection &aida_con, const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<ButtonAreaHandle::Callback_activate>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::field_buffer_emit_signal (aida_con, *sfb, *fptr);
  return NULL; // no support for remote signal returns atm
}
Rapicorn::Aida::uint64_t
ButtonAreaHandle::sig_activate (const std::function<Callback_activate> &func)
{
  void *fptr = new std::function<Callback_activate> (func);
  Rapicorn::Aida::uint64_t id = AIDA_CONNECTION().signal_connect (0x57905c3b089b970eULL, 0x3774e2d97c70a48fULL, __AIDA_Local__::smh2id (*this), __AIDA_emit__ButtonAreaHandle__activate, fptr);
  return id;
}
bool
ButtonAreaHandle::sig_activate (Rapicorn::Aida::uint64_t signal_id)
{
  const bool r = AIDA_CONNECTION().signal_disconnect (signal_id);
  return r;
}
ButtonAreaHandle::ButtonAreaHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ButtonAreaHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ButtonAreaHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<ButtonArea_Context$> (ipcid)->handle$ : ButtonAreaHandle();
}
const Rapicorn::Aida::TypeHash&
ButtonAreaHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0eb6bcdae9e87fe7ULL, 0xb2f16c34cdc20188ULL);
  return type_hash;
}
ButtonAreaHandle
ButtonAreaHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<ButtonArea_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return ButtonAreaHandle();
}
const Rapicorn::Aida::TypeHashList&
ButtonAreaHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<ButtonArea_Context$> (ipcid)->list_types();
}
std::string
ButtonAreaHandle::on_click () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x30c3d3f2b33bf581ULL, 0x79478f015decbb26ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2049371318a90eaeULL, 0xaad2e3187e219eaeULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonAreaHandle::on_click2 () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x35b46ed6cb8f24c3ULL, 0x261d8542336e8649ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click2 (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x281a2b2347c96db8ULL, 0xa01a955774bc9430ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonAreaHandle::on_click3 () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3a9709045f2195e3ULL, 0x8ac0eb7887c2a8eeULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click3 (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x29abcf6a16721aabULL, 0xed1c45f01dbea439ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
ClickType
ButtonAreaHandle::click_type () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x33032db41e62e30fULL, 0x92d90ac8cf899010ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  ClickType  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::click_type (ClickType value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x21058465dc0b1d3fULL, 0x7e683383d0024c74ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}

// === PureMethods ===
struct PureMethods_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (PureMethods_Context$);
public:
  struct SmartHandle$ : public PureMethodsHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  PureMethods_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
PureMethods_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x34692a915fe47960ULL, 0x86e3694656f6f9afULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
PureMethodsHandle::PureMethodsHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const PureMethodsHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, PureMethodsHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<PureMethods_Context$> (ipcid)->handle$ : PureMethodsHandle();
}
const Rapicorn::Aida::TypeHash&
PureMethodsHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0e0bc42228fe9334ULL, 0x66dcee20d071f835ULL);
  return type_hash;
}
PureMethodsHandle
PureMethodsHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<PureMethods_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return PureMethodsHandle();
}
const Rapicorn::Aida::TypeHashList&
PureMethodsHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<PureMethods_Context$> (ipcid)->list_types();
}
int
PureMethodsHandle::pure_method (double arg_f)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3e0c1c388c4a51a1ULL, 0x5f146e2e050f17e1ULL); // msgid
  fb <<= (*this);
  fb <<= arg_f;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}

static Rapicorn::Init _Rapicorn_Aida__INIT__MathExpressions_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_5),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_8),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_6),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_7),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_16),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_3),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_24),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_13),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_m2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_77),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_511),
  };
  Rapicorn::Aida::EnumInfo::enlist ("RapicornAidaTest", "MathExpressions", enum_values);
});
} // RapicornAidaTest

namespace Other {

// === NameTests ===
struct NameTests_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (NameTests_Context$);
public:
  struct SmartHandle$ : public NameTestsHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  NameTests_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
NameTests_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3cc442e612d0c931ULL, 0x174426019c513b3aULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
NameTestsHandle::NameTestsHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const NameTestsHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, NameTestsHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<NameTests_Context$> (ipcid)->handle$ : NameTestsHandle();
}
const Rapicorn::Aida::TypeHash&
NameTestsHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0ff49e5977e3e416ULL, 0x2d10a2bc2d53eab1ULL);
  return type_hash;
}
NameTestsHandle
NameTestsHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<NameTests_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return NameTestsHandle();
}
const Rapicorn::Aida::TypeHashList&
NameTestsHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<NameTests_Context$> (ipcid)->list_types();
}
void
NameTestsHandle::args_from_other_namespace (const InterfaceTests::QuickRecordStruct &arg_qr,
                                            RapicornAidaTest::ClickType arg_qe,
                                            const OtherNamespace::SomeRecordStruct &arg_sr)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 3), *fr = NULL;
  fb.add_msgid (0x211a5debfd86209cULL, 0x3ff87e4a8201e492ULL); // msgid
  fb <<= (*this);
  fb <<= arg_qr;
  fb <<= arg_qe;
  fb <<= arg_sr;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
} // Other

namespace BseTest {

// === Compressor ===
struct Compressor_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (Compressor_Context$);
public:
  struct SmartHandle$ : public CompressorHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  Compressor_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
Compressor_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3cc93ec8b4f43e89ULL, 0x38bbc5321cdaa262ULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
CompressorHandle::CompressorHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const CompressorHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, CompressorHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<Compressor_Context$> (ipcid)->handle$ : CompressorHandle();
}
const Rapicorn::Aida::TypeHash&
CompressorHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x0491625894ae6f81ULL, 0x139b9ce73db32661ULL);
  return type_hash;
}
CompressorHandle
CompressorHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Compressor_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return CompressorHandle();
}
const Rapicorn::Aida::TypeHashList&
CompressorHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Compressor_Context$> (ipcid)->list_types();
}
double
CompressorHandle::threshold () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3ffc3dfaef875d63ULL, 0xf6f4d889560ba297ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
CompressorHandle::threshold (double value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2209f452a5de4de8ULL, 0x3fb166b528077900ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
CompressorHandle::ratio () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3415341ee86f2c05ULL, 0xe5f3f6787cc5e436ULL);
  fb <<= (*this);
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
CompressorHandle::ratio (double value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x21b70e21f75fec8bULL, 0xbf3ad9293c93d072ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const RecordForGroupsStruct &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (5);
  fb <<= self.i;
  fb <<= self.ratio;
  fb <<= self.ordinary_bool;
  fb <<= self.threshold1;
  fb <<= self.threshold2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, RecordForGroupsStruct &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 5) return;
  fbr >>= self.i;
  fbr >>= self.ratio;
  fbr >>= self.ordinary_bool;
  fbr >>= self.threshold1;
  fbr >>= self.threshold2;
}

// === SoundModule ===
struct SoundModule_Context$ {
  RAPICORN_CLASS_NON_COPYABLE (SoundModule_Context$);
public:
  struct SmartHandle$ : public SoundModuleHandle {
    SmartHandle$ (Rapicorn::Aida::uint64_t ipcid) : Rapicorn::Aida::SmartHandle (ipcid) {}
  } handle$;
  SoundModule_Context$ (Rapicorn::Aida::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Rapicorn::Aida::TypeHashList *m_cached_types;
  const Rapicorn::Aida::TypeHashList& list_types ();
};
const Rapicorn::Aida::TypeHashList&
SoundModule_Context$::list_types ()
{
  if (!m_cached_types) {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x34056ecd1702e81aULL, 0x68e32ce1244df22bULL);
    fb <<= handle$;
    Rapicorn::Aida::FieldBuffer *fr = AIDA_CONNECTION().call_remote (&fb); // deletes fb
    AIDA_CHECK (fr != NULL, "missing result from 2-way call");
    Rapicorn::Aida::FieldReader frr (*fr, AIDA_CONNECTION());
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
    Rapicorn::Aida::TypeHashList *thv = new Rapicorn::Aida::TypeHashList();
    Rapicorn::Aida::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Rapicorn::Aida::atomic_ptr_cas (&m_cached_types, (Rapicorn::Aida::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
SoundModuleHandle::SoundModuleHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const SoundModuleHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, SoundModuleHandle &handle)
{
  const Rapicorn::Aida::uint64_t ipcid = fbr.pop_object();
  handle = AIDA_ISLIKELY (ipcid) ? connection_id2context<SoundModule_Context$> (ipcid)->handle$ : SoundModuleHandle();
}
const Rapicorn::Aida::TypeHash&
SoundModuleHandle::_type()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x06285204d12388cdULL, 0x2cf10a9d917227b5ULL);
  return type_hash;
}
SoundModuleHandle
SoundModuleHandle::_cast (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<SoundModule_Context$> (__AIDA_Local__::smh2id (other))->handle$;
  return SoundModuleHandle();
}
const Rapicorn::Aida::TypeHashList&
SoundModuleHandle::cast_types()
{
  static Rapicorn::Aida::TypeHashList notypes;
  const Rapicorn::Aida::uint64_t ipcid = __AIDA_Local__::smh2id (*this);
  if (AIDA_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<SoundModule_Context$> (ipcid)->list_types();
}
} // BseTest

