// --- Generated by AidaCxxStub ---

// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

namespace Rapicorn { namespace Aida {
class TestServerBase : public virtual PropertyHostInterface {
public:
  explicit             TestServerBase ()            {}
  virtual             ~TestServerBase ()            {}
  virtual uint64_t     _orbid         () const      { return uint64_t (this); }
};
} } // Rapicorn::Aida

#include <rapicorn-core.hh> // for rcore/signal.hh
using Rapicorn::Signals::slot;

#ifndef AIDA_CONNECTION
#define AIDA_CONNECTION()       (*(Rapicorn::Aida::ServerConnection*)NULL)
#endif // !AIDA_CONNECTION


// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __AIDA_GENERIC_CC_BOILERPLATE__
#define __AIDA_GENERIC_CC_BOILERPLATE__

#define AIDA_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("AIDA-ERROR: ") + errmsg); } while (0)

namespace { // Anon
using Rapicorn::Aida::uint64_t;

namespace __AIDA_Local__ {
using namespace Rapicorn::Aida;
static __attribute__ ((__format__ (__printf__, 1, 2), unused)) FieldBuffer*
error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  error_vprintf (format, args);
  va_end (args);
  return NULL;
}
} } // Anon::__AIDA_Local__
#endif // __AIDA_GENERIC_CC_BOILERPLATE__


namespace { // Anon
namespace __AIDA_Local__ {
// types
typedef ServerConnection::MethodRegistry MethodRegistry;
typedef ServerConnection::MethodEntry MethodEntry;
// objects
template<class Object> static inline Object* id2obj (uint64_t oid)
{
  const ptrdiff_t addr = AIDA_CONNECTION().orbid2instance (oid);
  Rapicorn::Aida::TestServerBase *instance = reinterpret_cast<Rapicorn::Aida::TestServerBase*> (addr);
  return dynamic_cast<Object*> (instance);
}
static inline uint64_t obj2id  (Rapicorn::Aida::TestServerBase *obj)
{ return AIDA_CONNECTION().instance2orbid (reinterpret_cast<ptrdiff_t> (obj)); }
template<class Object> inline Object* smh2obj (const SmartHandle &sh)
{ uint64_t orbid = sh._orbid(); return (orbid & 0) ? NULL : id2obj<Object> (orbid); }
template<class SMH> static inline SMH obj2smh (Rapicorn::Aida::TestServerBase *self)
{
  const uint64_t orbid = obj2id (self);
  SMH target;
  const uint64_t input[2] = { orbid, target._orbid() };
  Rapicorn::Aida::ObjectBroker::dup_handle (input, target);
  return target;
}
// messages
static inline void post_msg (FieldBuffer *fb) { ObjectBroker::post_msg (fb); }
static inline void add_header1_discon (FieldBuffer &fb, uint64_t orbid, uint64_t h, uint64_t l)
{ fb.add_header1 (Rapicorn::Aida::MSGID_DISCON, ObjectBroker::connection_id_from_orbid (orbid), h, l); }
static inline void add_header1_event  (FieldBuffer &fb, uint64_t orbid, uint64_t h, uint64_t l)
{ fb.add_header1 (Rapicorn::Aida::MSGID_EVENT, ObjectBroker::connection_id_from_orbid (orbid), h, l); }
static inline FieldBuffer* new_result (FieldReader &fbr, uint64_t h, uint64_t l, uint32_t n = 1)
{ return ObjectBroker::renew_into_result (fbr, ObjectBroker::receiver_connection_id (fbr.field_buffer()->first_id()), h, l, n); }

} } // Anon::__AIDA_Local__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

/** @interface FirstInterface
 * See also the corresponding C++ servant class I_FirstInterface_Interface. */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_FirstInterface_Interface ();
  virtual /*Des*/                       ~I_FirstInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          void_func                  ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterface_Interface*&);
I_FirstInterface_Interface* operator->* (FirstInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
FirstInterfaceHandle operator->* (I_FirstInterface_Interface *obj, Rapicorn::Aida::_HandleType);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64_t AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecord AliasRecord;

typedef XFooSequence AliasSequence;

typedef ExtensiveEnum AliasEnum;
} // MandatoryNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64_t Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ servant class I_UIWidgetArea_Interface. */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_UIWidgetArea_Interface ();
  virtual /*Des*/                       ~I_UIWidgetArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method            ();
  virtual double                        single_arg               (int n);
  virtual double                        single_arg2              (int n = 5);
  virtual double                        two_args                 (int n,
                                                                  double r);
  virtual double                        two_args2                (int n = 6,
                                                                  double r = 7.7);
  virtual double                        multi_args               (bool b,
                                                                  Rapicorn::Aida::int64_t n,
                                                                  double r,
                                                                  int i,
                                                                  const std::string &s = "String ding",
                                                                  double y = 5);
  virtual double                        self_method              (I_UIWidgetArea_Interface &ba1,
                                                                  I_UIWidgetArea_Interface &ba2);
  virtual void                          void_method              ();
  virtual std::string                   on_click2out             ();
  virtual void                          on_click2in              (const std::string &command);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetArea_Interface*&);
I_UIWidgetArea_Interface* operator->* (UIWidgetAreaHandle &sh, Rapicorn::Aida::_ServantType);
UIWidgetAreaHandle operator->* (I_UIWidgetArea_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface Parent
 * See also the corresponding C++ servant class I_Parent_Interface. */
/// See also the corresponding IDL class Parent.
class I_Parent_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Parent_Interface ();
  virtual /*Des*/                       ~I_Parent_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Parent_Interface*&);
I_Parent_Interface* operator->* (ParentHandle &sh, Rapicorn::Aida::_ServantType);
ParentHandle operator->* (I_Parent_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface Child
 * See also the corresponding C++ servant class I_Child_Interface. */
/// See also the corresponding IDL class Child.
class I_Child_Interface : public virtual I_Parent_Interface
{
protected:
  explicit                               I_Child_Interface ();
  virtual /*Des*/                       ~I_Child_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Child_Interface*&);
I_Child_Interface* operator->* (ChildHandle &sh, Rapicorn::Aida::_ServantType);
ChildHandle operator->* (I_Child_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface Descendant
 * See also the corresponding C++ servant class I_Descendant_Interface. */
/// See also the corresponding IDL class Descendant.
class I_Descendant_Interface : public virtual I_Child_Interface
{
protected:
  explicit                               I_Descendant_Interface ();
  virtual /*Des*/                       ~I_Descendant_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Descendant_Interface*&);
I_Descendant_Interface* operator->* (DescendantHandle &sh, Rapicorn::Aida::_ServantType);
DescendantHandle operator->* (I_Descendant_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface GrandChild
 * See also the corresponding C++ servant class I_GrandChild_Interface. */
/// See also the corresponding IDL class GrandChild.
class I_GrandChild_Interface : public virtual I_Descendant_Interface
{
protected:
  explicit                               I_GrandChild_Interface ();
  virtual /*Des*/                       ~I_GrandChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChild_Interface*&);
I_GrandChild_Interface* operator->* (GrandChildHandle &sh, Rapicorn::Aida::_ServantType);
GrandChildHandle operator->* (I_GrandChild_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface QuickIface
 * See also the corresponding C++ servant class I_QuickIface_Interface. */
/// See also the corresponding IDL class QuickIface.
class I_QuickIface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_QuickIface_Interface ();
  virtual /*Des*/                       ~I_QuickIface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          simple_function        (int i = 9);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIface_Interface*&);
I_QuickIface_Interface* operator->* (QuickIfaceHandle &sh, Rapicorn::Aida::_ServantType);
QuickIfaceHandle operator->* (I_QuickIface_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface MethodTestInterface
 * See also the corresponding C++ servant class I_MethodTestInterface_Interface. */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_MethodTestInterface_Interface ();
  virtual /*Des*/                       ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          method_with_void                ();
  virtual bool                          method_with_bools               (bool input,
                                                                         bool optval = 0);
  virtual int                           method_with_ints32              (int input,
                                                                         int optval = -2);
  virtual Rapicorn::Aida::int64_t       method_with_ints64              (Rapicorn::Aida::int64_t input,
                                                                         Rapicorn::Aida::int64_t optval = 576460752303423488);
  virtual double                        method_with_floats              (double input,
                                                                         double optval = 309.9);
  virtual std::string                   method_with_string              (const std::string &input,
                                                                         const std::string &optval = "default");
  virtual QuickEnum                     method_with_enum                (QuickEnum input,
                                                                         QuickEnum optval = QuickEnum (0));
  virtual QuickRecord                   method_with_record              (const QuickRecord &input,
                                                                         const QuickRecord &optval = QuickRecord());
  virtual QuickSequence                 method_with_sequence            (const QuickSequence &input,
                                                                         const QuickSequence &optval = QuickSequence());
  virtual I_GrandChild_Interface*       method_with_interface           (I_GrandChild_Interface &input,
                                                                         I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual Rapicorn::Aida::Any           method_with_anys                (const Rapicorn::Aida::Any &input,
                                                                         const Rapicorn::Aida::Any &optval);
  virtual I_QuickIface_Interface*       method_with_quickiface          (I_QuickIface_Interface &input,
                                                                         I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterface_Interface*&);
I_MethodTestInterface_Interface* operator->* (MethodTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
MethodTestInterfaceHandle operator->* (I_MethodTestInterface_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface SignalTestInterface
 * See also the corresponding C++ servant class I_SignalTestInterface_Interface. */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SignalTestInterface_Interface ();
  virtual /*Des*/                       ~I_SignalTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int32_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::int64_t ()> Signal_int64_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float64_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int32_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (Rapicorn::Aida::int64_t i)> Signal_int64_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float64_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterface_Interface*&);
I_SignalTestInterface_Interface* operator->* (SignalTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
SignalTestInterfaceHandle operator->* (I_SignalTestInterface_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface ChildInheritingSignals
 * See also the corresponding C++ servant class I_ChildInheritingSignals_Interface. */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignals_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_ChildInheritingSignals_Interface ();
  virtual /*Des*/                       ~I_ChildInheritingSignals_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_ChildInheritingSignals_Interface, void (I_ChildInheritingSignals_Interface &c, I_SignalTestInterface_Interface &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignals_Interface*&);
I_ChildInheritingSignals_Interface* operator->* (ChildInheritingSignalsHandle &sh, Rapicorn::Aida::_ServantType);
ChildInheritingSignalsHandle operator->* (I_ChildInheritingSignals_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface AnotherChild
 * See also the corresponding C++ servant class I_AnotherChild_Interface. */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChild_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_AnotherChild_Interface ();
  virtual /*Des*/                       ~I_AnotherChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChild_Interface*&);
I_AnotherChild_Interface* operator->* (AnotherChildHandle &sh, Rapicorn::Aida::_ServantType);
AnotherChildHandle operator->* (I_AnotherChild_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface PropertyTester
 * See also the corresponding C++ servant class I_PropertyTester_Interface. */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTester_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PropertyTester_Interface ();
  virtual /*Des*/                       ~I_PropertyTester_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual Rapicorn::Aida::int64_t       int64_prop     () const = 0;
  virtual void                          int64_prop     (Rapicorn::Aida::int64_t) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecord                   record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecord&) = 0;
  virtual QuickSequence                 sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequence&) = 0;
  virtual I_GrandChild_Interface*       interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChild_Interface*) = 0;
  virtual I_PropertyTester_Interface*   self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTester_Interface*) = 0;
  virtual Rapicorn::Aida::Any           any_prop       () const = 0;
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTester_Interface*&);
I_PropertyTester_Interface* operator->* (PropertyTesterHandle &sh, Rapicorn::Aida::_ServantType);
PropertyTesterHandle operator->* (I_PropertyTester_Interface *obj, Rapicorn::Aida::_HandleType);
} // InterfaceTests

namespace RapicornAidaTest {

/** @interface ButtonArea
 * See also the corresponding C++ servant class I_ButtonArea_Interface. */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_ButtonArea_Interface ();
  virtual /*Des*/                       ~I_ButtonArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonArea_Interface*&);
I_ButtonArea_Interface* operator->* (ButtonAreaHandle &sh, Rapicorn::Aida::_ServantType);
ButtonAreaHandle operator->* (I_ButtonArea_Interface *obj, Rapicorn::Aida::_HandleType);

class I_PureMethods_Interface;

/** @interface PureMethods
 * See also the corresponding C++ servant class I_PureMethods_Interface. */
/// See also the corresponding IDL class PureMethods.
class I_PureMethods_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PureMethods_Interface ();
  virtual /*Des*/                       ~I_PureMethods_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual int                           pure_method             (double f) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethods_Interface*&);
I_PureMethods_Interface* operator->* (PureMethodsHandle &sh, Rapicorn::Aida::_ServantType);
PureMethodsHandle operator->* (I_PureMethods_Interface *obj, Rapicorn::Aida::_HandleType);
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ servant class I_NameTests_Interface. */
/// See also the corresponding IDL class NameTests.
class I_NameTests_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_NameTests_Interface ();
  virtual /*Des*/                       ~I_NameTests_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecord &sr);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTests_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTests_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTests_Interface*&);
I_NameTests_Interface* operator->* (NameTestsHandle &sh, Rapicorn::Aida::_ServantType);
NameTestsHandle operator->* (I_NameTests_Interface *obj, Rapicorn::Aida::_HandleType);
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ servant class I_Compressor_Interface. */
/// See also the corresponding IDL class Compressor.
class I_Compressor_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Compressor_Interface ();
  virtual /*Des*/                       ~I_Compressor_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Compressor_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Compressor_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Compressor_Interface*&);
I_Compressor_Interface* operator->* (CompressorHandle &sh, Rapicorn::Aida::_ServantType);
CompressorHandle operator->* (I_Compressor_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface SoundModule
 * See also the corresponding C++ servant class I_SoundModule_Interface. */
/// See also the corresponding IDL class SoundModule.
class I_SoundModule_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SoundModule_Interface ();
  virtual /*Des*/                       ~I_SoundModule_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModule_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModule_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModule_Interface*&);
I_SoundModule_Interface* operator->* (SoundModuleHandle &sh, Rapicorn::Aida::_ServantType);
SoundModuleHandle operator->* (I_SoundModule_Interface *obj, Rapicorn::Aida::_HandleType);
} // BseTest

// --- Implementations ---

namespace MandatoryNamespace {

I_FirstInterface_Interface::I_FirstInterface_Interface ()
{}
I_FirstInterface_Interface::~I_FirstInterface_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_FirstInterface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_FirstInterface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_FirstInterface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_FirstInterface_Interface> (fbr.pop_object());
}
I_FirstInterface_Interface*
operator->* (FirstInterfaceHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_FirstInterface_Interface> (sh);
}
FirstInterfaceHandle
operator->* (I_FirstInterface_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<FirstInterfaceHandle> (obj);
}
void
I_FirstInterface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x22113f623903ac14ULL, 0x3fe8e50c1a9a78d2ULL)); // FirstInterface
}
const Rapicorn::Aida::PropertyList&
I_FirstInterface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
} // MandatoryNamespace

namespace InterfaceTests {

I_UIWidgetArea_Interface::I_UIWidgetArea_Interface () :
  sig_void_signal (*this), sig_sample_signal (*this)
{}
I_UIWidgetArea_Interface::~I_UIWidgetArea_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_UIWidgetArea_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_UIWidgetArea_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_UIWidgetArea_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_UIWidgetArea_Interface> (fbr.pop_object());
}
I_UIWidgetArea_Interface*
operator->* (UIWidgetAreaHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_UIWidgetArea_Interface> (sh);
}
UIWidgetAreaHandle
operator->* (I_UIWidgetArea_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<UIWidgetAreaHandle> (obj);
}
void
I_UIWidgetArea_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x11db82aaba1ee248ULL, 0xd2359653ff87e972ULL)); // UIWidgetArea
}
const Rapicorn::Aida::PropertyList&
I_UIWidgetArea_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    // RAPICORN_AIDA_PROPERTY (I_UIWidgetArea_Interface, dummy, "dummy", "", ""),
    RAPICORN_AIDA_PROPERTY (I_UIWidgetArea_Interface, on_click, _("On CLick"), _("Command on button1 click"), "rw"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_Parent_Interface::I_Parent_Interface ()
{}
I_Parent_Interface::~I_Parent_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Parent_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Parent_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Parent_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Parent_Interface> (fbr.pop_object());
}
I_Parent_Interface*
operator->* (ParentHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_Parent_Interface> (sh);
}
ParentHandle
operator->* (I_Parent_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<ParentHandle> (obj);
}
void
I_Parent_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
}
const Rapicorn::Aida::PropertyList&
I_Parent_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_Child_Interface::I_Child_Interface ()
{}
I_Child_Interface::~I_Child_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Child_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Child_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Child_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Child_Interface> (fbr.pop_object());
}
I_Child_Interface*
operator->* (ChildHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_Child_Interface> (sh);
}
ChildHandle
operator->* (I_Child_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<ChildHandle> (obj);
}
void
I_Child_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
}
const Rapicorn::Aida::PropertyList&
I_Child_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_Parent_Interface::_property_list());
  return property_list;
}

I_Descendant_Interface::I_Descendant_Interface ()
{}
I_Descendant_Interface::~I_Descendant_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Descendant_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Descendant_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Descendant_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Descendant_Interface> (fbr.pop_object());
}
I_Descendant_Interface*
operator->* (DescendantHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_Descendant_Interface> (sh);
}
DescendantHandle
operator->* (I_Descendant_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<DescendantHandle> (obj);
}
void
I_Descendant_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL)); // Descendant
}
const Rapicorn::Aida::PropertyList&
I_Descendant_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_Child_Interface::_property_list());
  return property_list;
}

I_GrandChild_Interface::I_GrandChild_Interface ()
{}
I_GrandChild_Interface::~I_GrandChild_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_GrandChild_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_GrandChild_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_GrandChild_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_GrandChild_Interface> (fbr.pop_object());
}
I_GrandChild_Interface*
operator->* (GrandChildHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_GrandChild_Interface> (sh);
}
GrandChildHandle
operator->* (I_GrandChild_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<GrandChildHandle> (obj);
}
void
I_GrandChild_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL)); // Descendant
  thl.push_back (Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0xf6975e5e92250718ULL, 0x53730d44919c46f9ULL)); // GrandChild
}
const Rapicorn::Aida::PropertyList&
I_GrandChild_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_Descendant_Interface::_property_list());
  return property_list;
}

I_QuickIface_Interface::I_QuickIface_Interface ()
{}
I_QuickIface_Interface::~I_QuickIface_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_QuickIface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_QuickIface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_QuickIface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_QuickIface_Interface> (fbr.pop_object());
}
I_QuickIface_Interface*
operator->* (QuickIfaceHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_QuickIface_Interface> (sh);
}
QuickIfaceHandle
operator->* (I_QuickIface_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<QuickIfaceHandle> (obj);
}
void
I_QuickIface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x4524ee119d4e454cULL, 0xbeb61f7c3cc04f7dULL)); // QuickIface
}
const Rapicorn::Aida::PropertyList&
I_QuickIface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_MethodTestInterface_Interface::I_MethodTestInterface_Interface ()
{}
I_MethodTestInterface_Interface::~I_MethodTestInterface_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_MethodTestInterface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_MethodTestInterface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_MethodTestInterface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_MethodTestInterface_Interface> (fbr.pop_object());
}
I_MethodTestInterface_Interface*
operator->* (MethodTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_MethodTestInterface_Interface> (sh);
}
MethodTestInterfaceHandle
operator->* (I_MethodTestInterface_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<MethodTestInterfaceHandle> (obj);
}
void
I_MethodTestInterface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x6bf684458ac5f01aULL, 0xf64c02611b807180ULL)); // MethodTestInterface
}
const Rapicorn::Aida::PropertyList&
I_MethodTestInterface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_SignalTestInterface_Interface::I_SignalTestInterface_Interface () :
  sig_void_result (*this), sig_bool_result (*this), sig_int32_result (*this), sig_int64_result (*this), sig_float64_result (*this), sig_string_result (*this), sig_enum_result (*this), sig_record_result (*this), sig_sequence_result (*this), sig_interface_result (*this), sig_any_result (*this), sig_self_result (*this), sig_void_arg (*this), sig_bool_arg (*this), sig_int32_arg (*this), sig_int64_arg (*this), sig_float64_arg (*this), sig_string_arg (*this), sig_enum_arg (*this), sig_record_arg (*this), sig_sequence_arg (*this), sig_interface_arg (*this), sig_any_arg (*this), sig_self_args (*this)
{}
I_SignalTestInterface_Interface::~I_SignalTestInterface_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SignalTestInterface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SignalTestInterface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SignalTestInterface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_SignalTestInterface_Interface> (fbr.pop_object());
}
I_SignalTestInterface_Interface*
operator->* (SignalTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_SignalTestInterface_Interface> (sh);
}
SignalTestInterfaceHandle
operator->* (I_SignalTestInterface_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<SignalTestInterfaceHandle> (obj);
}
void
I_SignalTestInterface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
}
const Rapicorn::Aida::PropertyList&
I_SignalTestInterface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_ChildInheritingSignals_Interface::I_ChildInheritingSignals_Interface () :
  sig_child_signal (*this)
{}
I_ChildInheritingSignals_Interface::~I_ChildInheritingSignals_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ChildInheritingSignals_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ChildInheritingSignals_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ChildInheritingSignals_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_ChildInheritingSignals_Interface> (fbr.pop_object());
}
I_ChildInheritingSignals_Interface*
operator->* (ChildInheritingSignalsHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_ChildInheritingSignals_Interface> (sh);
}
ChildInheritingSignalsHandle
operator->* (I_ChildInheritingSignals_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<ChildInheritingSignalsHandle> (obj);
}
void
I_ChildInheritingSignals_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  thl.push_back (Rapicorn::Aida::TypeHash (0xf20ff30241b5b694ULL, 0x9f544b2626e183f0ULL)); // ChildInheritingSignals
}
const Rapicorn::Aida::PropertyList&
I_ChildInheritingSignals_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_SignalTestInterface_Interface::_property_list());
  return property_list;
}

I_AnotherChild_Interface::I_AnotherChild_Interface ()
{}
I_AnotherChild_Interface::~I_AnotherChild_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_AnotherChild_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_AnotherChild_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_AnotherChild_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_AnotherChild_Interface> (fbr.pop_object());
}
I_AnotherChild_Interface*
operator->* (AnotherChildHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_AnotherChild_Interface> (sh);
}
AnotherChildHandle
operator->* (I_AnotherChild_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<AnotherChildHandle> (obj);
}
void
I_AnotherChild_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  thl.push_back (Rapicorn::Aida::TypeHash (0x9a33af1b27f7e36dULL, 0xdf625f7bd18934faULL)); // AnotherChild
}
const Rapicorn::Aida::PropertyList&
I_AnotherChild_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_SignalTestInterface_Interface::_property_list());
  return property_list;
}

I_PropertyTester_Interface::I_PropertyTester_Interface ()
{}
I_PropertyTester_Interface::~I_PropertyTester_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PropertyTester_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PropertyTester_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PropertyTester_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_PropertyTester_Interface> (fbr.pop_object());
}
I_PropertyTester_Interface*
operator->* (PropertyTesterHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_PropertyTester_Interface> (sh);
}
PropertyTesterHandle
operator->* (I_PropertyTester_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<PropertyTesterHandle> (obj);
}
void
I_PropertyTester_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0xa37ab462c55a3b3cULL, 0x4f3fd1c9ad9689fbULL)); // PropertyTester
}
const Rapicorn::Aida::PropertyList&
I_PropertyTester_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, bool_prop, "bool_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, int32_prop, "int32_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, int64_prop, "int64_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, float64_prop, "float64_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, string_prop, "string_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, enum_prop, "enum_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, record_prop, "record_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, sequence_prop, "sequence_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, interface_prop, "interface_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, self_prop, "self_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, any_prop, "any_prop", "", ""),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
} // InterfaceTests

namespace RapicornAidaTest {

I_ButtonArea_Interface::I_ButtonArea_Interface () :
  sig_check_activate (*this), sig_activate (*this)
{}
I_ButtonArea_Interface::~I_ButtonArea_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ButtonArea_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ButtonArea_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ButtonArea_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_ButtonArea_Interface> (fbr.pop_object());
}
I_ButtonArea_Interface*
operator->* (ButtonAreaHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_ButtonArea_Interface> (sh);
}
ButtonAreaHandle
operator->* (I_ButtonArea_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<ButtonAreaHandle> (obj);
}
void
I_ButtonArea_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0xec371b296fa57436ULL, 0x92e4310e386fc92eULL)); // ButtonArea
}
const Rapicorn::Aida::PropertyList&
I_ButtonArea_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, on_click, "on_click", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, on_click2, "on_click2", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, on_click3, "on_click3", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, click_type, "click_type", "", ""),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_PureMethods_Interface::I_PureMethods_Interface ()
{}
I_PureMethods_Interface::~I_PureMethods_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PureMethods_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PureMethods_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PureMethods_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_PureMethods_Interface> (fbr.pop_object());
}
I_PureMethods_Interface*
operator->* (PureMethodsHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_PureMethods_Interface> (sh);
}
PureMethodsHandle
operator->* (I_PureMethods_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<PureMethodsHandle> (obj);
}
void
I_PureMethods_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0xddc2a514d04d3af5ULL, 0xc0046740434c0486ULL)); // PureMethods
}
const Rapicorn::Aida::PropertyList&
I_PureMethods_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
} // RapicornAidaTest

namespace Other {

I_NameTests_Interface::I_NameTests_Interface ()
{}
I_NameTests_Interface::~I_NameTests_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_NameTests_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_NameTests_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_NameTests_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_NameTests_Interface> (fbr.pop_object());
}
I_NameTests_Interface*
operator->* (NameTestsHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_NameTests_Interface> (sh);
}
NameTestsHandle
operator->* (I_NameTests_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<NameTestsHandle> (obj);
}
void
I_NameTests_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x542d40cd7d8fcd40ULL, 0x8c1782df29c9b936ULL)); // NameTests
}
const Rapicorn::Aida::PropertyList&
I_NameTests_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
} // Other

namespace BseTest {

I_Compressor_Interface::I_Compressor_Interface ()
{}
I_Compressor_Interface::~I_Compressor_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Compressor_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Compressor_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Compressor_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Compressor_Interface> (fbr.pop_object());
}
I_Compressor_Interface*
operator->* (CompressorHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_Compressor_Interface> (sh);
}
CompressorHandle
operator->* (I_Compressor_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<CompressorHandle> (obj);
}
void
I_Compressor_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x42057a05d51182dfULL, 0x6a0d69cda274433eULL)); // Compressor
}
const Rapicorn::Aida::PropertyList&
I_Compressor_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    RAPICORN_AIDA_PROPERTY (I_Compressor_Interface, threshold, "", "", "w"),
    RAPICORN_AIDA_PROPERTY (I_Compressor_Interface, ratio, "", "", "w"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_SoundModule_Interface::I_SoundModule_Interface ()
{}
I_SoundModule_Interface::~I_SoundModule_Interface ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SoundModule_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SoundModule_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SoundModule_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_SoundModule_Interface> (fbr.pop_object());
}
I_SoundModule_Interface*
operator->* (SoundModuleHandle &sh, Rapicorn::Aida::_ServantType)
{
  return __AIDA_Local__::smh2obj<I_SoundModule_Interface> (sh);
}
SoundModuleHandle
operator->* (I_SoundModule_Interface *obj, Rapicorn::Aida::_HandleType)
{
  return __AIDA_Local__::obj2smh<SoundModuleHandle> (obj);
}
void
I_SoundModule_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x06447b38b51e0198ULL, 0x848669199cc311deULL)); // SoundModule
}
const Rapicorn::Aida::PropertyList&
I_SoundModule_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

// --- Method Dispatchers & Registry ---
} // BseTest

namespace MandatoryNamespace {
static Rapicorn::Aida::FieldBuffer*
__AIDA_types__FirstInterface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_FirstInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x06733e42687c02b3ULL, 0x831dd99e74128fb9ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__FirstInterface__void_func (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_FirstInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace InterfaceTests {
static Rapicorn::Aida::FieldBuffer*
__AIDA_types__UIWidgetArea (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x8f38c8e0b9611227ULL, 0xa088a34311deab39ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__UIWidgetArea__dummy (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  rval = self->dummy ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__UIWidgetArea__dummy (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_dummy;
  fbr >>= arg_dummy;
  self->dummy (arg_dummy);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__UIWidgetArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__UIWidgetArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__simple_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->simple_method ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__single_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  rval = self->single_arg (arg_n);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__single_arg2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  rval = self->single_arg2 (arg_n);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__two_args (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double  rval = self->two_args (arg_n, arg_r);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__two_args2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double  rval = self->two_args2 (arg_n, arg_r);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__multi_args (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 6) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_b;
  fbr >>= arg_b;
  Rapicorn::Aida::int64_t  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  int  arg_i;
  fbr >>= arg_i;
  std::string  arg_s;
  fbr >>= arg_s;
  double  arg_y;
  fbr >>= arg_y;
  double  rval = self->multi_args (arg_b, arg_n, arg_r, arg_i, arg_s, arg_y);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__self_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_UIWidgetArea_Interface *arg_ba1;
  fbr >>= arg_ba1;
  I_UIWidgetArea_Interface *arg_ba2;
  fbr >>= arg_ba2;
  double  rval = self->self_method (*arg_ba1, *arg_ba2);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__void_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  self->void_method ();
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__on_click2out (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click2out ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__UIWidgetArea__on_click2in (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_command;
  fbr >>= arg_command;
  self->on_click2in (arg_command);
  return NULL;
}
class __AIDA_Closure__UIWidgetArea__void_signal {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__UIWidgetArea__void_signal> SharedPtr;
  __AIDA_Closure__UIWidgetArea__void_signal (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__UIWidgetArea__void_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__UIWidgetArea__void_signal (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_void_signal.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__UIWidgetArea__void_signal::SharedPtr sp (new __AIDA_Closure__UIWidgetArea__void_signal (AIDA_CONNECTION(), handler_id));
    cid = self->sig_void_signal.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__UIWidgetArea__sample_signal {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__UIWidgetArea__sample_signal> SharedPtr;
  __AIDA_Closure__UIWidgetArea__sample_signal (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__UIWidgetArea__sample_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static double
  handler (I_UIWidgetArea_Interface &arg_ba1,
           int arg_someint,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL);
    fb <<= sp->m_handler;
    fb <<= arg_ba1;
    fb <<= arg_someint;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__UIWidgetArea__sample_signal (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_sample_signal.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__UIWidgetArea__sample_signal::SharedPtr sp (new __AIDA_Closure__UIWidgetArea__sample_signal (AIDA_CONNECTION(), handler_id));
    cid = self->sig_sample_signal.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL);
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__Parent (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Parent_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf963900935f64ed6ULL, 0x68f38589f5e75b82ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__Child (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Child_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x19344291fb3e24f8ULL, 0x03c09ce7d044cddaULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__Descendant (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Descendant_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x0c7e17cb99e7e1f5ULL, 0xf983d237de11fd86ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__GrandChild (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_GrandChild_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xcc7a1f29efc75d7dULL, 0x8caec1b61b3388a8ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__QuickIface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_QuickIface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x0040fbcf1af9959aULL, 0x5a1fc9c92b94af9fULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__QuickIface__simple_function (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_QuickIface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_i;
  fbr >>= arg_i;
  self->simple_function (arg_i);
  return NULL;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__MethodTestInterface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x61574837fdd015afULL, 0x893c7eca775ea115ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_void (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  self->method_with_void ();
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_bools (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_input;
  fbr >>= arg_input;
  bool  arg_optval;
  fbr >>= arg_optval;
  bool  rval = self->method_with_bools (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_ints32 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_input;
  fbr >>= arg_input;
  int  arg_optval;
  fbr >>= arg_optval;
  int  rval = self->method_with_ints32 (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_ints64 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::int64_t  arg_input;
  fbr >>= arg_input;
  Rapicorn::Aida::int64_t  arg_optval;
  fbr >>= arg_optval;
  Rapicorn::Aida::int64_t  rval = self->method_with_ints64 (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_floats (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_input;
  fbr >>= arg_input;
  double  arg_optval;
  fbr >>= arg_optval;
  double  rval = self->method_with_floats (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_string (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_input;
  fbr >>= arg_input;
  std::string  arg_optval;
  fbr >>= arg_optval;
  std::string  rval = self->method_with_string (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_enum (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickEnum  arg_input;
  fbr >>= arg_input;
  QuickEnum  arg_optval;
  fbr >>= arg_optval;
  QuickEnum  rval = self->method_with_enum (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_record (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickRecord  arg_input;
  fbr >>= arg_input;
  QuickRecord  arg_optval;
  fbr >>= arg_optval;
  QuickRecord  rval = self->method_with_record (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_sequence (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickSequence  arg_input;
  fbr >>= arg_input;
  QuickSequence  arg_optval;
  fbr >>= arg_optval;
  QuickSequence  rval = self->method_with_sequence (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_interface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_input;
  fbr >>= arg_input;
  I_GrandChild_Interface *arg_optval;
  fbr >>= arg_optval;
  I_GrandChild_Interface *rval = self->method_with_interface (*arg_input, *arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_anys (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::Any  arg_input;
  fbr >>= arg_input;
  Rapicorn::Aida::Any  arg_optval;
  fbr >>= arg_optval;
  Rapicorn::Aida::Any  rval = self->method_with_anys (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__MethodTestInterface__method_with_quickiface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_QuickIface_Interface *arg_input;
  fbr >>= arg_input;
  I_QuickIface_Interface *arg_iface0;
  fbr >>= arg_iface0;
  I_QuickIface_Interface *rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL);
  rb <<= rval;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__SignalTestInterface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x008959b54c5d1a16ULL, 0xe2db72887f695404ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__void_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__void_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__void_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__void_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__void_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_void_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__void_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__void_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_void_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__bool_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__bool_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__bool_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__bool_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static bool
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__bool_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_bool_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__bool_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__bool_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_bool_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int32_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int32_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int32_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__int32_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static int
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__int32_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_int32_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int32_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int32_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int32_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int64_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int64_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int64_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__int64_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static Rapicorn::Aida::int64_t
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__int64_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_int64_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int64_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int64_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int64_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__float64_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__float64_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__float64_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__float64_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static double
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__float64_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_float64_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__float64_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__float64_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_float64_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__string_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__string_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__string_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__string_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::string
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return "";
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__string_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_string_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__string_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__string_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_string_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__enum_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__enum_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__enum_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__enum_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static QuickEnum
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return QuickEnum (0);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__enum_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_enum_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__enum_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__enum_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_enum_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__record_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__record_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__record_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__record_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static QuickRecord
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return QuickRecord();
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__record_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_record_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__record_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__record_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_record_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__sequence_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__sequence_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__sequence_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__sequence_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static QuickSequence
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return QuickSequence();
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__sequence_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_sequence_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__sequence_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__sequence_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_sequence_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__interface_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__interface_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__interface_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__interface_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static I_GrandChild_Interface*
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__interface_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_interface_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__interface_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__interface_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_interface_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__any_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__any_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__any_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__any_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x296163d4220985ceULL, 0x40daacab4a841093ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static Rapicorn::Aida::Any
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x296163d4220985ceULL, 0x40daacab4a841093ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return Rapicorn::Aida::Any();
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__any_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_any_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__any_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__any_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_any_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x296163d4220985ceULL, 0x40daacab4a841093ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__self_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__self_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__self_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__self_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x35828273200534f7ULL, 0x72873f1374d6093bULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static I_SignalTestInterface_Interface*
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x35828273200534f7ULL, 0x72873f1374d6093bULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__self_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_self_result.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__self_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__self_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_self_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x35828273200534f7ULL, 0x72873f1374d6093bULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__void_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__void_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__void_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__void_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__void_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_void_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__void_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__void_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_void_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__bool_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__bool_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__bool_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__bool_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (bool arg_b,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL);
    fb <<= sp->m_handler;
    fb <<= arg_b;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__bool_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_bool_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__bool_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__bool_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_bool_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int32_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int32_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int32_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__int32_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (int arg_i,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL);
    fb <<= sp->m_handler;
    fb <<= arg_i;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__int32_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_int32_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int32_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int32_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int32_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int64_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int64_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int64_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__int64_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (Rapicorn::Aida::int64_t arg_i,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL);
    fb <<= sp->m_handler;
    fb <<= arg_i;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__int64_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_int64_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int64_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int64_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int64_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__float64_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__float64_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__float64_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__float64_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (double arg_f,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL);
    fb <<= sp->m_handler;
    fb <<= arg_f;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__float64_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_float64_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__float64_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__float64_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_float64_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__string_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__string_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__string_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__string_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const std::string &arg_s,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL);
    fb <<= sp->m_handler;
    fb <<= arg_s;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__string_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_string_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__string_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__string_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_string_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__enum_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__enum_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__enum_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__enum_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (QuickEnum arg_e,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL);
    fb <<= sp->m_handler;
    fb <<= arg_e;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__enum_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_enum_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__enum_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__enum_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_enum_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__record_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__record_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__record_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__record_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const QuickRecord &arg_r,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL);
    fb <<= sp->m_handler;
    fb <<= arg_r;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__record_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_record_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__record_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__record_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_record_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__sequence_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__sequence_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__sequence_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__sequence_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const QuickSequence &arg_s,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL);
    fb <<= sp->m_handler;
    fb <<= arg_s;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__sequence_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_sequence_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__sequence_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__sequence_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_sequence_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__interface_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__interface_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__interface_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__interface_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (I_GrandChild_Interface &arg_i,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL);
    fb <<= sp->m_handler;
    fb <<= arg_i;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__interface_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_interface_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__interface_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__interface_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_interface_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__any_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__any_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__any_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__any_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const Rapicorn::Aida::Any &arg_a,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL);
    fb <<= sp->m_handler;
    fb <<= arg_a;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__any_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_any_arg.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__any_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__any_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_any_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__self_args {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__self_args> SharedPtr;
  __AIDA_Closure__SignalTestInterface__self_args (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__SignalTestInterface__self_args()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (I_SignalTestInterface_Interface &arg_self_,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL);
    fb <<= sp->m_handler;
    fb <<= arg_self_;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__SignalTestInterface__self_args (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_self_args.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__self_args::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__self_args (AIDA_CONNECTION(), handler_id));
    cid = self->sig_self_args.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL);
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__ChildInheritingSignals (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ChildInheritingSignals_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x1e3629455056e2c5ULL, 0xb0a26fd3fa379e71ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
class __AIDA_Closure__ChildInheritingSignals__child_signal {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__ChildInheritingSignals__child_signal> SharedPtr;
  __AIDA_Closure__ChildInheritingSignals__child_signal (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__ChildInheritingSignals__child_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (I_ChildInheritingSignals_Interface &arg_c,
           I_SignalTestInterface_Interface &arg_p,
           const Rapicorn::Aida::Any &arg_a,
           int arg_i,
           const QuickRecord &arg_r,
           const QuickSequence &arg_s,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 6);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL);
    fb <<= sp->m_handler;
    fb <<= arg_c;
    fb <<= arg_p;
    fb <<= arg_a;
    fb <<= arg_i;
    fb <<= arg_r;
    fb <<= arg_s;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__ChildInheritingSignals__child_signal (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_ChildInheritingSignals_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_child_signal.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__ChildInheritingSignals__child_signal::SharedPtr sp (new __AIDA_Closure__ChildInheritingSignals__child_signal (AIDA_CONNECTION(), handler_id));
    cid = self->sig_child_signal.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL);
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__AnotherChild (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_AnotherChild_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x3401a3c0d40fe0e6ULL, 0x3c6d94a03419b7caULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__PropertyTester (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xc5c990e90dfb53e9ULL, 0x121587ef2dc3a59bULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__bool_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  rval = self->bool_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__bool_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_bool_prop;
  fbr >>= arg_bool_prop;
  self->bool_prop (arg_bool_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__int32_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  rval = self->int32_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__int32_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_int32_prop;
  fbr >>= arg_int32_prop;
  self->int32_prop (arg_int32_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__int64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::int64_t  rval = self->int64_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__int64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::int64_t  arg_int64_prop;
  fbr >>= arg_int64_prop;
  self->int64_prop (arg_int64_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__float64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->float64_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__float64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_float64_prop;
  fbr >>= arg_float64_prop;
  self->float64_prop (arg_float64_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__string_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->string_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__string_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_string_prop;
  fbr >>= arg_string_prop;
  self->string_prop (arg_string_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__enum_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickEnum  rval = self->enum_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__enum_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickEnum  arg_enum_prop;
  fbr >>= arg_enum_prop;
  self->enum_prop (arg_enum_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__record_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickRecord  rval = self->record_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__record_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickRecord  arg_record_prop;
  fbr >>= arg_record_prop;
  self->record_prop (arg_record_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__sequence_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickSequence  rval = self->sequence_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__sequence_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickSequence  arg_sequence_prop;
  fbr >>= arg_sequence_prop;
  self->sequence_prop (arg_sequence_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__interface_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *rval = self->interface_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__interface_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_interface_prop;
  fbr >>= arg_interface_prop;
  self->interface_prop (&*arg_interface_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__self_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_PropertyTester_Interface *rval = self->self_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__self_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_PropertyTester_Interface *arg_self_prop;
  fbr >>= arg_self_prop;
  self->self_prop (&*arg_self_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__PropertyTester__any_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::Any  rval = self->any_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__PropertyTester__any_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::Any  arg_any_prop;
  fbr >>= arg_any_prop;
  self->any_prop (arg_any_prop);
  return NULL;
}

} // InterfaceTests

namespace RapicornAidaTest {
static Rapicorn::Aida::FieldBuffer*
__AIDA_types__ButtonArea (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf9fd022398187c1eULL, 0x971768152fbb4b77ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__ButtonArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__ButtonArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__ButtonArea__on_click2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click2 ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x1b448d91990181daULL, 0x9751c08ae956c729ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__ButtonArea__on_click2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click2;
  fbr >>= arg_on_click2;
  self->on_click2 (arg_on_click2);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__ButtonArea__on_click3 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click3 ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__ButtonArea__on_click3 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click3;
  fbr >>= arg_on_click3;
  self->on_click3 (arg_on_click3);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__ButtonArea__click_type (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  ClickType  rval = self->click_type ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__ButtonArea__click_type (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  ClickType  arg_click_type;
  fbr >>= arg_click_type;
  self->click_type (arg_click_type);
  return NULL;
}
class __AIDA_Closure__ButtonArea__check_activate {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__ButtonArea__check_activate> SharedPtr;
  __AIDA_Closure__ButtonArea__check_activate (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__ButtonArea__check_activate()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static bool
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__ButtonArea__check_activate (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_check_activate.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__ButtonArea__check_activate::SharedPtr sp (new __AIDA_Closure__ButtonArea__check_activate (AIDA_CONNECTION(), handler_id));
    cid = self->sig_check_activate.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL);
  rb <<= cid;
  return &rb;
}
class __AIDA_Closure__ButtonArea__activate {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<__AIDA_Closure__ButtonArea__activate> SharedPtr;
  __AIDA_Closure__ButtonArea__activate (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~__AIDA_Closure__ButtonArea__activate()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, m_handler, 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL);
    fb <<= m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0);
    __AIDA_Local__::add_header1_event (fb, sp->m_handler, 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL);
    fb <<= sp->m_handler;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__AIDA_signal__ButtonArea__activate (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, signal_connection, cid = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection) self->sig_activate.disconnect (signal_connection);
  if (handler_id) {
    __AIDA_Closure__ButtonArea__activate::SharedPtr sp (new __AIDA_Closure__ButtonArea__activate (AIDA_CONNECTION(), handler_id));
    cid = self->sig_activate.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL);
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__PureMethods (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PureMethods_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf1b1618a8feeeadeULL, 0x37141973b72fb806ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__PureMethods__pure_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PureMethods_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_f;
  fbr >>= arg_f;
  int  rval = self->pure_method (arg_f);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL);
  rb <<= rval;
  return &rb;
}

} // RapicornAidaTest

namespace Other {
static Rapicorn::Aida::FieldBuffer*
__AIDA_types__NameTests (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_NameTests_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x501084fe2e8e5788ULL, 0x3fb86363d037fe27ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_call__NameTests__args_from_other_namespace (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 3) return __AIDA_Local__::error ("invalid number of arguments");
  I_NameTests_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  InterfaceTests::QuickRecord  arg_qr;
  fbr >>= arg_qr;
  RapicornAidaTest::ClickType  arg_qe;
  fbr >>= arg_qe;
  OtherNamespace::SomeRecord  arg_sr;
  fbr >>= arg_sr;
  self->args_from_other_namespace (arg_qr, arg_qe, arg_sr);
  return NULL;
}

} // Other

namespace BseTest {
static Rapicorn::Aida::FieldBuffer*
__AIDA_types__Compressor (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xee0a72a933a11affULL, 0x4de21e78a41cb272ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__Compressor__threshold (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->threshold ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__Compressor__threshold (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_threshold;
  fbr >>= arg_threshold;
  self->threshold (arg_threshold);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_get__Compressor__ratio (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->ratio ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__AIDA_set__Compressor__ratio (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_ratio;
  fbr >>= arg_ratio;
  self->ratio (arg_ratio);
  return NULL;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_types__SoundModule (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 3 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_SoundModule_Interface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_result (fbr, 0x008de59c242661d3ULL, 0xb91bcb9bc3832039ULL, 1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static const __AIDA_Local__::MethodEntry _aida_stub_entries[] = {
  { 0x06733e42687c02b3ULL, 0x831dd99e74128fb9ULL, MandatoryNamespace::__AIDA_types__FirstInterface, },
  { 0xc3f858f5171056cbULL, 0x394e47a2bcd63e16ULL, MandatoryNamespace::__AIDA_call__FirstInterface__void_func, },
  { 0x8f38c8e0b9611227ULL, 0xa088a34311deab39ULL, InterfaceTests::__AIDA_types__UIWidgetArea, },
  { 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL, InterfaceTests::__AIDA_get__UIWidgetArea__dummy, },
  { 0x7aaf2f96f3042829ULL, 0x3d0391e5b72e7ba5ULL, InterfaceTests::__AIDA_set__UIWidgetArea__dummy, },
  { 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL, InterfaceTests::__AIDA_get__UIWidgetArea__on_click, },
  { 0xf0025ec0fa66e3e2ULL, 0x880c10e8e6b57cfbULL, InterfaceTests::__AIDA_set__UIWidgetArea__on_click, },
  { 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL, InterfaceTests::__AIDA_call__UIWidgetArea__simple_method, },
  { 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL, InterfaceTests::__AIDA_call__UIWidgetArea__single_arg, },
  { 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL, InterfaceTests::__AIDA_call__UIWidgetArea__single_arg2, },
  { 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL, InterfaceTests::__AIDA_call__UIWidgetArea__two_args, },
  { 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL, InterfaceTests::__AIDA_call__UIWidgetArea__two_args2, },
  { 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL, InterfaceTests::__AIDA_call__UIWidgetArea__multi_args, },
  { 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL, InterfaceTests::__AIDA_call__UIWidgetArea__self_method, },
  { 0xdbb304ad4df15873ULL, 0xca276abf2bb1603cULL, InterfaceTests::__AIDA_call__UIWidgetArea__void_method, },
  { 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL, InterfaceTests::__AIDA_call__UIWidgetArea__on_click2out, },
  { 0x3432c3bb41bc72a0ULL, 0x533bc22135f973bfULL, InterfaceTests::__AIDA_call__UIWidgetArea__on_click2in, },
  { 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL, InterfaceTests::__AIDA_signal__UIWidgetArea__void_signal, },
  { 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL, InterfaceTests::__AIDA_signal__UIWidgetArea__sample_signal, },
  { 0xf963900935f64ed6ULL, 0x68f38589f5e75b82ULL, InterfaceTests::__AIDA_types__Parent, },
  { 0x19344291fb3e24f8ULL, 0x03c09ce7d044cddaULL, InterfaceTests::__AIDA_types__Child, },
  { 0x0c7e17cb99e7e1f5ULL, 0xf983d237de11fd86ULL, InterfaceTests::__AIDA_types__Descendant, },
  { 0xcc7a1f29efc75d7dULL, 0x8caec1b61b3388a8ULL, InterfaceTests::__AIDA_types__GrandChild, },
  { 0x0040fbcf1af9959aULL, 0x5a1fc9c92b94af9fULL, InterfaceTests::__AIDA_types__QuickIface, },
  { 0x76ac7a704663d246ULL, 0x23abac49621c6802ULL, InterfaceTests::__AIDA_call__QuickIface__simple_function, },
  { 0x61574837fdd015afULL, 0x893c7eca775ea115ULL, InterfaceTests::__AIDA_types__MethodTestInterface, },
  { 0x1addfccb0a3e01beULL, 0x314f2eb467d7a72bULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_void, },
  { 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_bools, },
  { 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_ints32, },
  { 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_ints64, },
  { 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_floats, },
  { 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_string, },
  { 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_enum, },
  { 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_record, },
  { 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_sequence, },
  { 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_interface, },
  { 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_anys, },
  { 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL, InterfaceTests::__AIDA_call__MethodTestInterface__method_with_quickiface, },
  { 0x008959b54c5d1a16ULL, 0xe2db72887f695404ULL, InterfaceTests::__AIDA_types__SignalTestInterface, },
  { 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL, InterfaceTests::__AIDA_signal__SignalTestInterface__void_result, },
  { 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL, InterfaceTests::__AIDA_signal__SignalTestInterface__bool_result, },
  { 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL, InterfaceTests::__AIDA_signal__SignalTestInterface__int32_result, },
  { 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__int64_result, },
  { 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__float64_result, },
  { 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__string_result, },
  { 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL, InterfaceTests::__AIDA_signal__SignalTestInterface__enum_result, },
  { 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__record_result, },
  { 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__sequence_result, },
  { 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__interface_result, },
  { 0x296163d4220985ceULL, 0x40daacab4a841093ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__any_result, },
  { 0x35828273200534f7ULL, 0x72873f1374d6093bULL, InterfaceTests::__AIDA_signal__SignalTestInterface__self_result, },
  { 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL, InterfaceTests::__AIDA_signal__SignalTestInterface__void_arg, },
  { 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__bool_arg, },
  { 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__int32_arg, },
  { 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__int64_arg, },
  { 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL, InterfaceTests::__AIDA_signal__SignalTestInterface__float64_arg, },
  { 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__string_arg, },
  { 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__enum_arg, },
  { 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL, InterfaceTests::__AIDA_signal__SignalTestInterface__record_arg, },
  { 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__sequence_arg, },
  { 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__interface_arg, },
  { 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL, InterfaceTests::__AIDA_signal__SignalTestInterface__any_arg, },
  { 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL, InterfaceTests::__AIDA_signal__SignalTestInterface__self_args, },
  { 0x1e3629455056e2c5ULL, 0xb0a26fd3fa379e71ULL, InterfaceTests::__AIDA_types__ChildInheritingSignals, },
  { 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL, InterfaceTests::__AIDA_signal__ChildInheritingSignals__child_signal, },
  { 0x3401a3c0d40fe0e6ULL, 0x3c6d94a03419b7caULL, InterfaceTests::__AIDA_types__AnotherChild, },
  { 0xc5c990e90dfb53e9ULL, 0x121587ef2dc3a59bULL, InterfaceTests::__AIDA_types__PropertyTester, },
  { 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL, InterfaceTests::__AIDA_get__PropertyTester__bool_prop, },
  { 0xa88d7a16adc7ad43ULL, 0x33e7a32598f08880ULL, InterfaceTests::__AIDA_set__PropertyTester__bool_prop, },
  { 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL, InterfaceTests::__AIDA_get__PropertyTester__int32_prop, },
  { 0x7b7b3182160469e4ULL, 0xbd3c44c3a57484ebULL, InterfaceTests::__AIDA_set__PropertyTester__int32_prop, },
  { 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL, InterfaceTests::__AIDA_get__PropertyTester__int64_prop, },
  { 0xb33bf89d2259a1dbULL, 0x0154420aebe9a16cULL, InterfaceTests::__AIDA_set__PropertyTester__int64_prop, },
  { 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL, InterfaceTests::__AIDA_get__PropertyTester__float64_prop, },
  { 0xf1df5bd296ac78e2ULL, 0xbb263cff89927093ULL, InterfaceTests::__AIDA_set__PropertyTester__float64_prop, },
  { 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL, InterfaceTests::__AIDA_get__PropertyTester__string_prop, },
  { 0xfadb1eed1d8d358aULL, 0x17cd2ca684080698ULL, InterfaceTests::__AIDA_set__PropertyTester__string_prop, },
  { 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL, InterfaceTests::__AIDA_get__PropertyTester__enum_prop, },
  { 0x99206fff699c82d6ULL, 0x1dcbc77498569411ULL, InterfaceTests::__AIDA_set__PropertyTester__enum_prop, },
  { 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL, InterfaceTests::__AIDA_get__PropertyTester__record_prop, },
  { 0x55aaf8cee9dd7a46ULL, 0x83d8416416740bf0ULL, InterfaceTests::__AIDA_set__PropertyTester__record_prop, },
  { 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL, InterfaceTests::__AIDA_get__PropertyTester__sequence_prop, },
  { 0xf86952a034b8bc84ULL, 0x3be169a3f0a9a07dULL, InterfaceTests::__AIDA_set__PropertyTester__sequence_prop, },
  { 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL, InterfaceTests::__AIDA_get__PropertyTester__interface_prop, },
  { 0xbf62779e2a11aebbULL, 0x95547f4e29ca3814ULL, InterfaceTests::__AIDA_set__PropertyTester__interface_prop, },
  { 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL, InterfaceTests::__AIDA_get__PropertyTester__self_prop, },
  { 0x1a1ee3ab20ab3c2fULL, 0xeeaf17826dba2891ULL, InterfaceTests::__AIDA_set__PropertyTester__self_prop, },
  { 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL, InterfaceTests::__AIDA_get__PropertyTester__any_prop, },
  { 0xe0c7d397e652f3f7ULL, 0xbbdf7826e88f4f42ULL, InterfaceTests::__AIDA_set__PropertyTester__any_prop, },
  { 0xf9fd022398187c1eULL, 0x971768152fbb4b77ULL, RapicornAidaTest::__AIDA_types__ButtonArea, },
  { 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL, RapicornAidaTest::__AIDA_get__ButtonArea__on_click, },
  { 0xdb3a24116c653985ULL, 0x2a0576faff45b4b2ULL, RapicornAidaTest::__AIDA_set__ButtonArea__on_click, },
  { 0x1b448d91990181daULL, 0x9751c08ae956c729ULL, RapicornAidaTest::__AIDA_get__ButtonArea__on_click2, },
  { 0xfc93898ba4104662ULL, 0xc918694fe5c2bfefULL, RapicornAidaTest::__AIDA_set__ButtonArea__on_click2, },
  { 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL, RapicornAidaTest::__AIDA_get__ButtonArea__on_click3, },
  { 0x1c1990dca0fde97cULL, 0x6cc2c7cc49d811f8ULL, RapicornAidaTest::__AIDA_set__ButtonArea__on_click3, },
  { 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL, RapicornAidaTest::__AIDA_get__ButtonArea__click_type, },
  { 0x1f5a6d031cb7e104ULL, 0x2d4a207f0842bec8ULL, RapicornAidaTest::__AIDA_set__ButtonArea__click_type, },
  { 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL, RapicornAidaTest::__AIDA_signal__ButtonArea__check_activate, },
  { 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL, RapicornAidaTest::__AIDA_signal__ButtonArea__activate, },
  { 0xf1b1618a8feeeadeULL, 0x37141973b72fb806ULL, RapicornAidaTest::__AIDA_types__PureMethods, },
  { 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL, RapicornAidaTest::__AIDA_call__PureMethods__pure_method, },
  { 0x501084fe2e8e5788ULL, 0x3fb86363d037fe27ULL, Other::__AIDA_types__NameTests, },
  { 0xd471f88e8c15081cULL, 0x963d2094339d0220ULL, Other::__AIDA_call__NameTests__args_from_other_namespace, },
  { 0xee0a72a933a11affULL, 0x4de21e78a41cb272ULL, BseTest::__AIDA_types__Compressor, },
  { 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL, BseTest::__AIDA_get__Compressor__threshold, },
  { 0xf40a3fd3d07b3d0bULL, 0xbae97c41e3d6a92bULL, BseTest::__AIDA_set__Compressor__threshold, },
  { 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL, BseTest::__AIDA_get__Compressor__ratio, },
  { 0x302f0b5b99a2a6c8ULL, 0xc8b771894ecd9315ULL, BseTest::__AIDA_set__Compressor__ratio, },
  { 0x008de59c242661d3ULL, 0xb91bcb9bc3832039ULL, BseTest::__AIDA_types__SoundModule, },
};
static __AIDA_Local__::MethodRegistry _aida_stub_registry (_aida_stub_entries);

} // BseTest

