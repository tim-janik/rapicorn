/* IDL test file					 	-*-mode:c++;-*-
 *
 * This work is provided "as is"; redistribution and modification
 * in whole or in part, in any medium, physical or electronic is
 * permitted without restriction.
 *
 * This work is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * In no event shall the authors or contributors be liable for any
 * direct, indirect, incidental, special, exemplary, or consequential
 * damages (including, but not limited to, procurement of substitute
 * goods or services; loss of use, data, or profits; or business
 * interruption) however caused and on any theory of liability, whether
 * in contract, strict liability, or tort (including negligence or
 * otherwise) arising in any way out of the use of this software, even
 * if advised of the possibility of such damage.
 */

// single line comment

/* multi line comment on single line */

/* multi line comment with embedded single line slashes //
// still in multi line comment
// */

;;;;;;;	// multi semicolon test

namespace EmptyNamespace1 { }

namespace EmptyNamespace2 {
;;;;;;;	// multi semicolon in namespace test
}

namespace MandatoryNamespace {

// simple constant tests
Const S = "string";
Const S2 = "concatenated" "string";
Const A = 1 + 3 * 5 + 2 ** 3 % 11 + 1.5;	// 25.5
// reassignment: Const A = 1;
// invalid: Const TRUE = 17;
Const B = A**3;					// 16581.375
Const C = 5;
Const D = (5);
Const E = 5 * (3 + 4);                          // 35
Const F = 5 * 3 + 4;                            // 19
Const G = (5 * 3 + 4);                          // 19
Const Signs = +1 + -2 + - -3 - +-+-+-+-+- 4;    // 6
Const Pows = 1**1 - -1**1 + 1**-1 - -1**-1 - -(1 + 1)**-(1 + 1) + +1**+1;
Const Floats = 0 + 0. + .0 + 1. + 10. + .011 + 101. + 1.1e+1 + .1e+1 + 1e-1 + 1E+1 + 1E-1 + 1e+01 + 1e-02; // 144.221
Const Vint = 42;

/* test that C++ style commments are properly ignored within strings */
Const CXX_COMMENT_TEST_1 = "Foo // bar";
Const CXX_COMMENT_TEST_2 = "Foo \" // bar";
Const CXX_COMMENT_TEST_3 = "Foo \\";//bar
Const CXX_COMMENT_TEST_4 = "Foo /**/ bar";
Const CXX_COMMENT_TEST_5 = "Foo /*//*/ bar";
Const CXX_COMMENT_TEST_6 = "Foo /* */ */ bar";
Const CXX_COMMENT_TEST_7 = "Foo /* /* /* bar";
Const CXX_COMMENT_TEST_8 = "Foo /* /* */ /* bar";
Const String1 = "1";
Const String2 = "2";
Const String3 = "first" "+" "second";
Const String4 = "" String1 "+" String2;
Const Vistring = _("foo");
// Const tmp = "" Vistring "error: i18n string concatenation";
Const Vstring = "foo";

// enumerations
enumeration Empty  { };
enumeration Enum1  { E1_A };
enumeration Enum1c { E1C_A, };
enumeration Enum2  { E2_A,  E2_B };
enumeration Enum2c { E2C_A, E2C_B, };
enumeration Enum3  { E3_A,  E3_B,  E3_C };
enumeration Enum3c { E3C_A, E3C_B, E3C_C, };
enumeration Enum4a { E4A_A, E4A_B, E4A_C, E4A_D  /**/ };
enumeration Enum4b { E4B_A, E4B_B, E4B_C, E4B_D, /**/ };
enumeration Enum4c { E4C_A, E4C_B, E4C_C, E4C_D  //
                       };
enumeration Enum4d { E4D_A, E4D_B, E4D_C, E4D_D, //
                       };

// enumeration arguments
enum ExtensiveEnum {
  V1a,  // 1
  V1b =  1,
  V2  = (2),
  V3  = (3,   "v3"),
  V4  = (4, _("v4")),
  V5  = (5,   "v5",    "V5"),
  V6  = (6, _("v6"),   "V6"),
  V7  = (7,   "v7",  _("V7")),
  V8  = (8, _("v8"), _("V8")),
  V9  = (((9))),
  /* check string expressions */
  V10 =    "v10",
  V11 =  _("v11"),
  V12 = (  "v12"),
  V13,
  V14 = (_("v14")),
  V15 = (  "v15",    "V15"),
  V16 = (_("v16"),   "V16"),
  V17 = (  "v17",  _("V17")),
  V18 = (_("v18"), _("V18")),
  /* check number parsing */
  V20 = 20,
  V21 = -(-20 - - + -1),
  V22 = 2 * 10 + 2,
  V23 = 2 * (5 + 5) + 3,
  V24 = 2 ** 4 + 8,
  V25 = -2 ** (2 + 2),
  V26 = +(2 ** (2 + 2)),
  V27 = -(2 ** (2 + 2)),
  V28 = - /*comment*/ (28),
  /* constants */
  V30 = Vint,
  V31 = Vstring,
  V32 = (Vint),
  V33 = (Vstring),
  V34 = (Vstring, Vstring),
  V35 = (Vint, Vstring),
  V36 = (Vint, Vstring, Vstring "4"),
};
// reassignment: Const V36 = 36;
Const enum_math = V36 + V34 + V24 + V13 + V3;

// record tests
record XFooRecord {
  Bool   single_bool;
  Num    single_num;
  Real   single_float;
  String single_string;
  Num    sibling1;
  Num    sibling2;
  Num    multi1;
  Num    multi2;
  Num    multi3;
  Num    multi4;
  ExtensiveEnum enum_field;
};

// sequence tests
sequence XFooSequence {
  Bool   single_bool;
};
sequence ExtensiveEnumSequence {
  ExtensiveEnum enum_elements;
};

// test nested types
record NestedTypesRec {
  XFooRecord    rec;
  XFooSequence  seq;
};
sequence NestedTypesSeq {
  NestedTypesRec ntr;
};

// typedef tests
typedef Num  AliasNum;
typedef Real AliasReal;
typedef Bool AliasBool;
typedef String AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;

} // MandatoryNamespace

// Test namespace continuation
namespace MandatoryNamespace {
record NewRecord {
  Num            i;
  Enum1          enum1;
  XFooSequence   xfs;
  NestedTypesRec ntr;
};

// namespace nesting
namespace Inner {
record InnerRecord {
  Num           x;
  Num           y;
  NewRecord     rec;
};
} // Inner

record Refer2Inner {
  Inner::InnerRecord r;
};

} // MandatoryNamespace

// cross-namespace references
namespace OtherNamespace {
record SomeRecord {
  MandatoryNamespace::NewRecord            r1;
  ::MandatoryNamespace::NewRecord          r2;
  MandatoryNamespace::Inner::InnerRecord   r3;
  ::MandatoryNamespace::Inner::InnerRecord r4;
};
}

// references to outer namespaces
namespace Outer {
Const FromOuter = 3;
namespace Middle {
Const FromMiddle = 2;
namespace Inner {
Const FromInner = 1;
Const dummy = FromInner + FromMiddle + FromOuter;
} // Outer::Middle::Inner
} // Outer::Middle
} // Outer

// Auxdata tests
namespace Auxdata {
// FIXME: can't check auxdata of record fields yet
//record RecordWithAuxdata {
  typedef Num bar  = Num ("Bar", "The Bar number", 10007.000, -10, +10, +2, "rw");
  typedef Real x   = Real ("auxtest1", "X coordinate", 0, 0, 100.0, +.5, "ro");
  typedef String s = String ("auxtest2", "Specify text here", "auxtest3", "rw");
//};
}

namespace InterfaceTests {
interface ButtonArea {
  Real dummy;
  Real simple_method ();
  Real single_arg (Num n);
  Real single_arg2 (Num n = Num ("Baz"));
  Real two_args (Num n, Real r);
  Real two_args2 (Num n = Num ("Baz"), Real r = Real ("Zonk"));
  Real multi_args (Num n, Real r, Num i, String s = String ("String ding"), Real y);
  Real self_method (ButtonArea ba1, InterfaceTests::ButtonArea ba2);
  signal Real sample_signal (ButtonArea ba1, Num someint);
};
interface Parent {};
interface Child : Parent {}; // interface inheritance
interface Descendant : Parent, Child {}; // multiple interface inheritance
interface GrandChild : Parent, Child, Descendant {}; // multiple interface inheritance
}
